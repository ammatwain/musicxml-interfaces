"use strict";
// Auto-generated by writeBuilders.js. Modification is unwise.
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildDashedFormatting = exports.patchDashedFormatting = exports.buildLineType = exports.patchLineType = exports.buildLineShape = exports.patchLineShape = exports.buildPrintStyleAlign = exports.patchPrintStyleAlign = exports.buildPrintStyle = exports.patchPrintStyle = exports.buildEnclosure = exports.patchEnclosure = exports.buildTextRotation = exports.patchTextRotation = exports.buildTextDirection = exports.patchTextDirection = exports.buildLineHeight = exports.patchLineHeight = exports.buildLetterSpacing = exports.patchLetterSpacing = exports.buildValignImage = exports.patchValignImage = exports.buildValign = exports.patchValign = exports.buildHalign = exports.patchHalign = exports.buildJustify = exports.patchJustify = exports.buildTextDecoration = exports.patchTextDecoration = exports.buildColor = exports.patchColor = exports.buildFont = exports.patchFont = exports.buildBezier = exports.patchBezier = exports.buildDirectiveEntity = exports.patchDirectiveEntity = exports.buildOrientation = exports.patchOrientation = exports.buildPlacement = exports.patchPlacement = exports.buildPosition = exports.patchPosition = exports.buildCalendarDate = exports.patchCalendarDate = exports.buildEncodingDate = exports.patchEncodingDate = exports.buildTextSegment = exports.patchTextSegment = void 0;
exports.buildPartNameDisplay = exports.patchPartNameDisplay = exports.buildAccidentalText = exports.patchAccidentalText = exports.buildDisplayText = exports.patchDisplayText = exports.buildString = exports.patchString = exports.buildFret = exports.patchFret = exports.buildFingering = exports.patchFingering = exports.buildDynamics = exports.patchDynamics = exports.buildNormalDot = exports.patchNormalDot = exports.buildCoda = exports.patchCoda = exports.buildSegno = exports.patchSegno = exports.buildWavyLine = exports.patchWavyLine = exports.buildFermata = exports.patchFermata = exports.buildLevel = exports.patchLevel = exports.buildFootnote = exports.patchFootnote = exports.buildEditorialVoice = exports.patchEditorialVoice = exports.buildEditorial = exports.patchEditorial = exports.buildDocumentAttributes = exports.patchDocumentAttributes = exports.buildTimeOnly = exports.patchTimeOnly = exports.buildBendSound = exports.patchBendSound = exports.buildTrillSound = exports.patchTrillSound = exports.buildLevelDisplay = exports.patchLevelDisplay = exports.buildTextFormatting = exports.patchTextFormatting = exports.buildPrintout = exports.patchPrintout = exports.buildPrintSpacing = exports.patchPrintSpacing = exports.buildPrintObject = exports.patchPrintObject = void 0;
exports.buildMiscellaneous = exports.patchMiscellaneous = exports.buildMiscellaneousField = exports.patchMiscellaneousField = exports.buildRelation = exports.patchRelation = exports.buildEncoder = exports.patchEncoder = exports.buildRights = exports.patchRights = exports.buildCreator = exports.patchCreator = exports.buildAppearance = exports.patchAppearance = exports.buildDistance = exports.patchDistance = exports.buildNoteSize = exports.patchNoteSize = exports.buildLineWidth = exports.patchLineWidth = exports.buildMeasureLayout = exports.patchMeasureLayout = exports.buildStaffLayout = exports.patchStaffLayout = exports.buildRightDivider = exports.patchRightDivider = exports.buildLeftDivider = exports.patchLeftDivider = exports.buildSystemDividers = exports.patchSystemDividers = exports.buildSystemMargins = exports.patchSystemMargins = exports.buildSystemLayout = exports.patchSystemLayout = exports.buildPageLayout = exports.patchPageLayout = exports.buildPageMargins = exports.patchPageMargins = exports.buildScaling = exports.patchScaling = exports.buildOtherPlay = exports.patchOtherPlay = exports.buildPlay = exports.patchPlay = exports.buildMidiInstrument = exports.patchMidiInstrument = exports.buildMidiDevice = exports.patchMidiDevice = exports.buildPartAbbreviationDisplay = exports.patchPartAbbreviationDisplay = void 0;
exports.buildCue = exports.patchCue = exports.buildAttributes = exports.patchAttributes = exports.buildMeasureStyle = exports.patchMeasureStyle = exports.buildSlash = exports.patchSlash = exports.buildBeatRepeat = exports.patchBeatRepeat = exports.buildMeasureRepeat = exports.patchMeasureRepeat = exports.buildMultipleRest = exports.patchMultipleRest = exports.buildSlashDot = exports.patchSlashDot = exports.buildDirective = exports.patchDirective = exports.buildTranspose = exports.patchTranspose = exports.buildDouble = exports.patchDouble = exports.buildStaffDetails = exports.patchStaffDetails = exports.buildStaffTuning = exports.patchStaffTuning = exports.buildClef = exports.patchClef = exports.buildPartSymbol = exports.patchPartSymbol = exports.buildInterchangeable = exports.patchInterchangeable = exports.buildTime = exports.patchTime = exports.buildKey = exports.patchKey = exports.buildKeyOctave = exports.patchKeyOctave = exports.buildCancel = exports.patchCancel = exports.buildTimeSymbol = exports.patchTimeSymbol = exports.buildTimeSeparator = exports.patchTimeSeparator = exports.buildEncoding = exports.patchEncoding = exports.buildSupports = exports.patchSupports = exports.buildIdentification = exports.patchIdentification = void 0;
exports.buildTupletType = exports.patchTupletType = exports.buildTupletNumber = exports.patchTupletNumber = exports.buildTupletNormal = exports.patchTupletNormal = exports.buildTupletActual = exports.patchTupletActual = exports.buildTuplet = exports.patchTuplet = exports.buildSlur = exports.patchSlur = exports.buildTied = exports.patchTied = exports.buildNotations = exports.patchNotations = exports.buildBeam = exports.patchBeam = exports.buildNoteheadText = exports.patchNoteheadText = exports.buildNotehead = exports.patchNotehead = exports.buildStem = exports.patchStem = exports.buildTimeModification = exports.patchTimeModification = exports.buildAccidental = exports.patchAccidental = exports.buildDot = exports.patchDot = exports.buildType = exports.patchType = exports.buildNote = exports.patchNote = exports.buildInstrument = exports.patchInstrument = exports.buildTie = exports.patchTie = exports.buildRest = exports.patchRest = exports.buildFullNote = exports.patchFullNote = exports.buildPitch = exports.patchPitch = exports.buildUnpitched = exports.patchUnpitched = exports.buildChord = exports.patchChord = exports.buildGrace = exports.patchGrace = void 0;
exports.buildThumbPosition = exports.patchThumbPosition = exports.buildOpenString = exports.patchOpenString = exports.buildHarmonic = exports.patchHarmonic = exports.buildDownBow = exports.patchDownBow = exports.buildUpBow = exports.patchUpBow = exports.buildTechnical = exports.patchTechnical = exports.buildAccidentalMark = exports.patchAccidentalMark = exports.buildOtherOrnament = exports.patchOtherOrnament = exports.buildTremolo = exports.patchTremolo = exports.buildSchleifer = exports.patchSchleifer = exports.buildInvertedMordent = exports.patchInvertedMordent = exports.buildMordent = exports.patchMordent = exports.buildShake = exports.patchShake = exports.buildVerticalTurn = exports.patchVerticalTurn = exports.buildDelayedInvertedTurn = exports.patchDelayedInvertedTurn = exports.buildInvertedTurn = exports.patchInvertedTurn = exports.buildDelayedTurn = exports.patchDelayedTurn = exports.buildTurn = exports.patchTurn = exports.buildTrillMark = exports.patchTrillMark = exports.buildOrnaments = exports.patchOrnaments = exports.buildOtherDirection = exports.patchOtherDirection = exports.buildOtherNotation = exports.patchOtherNotation = exports.buildSlide = exports.patchSlide = exports.buildGlissando = exports.patchGlissando = exports.buildTupletDot = exports.patchTupletDot = void 0;
exports.buildStaccatissimo = exports.patchStaccatissimo = exports.buildDetachedLegato = exports.patchDetachedLegato = exports.buildTenuto = exports.patchTenuto = exports.buildStaccato = exports.patchStaccato = exports.buildStrongAccent = exports.patchStrongAccent = exports.buildAccent = exports.patchAccent = exports.buildArticulations = exports.patchArticulations = exports.buildOtherTechnical = exports.patchOtherTechnical = exports.buildHandbell = exports.patchHandbell = exports.buildArrow = exports.patchArrow = exports.buildHoleClosed = exports.patchHoleClosed = exports.buildHole = exports.patchHole = exports.buildFingernails = exports.patchFingernails = exports.buildToe = exports.patchToe = exports.buildHeel = exports.patchHeel = exports.buildTap = exports.patchTap = exports.buildWithBar = exports.patchWithBar = exports.buildBend = exports.patchBend = exports.buildPullOff = exports.patchPullOff = exports.buildHammerOn = exports.patchHammerOn = exports.buildSnapPizzicato = exports.patchSnapPizzicato = exports.buildStopped = exports.patchStopped = exports.buildTripleTongue = exports.patchTripleTongue = exports.buildDoubleTongue = exports.patchDoubleTongue = exports.buildPluck = exports.patchPluck = void 0;
exports.buildPrefix = exports.patchPrefix = exports.buildFigure = exports.patchFigure = exports.buildFiguredBass = exports.patchFiguredBass = exports.buildExtend = exports.patchExtend = exports.buildElision = exports.patchElision = exports.buildSyllabic = exports.patchSyllabic = exports.buildText = exports.patchText = exports.buildLyric = exports.patchLyric = exports.buildLyricParts = exports.patchLyricParts = exports.buildEndParagraph = exports.patchEndParagraph = exports.buildEndLine = exports.patchEndLine = exports.buildHumming = exports.patchHumming = exports.buildLaughing = exports.patchLaughing = exports.buildNonArpeggiate = exports.patchNonArpeggiate = exports.buildArpeggiate = exports.patchArpeggiate = exports.buildOtherArticulation = exports.patchOtherArticulation = exports.buildUnstress = exports.patchUnstress = exports.buildStress = exports.patchStress = exports.buildCaesura = exports.patchCaesura = exports.buildBreathMark = exports.patchBreathMark = exports.buildFalloff = exports.patchFalloff = exports.buildDoit = exports.patchDoit = exports.buildPlop = exports.patchPlop = exports.buildScoop = exports.patchScoop = exports.buildSpiccato = exports.patchSpiccato = void 0;
exports.buildHarpPedals = exports.patchHarpPedals = exports.buildOctaveShift = exports.patchOctaveShift = exports.buildMetronomeTuplet = exports.patchMetronomeTuplet = exports.buildMetronomeBeam = exports.patchMetronomeBeam = exports.buildMetronomeDot = exports.patchMetronomeDot = exports.buildMetronomeNote = exports.patchMetronomeNote = exports.buildPerMinute = exports.patchPerMinute = exports.buildBeatUnitDot = exports.patchBeatUnitDot = exports.buildMetronome = exports.patchMetronome = exports.buildPedal = exports.patchPedal = exports.buildBracket = exports.patchBracket = exports.buildDashes = exports.patchDashes = exports.buildWedge = exports.patchWedge = exports.buildWords = exports.patchWords = exports.buildRehearsal = exports.patchRehearsal = exports.buildDirectionType = exports.patchDirectionType = exports.buildDirection = exports.patchDirection = exports.buildRepeat = exports.patchRepeat = exports.buildEnding = exports.patchEnding = exports.buildBarStyle = exports.patchBarStyle = exports.buildBarline = exports.patchBarline = exports.buildForward = exports.patchForward = exports.buildBackup = exports.patchBackup = exports.buildSuffix = exports.patchSuffix = exports.buildFigureNumber = exports.patchFigureNumber = void 0;
exports.buildBassStep = exports.patchBassStep = exports.buildBass = exports.patchBass = exports.buildInversion = exports.patchInversion = exports.buildKind = exports.patchKind = exports.buildFunction = exports.patchFunction = exports.buildRootAlter = exports.patchRootAlter = exports.buildRootStep = exports.patchRootStep = exports.buildRoot = exports.patchRoot = exports.buildHarmony = exports.patchHarmony = exports.buildHarmonyChord = exports.patchHarmonyChord = exports.buildOffset = exports.patchOffset = exports.buildStick = exports.patchStick = exports.buildBeater = exports.patchBeater = exports.buildTimpani = exports.patchTimpani = exports.buildPercussion = exports.patchPercussion = exports.buildAccordionRegistration = exports.patchAccordionRegistration = exports.buildPrincipalVoice = exports.patchPrincipalVoice = exports.buildImage = exports.patchImage = exports.buildAccord = exports.patchAccord = exports.buildScordatura = exports.patchScordatura = exports.buildStringMute = exports.patchStringMute = exports.buildEyeglasses = exports.patchEyeglasses = exports.buildDampAll = exports.patchDampAll = exports.buildDamp = exports.patchDamp = exports.buildPedalTuning = exports.patchPedalTuning = void 0;
exports.buildScorePart = exports.patchScorePart = exports.buildCreditImage = exports.patchCreditImage = exports.buildCreditWords = exports.patchCreditWords = exports.buildCredit = exports.patchCredit = exports.buildLyricLanguage = exports.patchLyricLanguage = exports.buildLyricFont = exports.patchLyricFont = exports.buildWordFont = exports.patchWordFont = exports.buildMusicFont = exports.patchMusicFont = exports.buildDefaults = exports.patchDefaults = exports.buildOpus = exports.patchOpus = exports.buildWork = exports.patchWork = exports.buildSound = exports.patchSound = exports.buildMeasureNumbering = exports.patchMeasureNumbering = exports.buildPrint = exports.patchPrint = exports.buildFeature = exports.patchFeature = exports.buildGrouping = exports.patchGrouping = exports.buildBarre = exports.patchBarre = exports.buildFrameNote = exports.patchFrameNote = exports.buildFirstFret = exports.patchFirstFret = exports.buildFrame = exports.patchFrame = exports.buildDegreeType = exports.patchDegreeType = exports.buildDegreeAlter = exports.patchDegreeAlter = exports.buildDegreeValue = exports.patchDegreeValue = exports.buildDegree = exports.patchDegree = exports.buildBassAlter = exports.patchBassAlter = void 0;
exports.buildMeasure = exports.patchMeasure = exports.buildScoreTimewise = exports.patchScoreTimewise = exports.buildScoreHeader = exports.patchScoreHeader = exports.buildVirtualInstrument = exports.patchVirtualInstrument = exports.buildSolo = exports.patchSolo = exports.buildScoreInstrument = exports.patchScoreInstrument = exports.buildGroupTime = exports.patchGroupTime = exports.buildGroupBarline = exports.patchGroupBarline = exports.buildGroupSymbol = exports.patchGroupSymbol = exports.buildGroupAbbreviationDisplay = exports.patchGroupAbbreviationDisplay = exports.buildGroupAbbreviation = exports.patchGroupAbbreviation = exports.buildGroupNameDisplay = exports.patchGroupNameDisplay = exports.buildGroupName = exports.patchGroupName = exports.buildPartGroup = exports.patchPartGroup = exports.buildPartAbbreviation = exports.patchPartAbbreviation = exports.buildPartName = exports.patchPartName = void 0;
function makePatch(original, updates, childBuilders, explicitPatches, modifiedKeys) {
    if (!original)
        return [{ p: [], oi: updates }].concat(explicitPatches);
    let patches = Object.keys(modifiedKeys).map(key => {
        if (childBuilders[key] !== undefined)
            return;
        if (updates[key] === original[key] || updates[key] !== updates[key] && original[key] !== original[key])
            return;
        if (updates[key] === undefined)
            return { p: [key], od: original[key] };
        if (original[key] === undefined)
            return { p: [key], oi: updates[key] };
        return { p: [key], od: original[key], oi: updates[key] };
    }).filter(p => Boolean(p));
    Object.keys(childBuilders).map(key => {
        if (original[key] === undefined) {
            patches.push({ p: [key], oi: childBuilders[key].build() });
        }
        else {
            let subpatches = childBuilders[key].patch().map(patch => {
                patch.p = [key].concat(patch.p);
                return patch;
            });
            patches = patches.concat(subpatches);
        }
    });
    return patches.concat(explicitPatches);
}
class TextSegmentBuilder {
    build;
    patch;
    acc;
    text;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "TextSegment";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.acc = (build) => {
            if (typeof build === 'function') {
                delete updates["acc"];
                const builder = build(new AccidentalTextBuilder(original && original["acc"]));
                if (!original)
                    updates["acc"] = builder.build();
                else
                    childBuilders["acc"] = builder;
            }
            else {
                updates.acc = build;
                delete childBuilders["acc;"];
            }
            modifiedKeys["acc"] = true;
            return this;
        };
        this.text = (build) => {
            if (typeof build === 'function') {
                delete updates["text"];
                const builder = build(new DisplayTextBuilder(original && original["text"]));
                if (!original)
                    updates["text"] = builder.build();
                else
                    childBuilders["text"] = builder;
            }
            else {
                updates.text = build;
                delete childBuilders["text;"];
            }
            modifiedKeys["text"] = true;
            return this;
        };
    }
}
function patchTextSegment(base, builder) { return builder(new TextSegmentBuilder(base)).patch(); }
exports.patchTextSegment = patchTextSegment;
function buildTextSegment(builder) { return builder(new TextSegmentBuilder()).build(); }
exports.buildTextSegment = buildTextSegment;
class EncodingDateBuilder {
    build;
    patch;
    month;
    day;
    year;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["month"]) ||
                childBuilders["month"] !== undefined ||
                updates.month !== undefined, "month is a required field");
            console.assert((original && !modifiedKeys["day"]) ||
                childBuilders["day"] !== undefined ||
                updates.day !== undefined, "day is a required field");
            console.assert((original && !modifiedKeys["year"]) ||
                childBuilders["year"] !== undefined ||
                updates.year !== undefined, "year is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "EncodingDate";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.month = (spec) => {
            updates["month"] = spec;
            delete childBuilders["month;"];
            modifiedKeys["month"] = true;
            return this;
        };
        this.day = (spec) => {
            updates["day"] = spec;
            delete childBuilders["day;"];
            modifiedKeys["day"] = true;
            return this;
        };
        this.year = (spec) => {
            updates["year"] = spec;
            delete childBuilders["year;"];
            modifiedKeys["year"] = true;
            return this;
        };
    }
}
function patchEncodingDate(base, builder) { return builder(new EncodingDateBuilder(base)).patch(); }
exports.patchEncodingDate = patchEncodingDate;
function buildEncodingDate(builder) { return builder(new EncodingDateBuilder()).build(); }
exports.buildEncodingDate = buildEncodingDate;
class CalendarDateBuilder {
    build;
    patch;
    month;
    day;
    year;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["month"]) ||
                childBuilders["month"] !== undefined ||
                updates.month !== undefined, "month is a required field");
            console.assert((original && !modifiedKeys["day"]) ||
                childBuilders["day"] !== undefined ||
                updates.day !== undefined, "day is a required field");
            console.assert((original && !modifiedKeys["year"]) ||
                childBuilders["year"] !== undefined ||
                updates.year !== undefined, "year is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "CalendarDate";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.month = (spec) => {
            updates["month"] = spec;
            delete childBuilders["month;"];
            modifiedKeys["month"] = true;
            return this;
        };
        this.day = (spec) => {
            updates["day"] = spec;
            delete childBuilders["day;"];
            modifiedKeys["day"] = true;
            return this;
        };
        this.year = (spec) => {
            updates["year"] = spec;
            delete childBuilders["year;"];
            modifiedKeys["year"] = true;
            return this;
        };
    }
}
function patchCalendarDate(base, builder) { return builder(new CalendarDateBuilder(base)).patch(); }
exports.patchCalendarDate = patchCalendarDate;
function buildCalendarDate(builder) { return builder(new CalendarDateBuilder()).build(); }
exports.buildCalendarDate = buildCalendarDate;
class PositionBuilder {
    build;
    patch;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Position";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
    }
}
function patchPosition(base, builder) { return builder(new PositionBuilder(base)).patch(); }
exports.patchPosition = patchPosition;
function buildPosition(builder) { return builder(new PositionBuilder()).build(); }
exports.buildPosition = buildPosition;
class PlacementBuilder {
    build;
    patch;
    placement;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Placement";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.placement = (spec) => {
            updates["placement"] = spec;
            delete childBuilders["placement;"];
            modifiedKeys["placement"] = true;
            return this;
        };
    }
}
function patchPlacement(base, builder) { return builder(new PlacementBuilder(base)).patch(); }
exports.patchPlacement = patchPlacement;
function buildPlacement(builder) { return builder(new PlacementBuilder()).build(); }
exports.buildPlacement = buildPlacement;
class OrientationBuilder {
    build;
    patch;
    orientation;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Orientation";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.orientation = (spec) => {
            updates["orientation"] = spec;
            delete childBuilders["orientation;"];
            modifiedKeys["orientation"] = true;
            return this;
        };
    }
}
function patchOrientation(base, builder) { return builder(new OrientationBuilder(base)).patch(); }
exports.patchOrientation = patchOrientation;
function buildOrientation(builder) { return builder(new OrientationBuilder()).build(); }
exports.buildOrientation = buildOrientation;
class DirectiveEntityBuilder {
    build;
    patch;
    directive;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "DirectiveEntity";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.directive = (spec) => {
            updates["directive"] = spec;
            delete childBuilders["directive;"];
            modifiedKeys["directive"] = true;
            return this;
        };
    }
}
function patchDirectiveEntity(base, builder) { return builder(new DirectiveEntityBuilder(base)).patch(); }
exports.patchDirectiveEntity = patchDirectiveEntity;
function buildDirectiveEntity(builder) { return builder(new DirectiveEntityBuilder()).build(); }
exports.buildDirectiveEntity = buildDirectiveEntity;
class BezierBuilder {
    build;
    patch;
    bezierX2;
    bezierOffset;
    bezierOffset2;
    bezierX;
    bezierY;
    bezierY2;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Bezier";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.bezierX2 = (spec) => {
            updates["bezierX2"] = spec;
            delete childBuilders["bezierX2;"];
            modifiedKeys["bezierX2"] = true;
            return this;
        };
        this.bezierOffset = (spec) => {
            updates["bezierOffset"] = spec;
            delete childBuilders["bezierOffset;"];
            modifiedKeys["bezierOffset"] = true;
            return this;
        };
        this.bezierOffset2 = (spec) => {
            updates["bezierOffset2"] = spec;
            delete childBuilders["bezierOffset2;"];
            modifiedKeys["bezierOffset2"] = true;
            return this;
        };
        this.bezierX = (spec) => {
            updates["bezierX"] = spec;
            delete childBuilders["bezierX;"];
            modifiedKeys["bezierX"] = true;
            return this;
        };
        this.bezierY = (spec) => {
            updates["bezierY"] = spec;
            delete childBuilders["bezierY;"];
            modifiedKeys["bezierY"] = true;
            return this;
        };
        this.bezierY2 = (spec) => {
            updates["bezierY2"] = spec;
            delete childBuilders["bezierY2;"];
            modifiedKeys["bezierY2"] = true;
            return this;
        };
    }
}
function patchBezier(base, builder) { return builder(new BezierBuilder(base)).patch(); }
exports.patchBezier = patchBezier;
function buildBezier(builder) { return builder(new BezierBuilder()).build(); }
exports.buildBezier = buildBezier;
class FontBuilder {
    build;
    patch;
    fontFamily;
    fontWeight;
    fontStyle;
    fontSize;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Font";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.fontFamily = (spec) => {
            updates["fontFamily"] = spec;
            delete childBuilders["fontFamily;"];
            modifiedKeys["fontFamily"] = true;
            return this;
        };
        this.fontWeight = (spec) => {
            updates["fontWeight"] = spec;
            delete childBuilders["fontWeight;"];
            modifiedKeys["fontWeight"] = true;
            return this;
        };
        this.fontStyle = (spec) => {
            updates["fontStyle"] = spec;
            delete childBuilders["fontStyle;"];
            modifiedKeys["fontStyle"] = true;
            return this;
        };
        this.fontSize = (spec) => {
            updates["fontSize"] = spec;
            delete childBuilders["fontSize;"];
            modifiedKeys["fontSize"] = true;
            return this;
        };
    }
}
function patchFont(base, builder) { return builder(new FontBuilder(base)).patch(); }
exports.patchFont = patchFont;
function buildFont(builder) { return builder(new FontBuilder()).build(); }
exports.buildFont = buildFont;
class ColorBuilder {
    build;
    patch;
    color;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Color";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
    }
}
function patchColor(base, builder) { return builder(new ColorBuilder(base)).patch(); }
exports.patchColor = patchColor;
function buildColor(builder) { return builder(new ColorBuilder()).build(); }
exports.buildColor = buildColor;
class TextDecorationBuilder {
    build;
    patch;
    underline;
    overline;
    lineThrough;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "TextDecoration";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.underline = (spec) => {
            updates["underline"] = spec;
            delete childBuilders["underline;"];
            modifiedKeys["underline"] = true;
            return this;
        };
        this.overline = (spec) => {
            updates["overline"] = spec;
            delete childBuilders["overline;"];
            modifiedKeys["overline"] = true;
            return this;
        };
        this.lineThrough = (spec) => {
            updates["lineThrough"] = spec;
            delete childBuilders["lineThrough;"];
            modifiedKeys["lineThrough"] = true;
            return this;
        };
    }
}
function patchTextDecoration(base, builder) { return builder(new TextDecorationBuilder(base)).patch(); }
exports.patchTextDecoration = patchTextDecoration;
function buildTextDecoration(builder) { return builder(new TextDecorationBuilder()).build(); }
exports.buildTextDecoration = buildTextDecoration;
class JustifyBuilder {
    build;
    patch;
    justify;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Justify";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.justify = (spec) => {
            updates["justify"] = spec;
            delete childBuilders["justify;"];
            modifiedKeys["justify"] = true;
            return this;
        };
    }
}
function patchJustify(base, builder) { return builder(new JustifyBuilder(base)).patch(); }
exports.patchJustify = patchJustify;
function buildJustify(builder) { return builder(new JustifyBuilder()).build(); }
exports.buildJustify = buildJustify;
class HalignBuilder {
    build;
    patch;
    halign;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Halign";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.halign = (spec) => {
            updates["halign"] = spec;
            delete childBuilders["halign;"];
            modifiedKeys["halign"] = true;
            return this;
        };
    }
}
function patchHalign(base, builder) { return builder(new HalignBuilder(base)).patch(); }
exports.patchHalign = patchHalign;
function buildHalign(builder) { return builder(new HalignBuilder()).build(); }
exports.buildHalign = buildHalign;
class ValignBuilder {
    build;
    patch;
    valign;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Valign";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.valign = (spec) => {
            updates["valign"] = spec;
            delete childBuilders["valign;"];
            modifiedKeys["valign"] = true;
            return this;
        };
    }
}
function patchValign(base, builder) { return builder(new ValignBuilder(base)).patch(); }
exports.patchValign = patchValign;
function buildValign(builder) { return builder(new ValignBuilder()).build(); }
exports.buildValign = buildValign;
class ValignImageBuilder {
    build;
    patch;
    valignImage;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "ValignImage";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.valignImage = (spec) => {
            updates["valignImage"] = spec;
            delete childBuilders["valignImage;"];
            modifiedKeys["valignImage"] = true;
            return this;
        };
    }
}
function patchValignImage(base, builder) { return builder(new ValignImageBuilder(base)).patch(); }
exports.patchValignImage = patchValignImage;
function buildValignImage(builder) { return builder(new ValignImageBuilder()).build(); }
exports.buildValignImage = buildValignImage;
class LetterSpacingBuilder {
    build;
    patch;
    letterSpacing;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "LetterSpacing";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.letterSpacing = (spec) => {
            updates["letterSpacing"] = spec;
            delete childBuilders["letterSpacing;"];
            modifiedKeys["letterSpacing"] = true;
            return this;
        };
    }
}
function patchLetterSpacing(base, builder) { return builder(new LetterSpacingBuilder(base)).patch(); }
exports.patchLetterSpacing = patchLetterSpacing;
function buildLetterSpacing(builder) { return builder(new LetterSpacingBuilder()).build(); }
exports.buildLetterSpacing = buildLetterSpacing;
class LineHeightBuilder {
    build;
    patch;
    lineHeight;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "LineHeight";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.lineHeight = (spec) => {
            updates["lineHeight"] = spec;
            delete childBuilders["lineHeight;"];
            modifiedKeys["lineHeight"] = true;
            return this;
        };
    }
}
function patchLineHeight(base, builder) { return builder(new LineHeightBuilder(base)).patch(); }
exports.patchLineHeight = patchLineHeight;
function buildLineHeight(builder) { return builder(new LineHeightBuilder()).build(); }
exports.buildLineHeight = buildLineHeight;
class TextDirectionBuilder {
    build;
    patch;
    dir;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "TextDirection";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.dir = (spec) => {
            updates["dir"] = spec;
            delete childBuilders["dir;"];
            modifiedKeys["dir"] = true;
            return this;
        };
    }
}
function patchTextDirection(base, builder) { return builder(new TextDirectionBuilder(base)).patch(); }
exports.patchTextDirection = patchTextDirection;
function buildTextDirection(builder) { return builder(new TextDirectionBuilder()).build(); }
exports.buildTextDirection = buildTextDirection;
class TextRotationBuilder {
    build;
    patch;
    rotation;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "TextRotation";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.rotation = (spec) => {
            updates["rotation"] = spec;
            delete childBuilders["rotation;"];
            modifiedKeys["rotation"] = true;
            return this;
        };
    }
}
function patchTextRotation(base, builder) { return builder(new TextRotationBuilder(base)).patch(); }
exports.patchTextRotation = patchTextRotation;
function buildTextRotation(builder) { return builder(new TextRotationBuilder()).build(); }
exports.buildTextRotation = buildTextRotation;
class EnclosureBuilder {
    build;
    patch;
    enclosure;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Enclosure";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.enclosure = (spec) => {
            updates["enclosure"] = spec;
            delete childBuilders["enclosure;"];
            modifiedKeys["enclosure"] = true;
            return this;
        };
    }
}
function patchEnclosure(base, builder) { return builder(new EnclosureBuilder(base)).patch(); }
exports.patchEnclosure = patchEnclosure;
function buildEnclosure(builder) { return builder(new EnclosureBuilder()).build(); }
exports.buildEnclosure = buildEnclosure;
class PrintStyleBuilder {
    build;
    patch;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    fontFamily;
    fontWeight;
    fontStyle;
    fontSize;
    color;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "PrintStyle";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
        this.fontFamily = (spec) => {
            updates["fontFamily"] = spec;
            delete childBuilders["fontFamily;"];
            modifiedKeys["fontFamily"] = true;
            return this;
        };
        this.fontWeight = (spec) => {
            updates["fontWeight"] = spec;
            delete childBuilders["fontWeight;"];
            modifiedKeys["fontWeight"] = true;
            return this;
        };
        this.fontStyle = (spec) => {
            updates["fontStyle"] = spec;
            delete childBuilders["fontStyle;"];
            modifiedKeys["fontStyle"] = true;
            return this;
        };
        this.fontSize = (spec) => {
            updates["fontSize"] = spec;
            delete childBuilders["fontSize;"];
            modifiedKeys["fontSize"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
    }
}
function patchPrintStyle(base, builder) { return builder(new PrintStyleBuilder(base)).patch(); }
exports.patchPrintStyle = patchPrintStyle;
function buildPrintStyle(builder) { return builder(new PrintStyleBuilder()).build(); }
exports.buildPrintStyle = buildPrintStyle;
class PrintStyleAlignBuilder {
    build;
    patch;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    fontFamily;
    fontWeight;
    fontStyle;
    fontSize;
    color;
    halign;
    valign;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "PrintStyleAlign";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
        this.fontFamily = (spec) => {
            updates["fontFamily"] = spec;
            delete childBuilders["fontFamily;"];
            modifiedKeys["fontFamily"] = true;
            return this;
        };
        this.fontWeight = (spec) => {
            updates["fontWeight"] = spec;
            delete childBuilders["fontWeight;"];
            modifiedKeys["fontWeight"] = true;
            return this;
        };
        this.fontStyle = (spec) => {
            updates["fontStyle"] = spec;
            delete childBuilders["fontStyle;"];
            modifiedKeys["fontStyle"] = true;
            return this;
        };
        this.fontSize = (spec) => {
            updates["fontSize"] = spec;
            delete childBuilders["fontSize;"];
            modifiedKeys["fontSize"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
        this.halign = (spec) => {
            updates["halign"] = spec;
            delete childBuilders["halign;"];
            modifiedKeys["halign"] = true;
            return this;
        };
        this.valign = (spec) => {
            updates["valign"] = spec;
            delete childBuilders["valign;"];
            modifiedKeys["valign"] = true;
            return this;
        };
    }
}
function patchPrintStyleAlign(base, builder) { return builder(new PrintStyleAlignBuilder(base)).patch(); }
exports.patchPrintStyleAlign = patchPrintStyleAlign;
function buildPrintStyleAlign(builder) { return builder(new PrintStyleAlignBuilder()).build(); }
exports.buildPrintStyleAlign = buildPrintStyleAlign;
class LineShapeBuilder {
    build;
    patch;
    lineShape;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "LineShape";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.lineShape = (spec) => {
            updates["lineShape"] = spec;
            delete childBuilders["lineShape;"];
            modifiedKeys["lineShape"] = true;
            return this;
        };
    }
}
function patchLineShape(base, builder) { return builder(new LineShapeBuilder(base)).patch(); }
exports.patchLineShape = patchLineShape;
function buildLineShape(builder) { return builder(new LineShapeBuilder()).build(); }
exports.buildLineShape = buildLineShape;
class LineTypeBuilder {
    build;
    patch;
    lineType;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "LineType";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.lineType = (spec) => {
            updates["lineType"] = spec;
            delete childBuilders["lineType;"];
            modifiedKeys["lineType"] = true;
            return this;
        };
    }
}
function patchLineType(base, builder) { return builder(new LineTypeBuilder(base)).patch(); }
exports.patchLineType = patchLineType;
function buildLineType(builder) { return builder(new LineTypeBuilder()).build(); }
exports.buildLineType = buildLineType;
class DashedFormattingBuilder {
    build;
    patch;
    dashLength;
    spaceLength;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "DashedFormatting";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.dashLength = (spec) => {
            updates["dashLength"] = spec;
            delete childBuilders["dashLength;"];
            modifiedKeys["dashLength"] = true;
            return this;
        };
        this.spaceLength = (spec) => {
            updates["spaceLength"] = spec;
            delete childBuilders["spaceLength;"];
            modifiedKeys["spaceLength"] = true;
            return this;
        };
    }
}
function patchDashedFormatting(base, builder) { return builder(new DashedFormattingBuilder(base)).patch(); }
exports.patchDashedFormatting = patchDashedFormatting;
function buildDashedFormatting(builder) { return builder(new DashedFormattingBuilder()).build(); }
exports.buildDashedFormatting = buildDashedFormatting;
class PrintObjectBuilder {
    build;
    patch;
    printObject;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "PrintObject";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.printObject = (spec) => {
            updates["printObject"] = spec;
            delete childBuilders["printObject;"];
            modifiedKeys["printObject"] = true;
            return this;
        };
    }
}
function patchPrintObject(base, builder) { return builder(new PrintObjectBuilder(base)).patch(); }
exports.patchPrintObject = patchPrintObject;
function buildPrintObject(builder) { return builder(new PrintObjectBuilder()).build(); }
exports.buildPrintObject = buildPrintObject;
class PrintSpacingBuilder {
    build;
    patch;
    printSpacing;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "PrintSpacing";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.printSpacing = (spec) => {
            updates["printSpacing"] = spec;
            delete childBuilders["printSpacing;"];
            modifiedKeys["printSpacing"] = true;
            return this;
        };
    }
}
function patchPrintSpacing(base, builder) { return builder(new PrintSpacingBuilder(base)).patch(); }
exports.patchPrintSpacing = patchPrintSpacing;
function buildPrintSpacing(builder) { return builder(new PrintSpacingBuilder()).build(); }
exports.buildPrintSpacing = buildPrintSpacing;
class PrintoutBuilder {
    build;
    patch;
    printDot;
    printLyric;
    printObject;
    printSpacing;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Printout";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.printDot = (spec) => {
            updates["printDot"] = spec;
            delete childBuilders["printDot;"];
            modifiedKeys["printDot"] = true;
            return this;
        };
        this.printLyric = (spec) => {
            updates["printLyric"] = spec;
            delete childBuilders["printLyric;"];
            modifiedKeys["printLyric"] = true;
            return this;
        };
        this.printObject = (spec) => {
            updates["printObject"] = spec;
            delete childBuilders["printObject;"];
            modifiedKeys["printObject"] = true;
            return this;
        };
        this.printSpacing = (spec) => {
            updates["printSpacing"] = spec;
            delete childBuilders["printSpacing;"];
            modifiedKeys["printSpacing"] = true;
            return this;
        };
    }
}
function patchPrintout(base, builder) { return builder(new PrintoutBuilder(base)).patch(); }
exports.patchPrintout = patchPrintout;
function buildPrintout(builder) { return builder(new PrintoutBuilder()).build(); }
exports.buildPrintout = buildPrintout;
class TextFormattingBuilder {
    build;
    patch;
    justify;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    fontFamily;
    fontWeight;
    fontStyle;
    fontSize;
    color;
    halign;
    valign;
    underline;
    overline;
    lineThrough;
    rotation;
    letterSpacing;
    lineHeight;
    dir;
    enclosure;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "TextFormatting";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.justify = (spec) => {
            updates["justify"] = spec;
            delete childBuilders["justify;"];
            modifiedKeys["justify"] = true;
            return this;
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
        this.fontFamily = (spec) => {
            updates["fontFamily"] = spec;
            delete childBuilders["fontFamily;"];
            modifiedKeys["fontFamily"] = true;
            return this;
        };
        this.fontWeight = (spec) => {
            updates["fontWeight"] = spec;
            delete childBuilders["fontWeight;"];
            modifiedKeys["fontWeight"] = true;
            return this;
        };
        this.fontStyle = (spec) => {
            updates["fontStyle"] = spec;
            delete childBuilders["fontStyle;"];
            modifiedKeys["fontStyle"] = true;
            return this;
        };
        this.fontSize = (spec) => {
            updates["fontSize"] = spec;
            delete childBuilders["fontSize;"];
            modifiedKeys["fontSize"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
        this.halign = (spec) => {
            updates["halign"] = spec;
            delete childBuilders["halign;"];
            modifiedKeys["halign"] = true;
            return this;
        };
        this.valign = (spec) => {
            updates["valign"] = spec;
            delete childBuilders["valign;"];
            modifiedKeys["valign"] = true;
            return this;
        };
        this.underline = (spec) => {
            updates["underline"] = spec;
            delete childBuilders["underline;"];
            modifiedKeys["underline"] = true;
            return this;
        };
        this.overline = (spec) => {
            updates["overline"] = spec;
            delete childBuilders["overline;"];
            modifiedKeys["overline"] = true;
            return this;
        };
        this.lineThrough = (spec) => {
            updates["lineThrough"] = spec;
            delete childBuilders["lineThrough;"];
            modifiedKeys["lineThrough"] = true;
            return this;
        };
        this.rotation = (spec) => {
            updates["rotation"] = spec;
            delete childBuilders["rotation;"];
            modifiedKeys["rotation"] = true;
            return this;
        };
        this.letterSpacing = (spec) => {
            updates["letterSpacing"] = spec;
            delete childBuilders["letterSpacing;"];
            modifiedKeys["letterSpacing"] = true;
            return this;
        };
        this.lineHeight = (spec) => {
            updates["lineHeight"] = spec;
            delete childBuilders["lineHeight;"];
            modifiedKeys["lineHeight"] = true;
            return this;
        };
        this.dir = (spec) => {
            updates["dir"] = spec;
            delete childBuilders["dir;"];
            modifiedKeys["dir"] = true;
            return this;
        };
        this.enclosure = (spec) => {
            updates["enclosure"] = spec;
            delete childBuilders["enclosure;"];
            modifiedKeys["enclosure"] = true;
            return this;
        };
    }
}
function patchTextFormatting(base, builder) { return builder(new TextFormattingBuilder(base)).patch(); }
exports.patchTextFormatting = patchTextFormatting;
function buildTextFormatting(builder) { return builder(new TextFormattingBuilder()).build(); }
exports.buildTextFormatting = buildTextFormatting;
class LevelDisplayBuilder {
    build;
    patch;
    bracket;
    size;
    parentheses;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "LevelDisplay";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.bracket = (spec) => {
            updates["bracket"] = spec;
            delete childBuilders["bracket;"];
            modifiedKeys["bracket"] = true;
            return this;
        };
        this.size = (spec) => {
            updates["size"] = spec;
            delete childBuilders["size;"];
            modifiedKeys["size"] = true;
            return this;
        };
        this.parentheses = (spec) => {
            updates["parentheses"] = spec;
            delete childBuilders["parentheses;"];
            modifiedKeys["parentheses"] = true;
            return this;
        };
    }
}
function patchLevelDisplay(base, builder) { return builder(new LevelDisplayBuilder(base)).patch(); }
exports.patchLevelDisplay = patchLevelDisplay;
function buildLevelDisplay(builder) { return builder(new LevelDisplayBuilder()).build(); }
exports.buildLevelDisplay = buildLevelDisplay;
class TrillSoundBuilder {
    build;
    patch;
    startNote;
    accelerate;
    beats;
    lastBeat;
    trillStep;
    twoNoteTurn;
    secondBeat;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "TrillSound";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.startNote = (spec) => {
            updates["startNote"] = spec;
            delete childBuilders["startNote;"];
            modifiedKeys["startNote"] = true;
            return this;
        };
        this.accelerate = (spec) => {
            updates["accelerate"] = spec;
            delete childBuilders["accelerate;"];
            modifiedKeys["accelerate"] = true;
            return this;
        };
        this.beats = (spec) => {
            updates["beats"] = spec;
            delete childBuilders["beats;"];
            modifiedKeys["beats"] = true;
            return this;
        };
        this.lastBeat = (spec) => {
            updates["lastBeat"] = spec;
            delete childBuilders["lastBeat;"];
            modifiedKeys["lastBeat"] = true;
            return this;
        };
        this.trillStep = (spec) => {
            updates["trillStep"] = spec;
            delete childBuilders["trillStep;"];
            modifiedKeys["trillStep"] = true;
            return this;
        };
        this.twoNoteTurn = (spec) => {
            updates["twoNoteTurn"] = spec;
            delete childBuilders["twoNoteTurn;"];
            modifiedKeys["twoNoteTurn"] = true;
            return this;
        };
        this.secondBeat = (spec) => {
            updates["secondBeat"] = spec;
            delete childBuilders["secondBeat;"];
            modifiedKeys["secondBeat"] = true;
            return this;
        };
    }
}
function patchTrillSound(base, builder) { return builder(new TrillSoundBuilder(base)).patch(); }
exports.patchTrillSound = patchTrillSound;
function buildTrillSound(builder) { return builder(new TrillSoundBuilder()).build(); }
exports.buildTrillSound = buildTrillSound;
class BendSoundBuilder {
    build;
    patch;
    accelerate;
    beats;
    firstBeat;
    lastBeat;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "BendSound";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.accelerate = (spec) => {
            updates["accelerate"] = spec;
            delete childBuilders["accelerate;"];
            modifiedKeys["accelerate"] = true;
            return this;
        };
        this.beats = (spec) => {
            updates["beats"] = spec;
            delete childBuilders["beats;"];
            modifiedKeys["beats"] = true;
            return this;
        };
        this.firstBeat = (spec) => {
            updates["firstBeat"] = spec;
            delete childBuilders["firstBeat;"];
            modifiedKeys["firstBeat"] = true;
            return this;
        };
        this.lastBeat = (spec) => {
            updates["lastBeat"] = spec;
            delete childBuilders["lastBeat;"];
            modifiedKeys["lastBeat"] = true;
            return this;
        };
    }
}
function patchBendSound(base, builder) { return builder(new BendSoundBuilder(base)).patch(); }
exports.patchBendSound = patchBendSound;
function buildBendSound(builder) { return builder(new BendSoundBuilder()).build(); }
exports.buildBendSound = buildBendSound;
class TimeOnlyBuilder {
    build;
    patch;
    timeOnly;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "TimeOnly";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.timeOnly = (spec) => {
            updates["timeOnly"] = spec;
            delete childBuilders["timeOnly;"];
            modifiedKeys["timeOnly"] = true;
            return this;
        };
    }
}
function patchTimeOnly(base, builder) { return builder(new TimeOnlyBuilder(base)).patch(); }
exports.patchTimeOnly = patchTimeOnly;
function buildTimeOnly(builder) { return builder(new TimeOnlyBuilder()).build(); }
exports.buildTimeOnly = buildTimeOnly;
class DocumentAttributesBuilder {
    build;
    patch;
    version;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["version"]) ||
                childBuilders["version"] !== undefined ||
                updates.version !== undefined, "version is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "DocumentAttributes";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.version = (spec) => {
            updates["version"] = spec;
            delete childBuilders["version;"];
            modifiedKeys["version"] = true;
            return this;
        };
    }
}
function patchDocumentAttributes(base, builder) { return builder(new DocumentAttributesBuilder(base)).patch(); }
exports.patchDocumentAttributes = patchDocumentAttributes;
function buildDocumentAttributes(builder) { return builder(new DocumentAttributesBuilder()).build(); }
exports.buildDocumentAttributes = buildDocumentAttributes;
class EditorialBuilder {
    build;
    patch;
    footnote;
    level;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Editorial";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.footnote = (build) => {
            if (typeof build === 'function') {
                delete updates["footnote"];
                const builder = build(new FootnoteBuilder(original && original["footnote"]));
                if (!original)
                    updates["footnote"] = builder.build();
                else
                    childBuilders["footnote"] = builder;
            }
            else {
                updates.footnote = build;
                delete childBuilders["footnote;"];
            }
            modifiedKeys["footnote"] = true;
            return this;
        };
        this.level = (build) => {
            if (typeof build === 'function') {
                delete updates["level"];
                const builder = build(new LevelBuilder(original && original["level"]));
                if (!original)
                    updates["level"] = builder.build();
                else
                    childBuilders["level"] = builder;
            }
            else {
                updates.level = build;
                delete childBuilders["level;"];
            }
            modifiedKeys["level"] = true;
            return this;
        };
    }
}
function patchEditorial(base, builder) { return builder(new EditorialBuilder(base)).patch(); }
exports.patchEditorial = patchEditorial;
function buildEditorial(builder) { return builder(new EditorialBuilder()).build(); }
exports.buildEditorial = buildEditorial;
class EditorialVoiceBuilder {
    build;
    patch;
    voice;
    footnote;
    level;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "EditorialVoice";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.voice = (spec) => {
            updates["voice"] = spec;
            delete childBuilders["voice;"];
            modifiedKeys["voice"] = true;
            return this;
        };
        this.footnote = (build) => {
            if (typeof build === 'function') {
                delete updates["footnote"];
                const builder = build(new FootnoteBuilder(original && original["footnote"]));
                if (!original)
                    updates["footnote"] = builder.build();
                else
                    childBuilders["footnote"] = builder;
            }
            else {
                updates.footnote = build;
                delete childBuilders["footnote;"];
            }
            modifiedKeys["footnote"] = true;
            return this;
        };
        this.level = (build) => {
            if (typeof build === 'function') {
                delete updates["level"];
                const builder = build(new LevelBuilder(original && original["level"]));
                if (!original)
                    updates["level"] = builder.build();
                else
                    childBuilders["level"] = builder;
            }
            else {
                updates.level = build;
                delete childBuilders["level;"];
            }
            modifiedKeys["level"] = true;
            return this;
        };
    }
}
function patchEditorialVoice(base, builder) { return builder(new EditorialVoiceBuilder(base)).patch(); }
exports.patchEditorialVoice = patchEditorialVoice;
function buildEditorialVoice(builder) { return builder(new EditorialVoiceBuilder()).build(); }
exports.buildEditorialVoice = buildEditorialVoice;
class FootnoteBuilder {
    build;
    patch;
    text;
    justify;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    fontFamily;
    fontWeight;
    fontStyle;
    fontSize;
    color;
    halign;
    valign;
    underline;
    overline;
    lineThrough;
    rotation;
    letterSpacing;
    lineHeight;
    dir;
    enclosure;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["text"]) ||
                childBuilders["text"] !== undefined ||
                updates.text !== undefined, "text is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Footnote";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.text = (spec) => {
            updates["text"] = spec;
            delete childBuilders["text;"];
            modifiedKeys["text"] = true;
            return this;
        };
        this.justify = (spec) => {
            updates["justify"] = spec;
            delete childBuilders["justify;"];
            modifiedKeys["justify"] = true;
            return this;
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
        this.fontFamily = (spec) => {
            updates["fontFamily"] = spec;
            delete childBuilders["fontFamily;"];
            modifiedKeys["fontFamily"] = true;
            return this;
        };
        this.fontWeight = (spec) => {
            updates["fontWeight"] = spec;
            delete childBuilders["fontWeight;"];
            modifiedKeys["fontWeight"] = true;
            return this;
        };
        this.fontStyle = (spec) => {
            updates["fontStyle"] = spec;
            delete childBuilders["fontStyle;"];
            modifiedKeys["fontStyle"] = true;
            return this;
        };
        this.fontSize = (spec) => {
            updates["fontSize"] = spec;
            delete childBuilders["fontSize;"];
            modifiedKeys["fontSize"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
        this.halign = (spec) => {
            updates["halign"] = spec;
            delete childBuilders["halign;"];
            modifiedKeys["halign"] = true;
            return this;
        };
        this.valign = (spec) => {
            updates["valign"] = spec;
            delete childBuilders["valign;"];
            modifiedKeys["valign"] = true;
            return this;
        };
        this.underline = (spec) => {
            updates["underline"] = spec;
            delete childBuilders["underline;"];
            modifiedKeys["underline"] = true;
            return this;
        };
        this.overline = (spec) => {
            updates["overline"] = spec;
            delete childBuilders["overline;"];
            modifiedKeys["overline"] = true;
            return this;
        };
        this.lineThrough = (spec) => {
            updates["lineThrough"] = spec;
            delete childBuilders["lineThrough;"];
            modifiedKeys["lineThrough"] = true;
            return this;
        };
        this.rotation = (spec) => {
            updates["rotation"] = spec;
            delete childBuilders["rotation;"];
            modifiedKeys["rotation"] = true;
            return this;
        };
        this.letterSpacing = (spec) => {
            updates["letterSpacing"] = spec;
            delete childBuilders["letterSpacing;"];
            modifiedKeys["letterSpacing"] = true;
            return this;
        };
        this.lineHeight = (spec) => {
            updates["lineHeight"] = spec;
            delete childBuilders["lineHeight;"];
            modifiedKeys["lineHeight"] = true;
            return this;
        };
        this.dir = (spec) => {
            updates["dir"] = spec;
            delete childBuilders["dir;"];
            modifiedKeys["dir"] = true;
            return this;
        };
        this.enclosure = (spec) => {
            updates["enclosure"] = spec;
            delete childBuilders["enclosure;"];
            modifiedKeys["enclosure"] = true;
            return this;
        };
    }
}
function patchFootnote(base, builder) { return builder(new FootnoteBuilder(base)).patch(); }
exports.patchFootnote = patchFootnote;
function buildFootnote(builder) { return builder(new FootnoteBuilder()).build(); }
exports.buildFootnote = buildFootnote;
class LevelBuilder {
    build;
    patch;
    text;
    reference;
    bracket;
    size;
    parentheses;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["text"]) ||
                childBuilders["text"] !== undefined ||
                updates.text !== undefined, "text is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Level";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.text = (spec) => {
            updates["text"] = spec;
            delete childBuilders["text;"];
            modifiedKeys["text"] = true;
            return this;
        };
        this.reference = (spec) => {
            updates["reference"] = spec;
            delete childBuilders["reference;"];
            modifiedKeys["reference"] = true;
            return this;
        };
        this.bracket = (spec) => {
            updates["bracket"] = spec;
            delete childBuilders["bracket;"];
            modifiedKeys["bracket"] = true;
            return this;
        };
        this.size = (spec) => {
            updates["size"] = spec;
            delete childBuilders["size;"];
            modifiedKeys["size"] = true;
            return this;
        };
        this.parentheses = (spec) => {
            updates["parentheses"] = spec;
            delete childBuilders["parentheses;"];
            modifiedKeys["parentheses"] = true;
            return this;
        };
    }
}
function patchLevel(base, builder) { return builder(new LevelBuilder(base)).patch(); }
exports.patchLevel = patchLevel;
function buildLevel(builder) { return builder(new LevelBuilder()).build(); }
exports.buildLevel = buildLevel;
class FermataBuilder {
    build;
    patch;
    shape;
    type;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    fontFamily;
    fontWeight;
    fontStyle;
    fontSize;
    color;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["shape"]) ||
                childBuilders["shape"] !== undefined ||
                updates.shape !== undefined, "shape is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Fermata";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.shape = (spec) => {
            updates["shape"] = spec;
            delete childBuilders["shape;"];
            modifiedKeys["shape"] = true;
            return this;
        };
        this.type = (spec) => {
            updates["type"] = spec;
            delete childBuilders["type;"];
            modifiedKeys["type"] = true;
            return this;
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
        this.fontFamily = (spec) => {
            updates["fontFamily"] = spec;
            delete childBuilders["fontFamily;"];
            modifiedKeys["fontFamily"] = true;
            return this;
        };
        this.fontWeight = (spec) => {
            updates["fontWeight"] = spec;
            delete childBuilders["fontWeight;"];
            modifiedKeys["fontWeight"] = true;
            return this;
        };
        this.fontStyle = (spec) => {
            updates["fontStyle"] = spec;
            delete childBuilders["fontStyle;"];
            modifiedKeys["fontStyle"] = true;
            return this;
        };
        this.fontSize = (spec) => {
            updates["fontSize"] = spec;
            delete childBuilders["fontSize;"];
            modifiedKeys["fontSize"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
    }
}
function patchFermata(base, builder) { return builder(new FermataBuilder(base)).patch(); }
exports.patchFermata = patchFermata;
function buildFermata(builder) { return builder(new FermataBuilder()).build(); }
exports.buildFermata = buildFermata;
class WavyLineBuilder {
    build;
    patch;
    number;
    type;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    color;
    placement;
    startNote;
    accelerate;
    beats;
    lastBeat;
    trillStep;
    twoNoteTurn;
    secondBeat;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["type"]) ||
                childBuilders["type"] !== undefined ||
                updates.type !== undefined, "type is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "WavyLine";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.number = (spec) => {
            updates["number"] = spec;
            delete childBuilders["number;"];
            modifiedKeys["number"] = true;
            return this;
        };
        this.type = (spec) => {
            updates["type"] = spec;
            delete childBuilders["type;"];
            modifiedKeys["type"] = true;
            return this;
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
        this.placement = (spec) => {
            updates["placement"] = spec;
            delete childBuilders["placement;"];
            modifiedKeys["placement"] = true;
            return this;
        };
        this.startNote = (spec) => {
            updates["startNote"] = spec;
            delete childBuilders["startNote;"];
            modifiedKeys["startNote"] = true;
            return this;
        };
        this.accelerate = (spec) => {
            updates["accelerate"] = spec;
            delete childBuilders["accelerate;"];
            modifiedKeys["accelerate"] = true;
            return this;
        };
        this.beats = (spec) => {
            updates["beats"] = spec;
            delete childBuilders["beats;"];
            modifiedKeys["beats"] = true;
            return this;
        };
        this.lastBeat = (spec) => {
            updates["lastBeat"] = spec;
            delete childBuilders["lastBeat;"];
            modifiedKeys["lastBeat"] = true;
            return this;
        };
        this.trillStep = (spec) => {
            updates["trillStep"] = spec;
            delete childBuilders["trillStep;"];
            modifiedKeys["trillStep"] = true;
            return this;
        };
        this.twoNoteTurn = (spec) => {
            updates["twoNoteTurn"] = spec;
            delete childBuilders["twoNoteTurn;"];
            modifiedKeys["twoNoteTurn"] = true;
            return this;
        };
        this.secondBeat = (spec) => {
            updates["secondBeat"] = spec;
            delete childBuilders["secondBeat;"];
            modifiedKeys["secondBeat"] = true;
            return this;
        };
    }
}
function patchWavyLine(base, builder) { return builder(new WavyLineBuilder(base)).patch(); }
exports.patchWavyLine = patchWavyLine;
function buildWavyLine(builder) { return builder(new WavyLineBuilder()).build(); }
exports.buildWavyLine = buildWavyLine;
class SegnoBuilder {
    build;
    patch;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    fontFamily;
    fontWeight;
    fontStyle;
    fontSize;
    color;
    halign;
    valign;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Segno";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
        this.fontFamily = (spec) => {
            updates["fontFamily"] = spec;
            delete childBuilders["fontFamily;"];
            modifiedKeys["fontFamily"] = true;
            return this;
        };
        this.fontWeight = (spec) => {
            updates["fontWeight"] = spec;
            delete childBuilders["fontWeight;"];
            modifiedKeys["fontWeight"] = true;
            return this;
        };
        this.fontStyle = (spec) => {
            updates["fontStyle"] = spec;
            delete childBuilders["fontStyle;"];
            modifiedKeys["fontStyle"] = true;
            return this;
        };
        this.fontSize = (spec) => {
            updates["fontSize"] = spec;
            delete childBuilders["fontSize;"];
            modifiedKeys["fontSize"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
        this.halign = (spec) => {
            updates["halign"] = spec;
            delete childBuilders["halign;"];
            modifiedKeys["halign"] = true;
            return this;
        };
        this.valign = (spec) => {
            updates["valign"] = spec;
            delete childBuilders["valign;"];
            modifiedKeys["valign"] = true;
            return this;
        };
    }
}
function patchSegno(base, builder) { return builder(new SegnoBuilder(base)).patch(); }
exports.patchSegno = patchSegno;
function buildSegno(builder) { return builder(new SegnoBuilder()).build(); }
exports.buildSegno = buildSegno;
class CodaBuilder {
    build;
    patch;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    fontFamily;
    fontWeight;
    fontStyle;
    fontSize;
    color;
    halign;
    valign;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Coda";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
        this.fontFamily = (spec) => {
            updates["fontFamily"] = spec;
            delete childBuilders["fontFamily;"];
            modifiedKeys["fontFamily"] = true;
            return this;
        };
        this.fontWeight = (spec) => {
            updates["fontWeight"] = spec;
            delete childBuilders["fontWeight;"];
            modifiedKeys["fontWeight"] = true;
            return this;
        };
        this.fontStyle = (spec) => {
            updates["fontStyle"] = spec;
            delete childBuilders["fontStyle;"];
            modifiedKeys["fontStyle"] = true;
            return this;
        };
        this.fontSize = (spec) => {
            updates["fontSize"] = spec;
            delete childBuilders["fontSize;"];
            modifiedKeys["fontSize"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
        this.halign = (spec) => {
            updates["halign"] = spec;
            delete childBuilders["halign;"];
            modifiedKeys["halign"] = true;
            return this;
        };
        this.valign = (spec) => {
            updates["valign"] = spec;
            delete childBuilders["valign;"];
            modifiedKeys["valign"] = true;
            return this;
        };
    }
}
function patchCoda(base, builder) { return builder(new CodaBuilder(base)).patch(); }
exports.patchCoda = patchCoda;
function buildCoda(builder) { return builder(new CodaBuilder()).build(); }
exports.buildCoda = buildCoda;
class NormalDotBuilder {
    build;
    patch;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "NormalDot";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
    }
}
function patchNormalDot(base, builder) { return builder(new NormalDotBuilder(base)).patch(); }
exports.patchNormalDot = patchNormalDot;
function buildNormalDot(builder) { return builder(new NormalDotBuilder()).build(); }
exports.buildNormalDot = buildNormalDot;
class DynamicsBuilder {
    build;
    patch;
    f;
    ff;
    fff;
    ffff;
    fffff;
    ffffff;
    fp;
    fz;
    mf;
    mp;
    otherDynamics;
    p;
    pp;
    ppp;
    pppp;
    ppppp;
    pppppp;
    rf;
    rfz;
    sf;
    sffz;
    sfp;
    sfpp;
    sfz;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    fontFamily;
    fontWeight;
    fontStyle;
    fontSize;
    color;
    halign;
    valign;
    underline;
    overline;
    lineThrough;
    enclosure;
    placement;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Dynamics";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.f = (spec) => {
            updates["f"] = spec;
            delete childBuilders["f;"];
            modifiedKeys["f"] = true;
            return this;
        };
        this.ff = (spec) => {
            updates["ff"] = spec;
            delete childBuilders["ff;"];
            modifiedKeys["ff"] = true;
            return this;
        };
        this.fff = (spec) => {
            updates["fff"] = spec;
            delete childBuilders["fff;"];
            modifiedKeys["fff"] = true;
            return this;
        };
        this.ffff = (spec) => {
            updates["ffff"] = spec;
            delete childBuilders["ffff;"];
            modifiedKeys["ffff"] = true;
            return this;
        };
        this.fffff = (spec) => {
            updates["fffff"] = spec;
            delete childBuilders["fffff;"];
            modifiedKeys["fffff"] = true;
            return this;
        };
        this.ffffff = (spec) => {
            updates["ffffff"] = spec;
            delete childBuilders["ffffff;"];
            modifiedKeys["ffffff"] = true;
            return this;
        };
        this.fp = (spec) => {
            updates["fp"] = spec;
            delete childBuilders["fp;"];
            modifiedKeys["fp"] = true;
            return this;
        };
        this.fz = (spec) => {
            updates["fz"] = spec;
            delete childBuilders["fz;"];
            modifiedKeys["fz"] = true;
            return this;
        };
        this.mf = (spec) => {
            updates["mf"] = spec;
            delete childBuilders["mf;"];
            modifiedKeys["mf"] = true;
            return this;
        };
        this.mp = (spec) => {
            updates["mp"] = spec;
            delete childBuilders["mp;"];
            modifiedKeys["mp"] = true;
            return this;
        };
        this.otherDynamics = (spec) => {
            updates["otherDynamics"] = spec;
            delete childBuilders["otherDynamics;"];
            modifiedKeys["otherDynamics"] = true;
            return this;
        };
        this.p = (spec) => {
            updates["p"] = spec;
            delete childBuilders["p;"];
            modifiedKeys["p"] = true;
            return this;
        };
        this.pp = (spec) => {
            updates["pp"] = spec;
            delete childBuilders["pp;"];
            modifiedKeys["pp"] = true;
            return this;
        };
        this.ppp = (spec) => {
            updates["ppp"] = spec;
            delete childBuilders["ppp;"];
            modifiedKeys["ppp"] = true;
            return this;
        };
        this.pppp = (spec) => {
            updates["pppp"] = spec;
            delete childBuilders["pppp;"];
            modifiedKeys["pppp"] = true;
            return this;
        };
        this.ppppp = (spec) => {
            updates["ppppp"] = spec;
            delete childBuilders["ppppp;"];
            modifiedKeys["ppppp"] = true;
            return this;
        };
        this.pppppp = (spec) => {
            updates["pppppp"] = spec;
            delete childBuilders["pppppp;"];
            modifiedKeys["pppppp"] = true;
            return this;
        };
        this.rf = (spec) => {
            updates["rf"] = spec;
            delete childBuilders["rf;"];
            modifiedKeys["rf"] = true;
            return this;
        };
        this.rfz = (spec) => {
            updates["rfz"] = spec;
            delete childBuilders["rfz;"];
            modifiedKeys["rfz"] = true;
            return this;
        };
        this.sf = (spec) => {
            updates["sf"] = spec;
            delete childBuilders["sf;"];
            modifiedKeys["sf"] = true;
            return this;
        };
        this.sffz = (spec) => {
            updates["sffz"] = spec;
            delete childBuilders["sffz;"];
            modifiedKeys["sffz"] = true;
            return this;
        };
        this.sfp = (spec) => {
            updates["sfp"] = spec;
            delete childBuilders["sfp;"];
            modifiedKeys["sfp"] = true;
            return this;
        };
        this.sfpp = (spec) => {
            updates["sfpp"] = spec;
            delete childBuilders["sfpp;"];
            modifiedKeys["sfpp"] = true;
            return this;
        };
        this.sfz = (spec) => {
            updates["sfz"] = spec;
            delete childBuilders["sfz;"];
            modifiedKeys["sfz"] = true;
            return this;
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
        this.fontFamily = (spec) => {
            updates["fontFamily"] = spec;
            delete childBuilders["fontFamily;"];
            modifiedKeys["fontFamily"] = true;
            return this;
        };
        this.fontWeight = (spec) => {
            updates["fontWeight"] = spec;
            delete childBuilders["fontWeight;"];
            modifiedKeys["fontWeight"] = true;
            return this;
        };
        this.fontStyle = (spec) => {
            updates["fontStyle"] = spec;
            delete childBuilders["fontStyle;"];
            modifiedKeys["fontStyle"] = true;
            return this;
        };
        this.fontSize = (spec) => {
            updates["fontSize"] = spec;
            delete childBuilders["fontSize;"];
            modifiedKeys["fontSize"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
        this.halign = (spec) => {
            updates["halign"] = spec;
            delete childBuilders["halign;"];
            modifiedKeys["halign"] = true;
            return this;
        };
        this.valign = (spec) => {
            updates["valign"] = spec;
            delete childBuilders["valign;"];
            modifiedKeys["valign"] = true;
            return this;
        };
        this.underline = (spec) => {
            updates["underline"] = spec;
            delete childBuilders["underline;"];
            modifiedKeys["underline"] = true;
            return this;
        };
        this.overline = (spec) => {
            updates["overline"] = spec;
            delete childBuilders["overline;"];
            modifiedKeys["overline"] = true;
            return this;
        };
        this.lineThrough = (spec) => {
            updates["lineThrough"] = spec;
            delete childBuilders["lineThrough;"];
            modifiedKeys["lineThrough"] = true;
            return this;
        };
        this.enclosure = (spec) => {
            updates["enclosure"] = spec;
            delete childBuilders["enclosure;"];
            modifiedKeys["enclosure"] = true;
            return this;
        };
        this.placement = (spec) => {
            updates["placement"] = spec;
            delete childBuilders["placement;"];
            modifiedKeys["placement"] = true;
            return this;
        };
    }
}
function patchDynamics(base, builder) { return builder(new DynamicsBuilder(base)).patch(); }
exports.patchDynamics = patchDynamics;
function buildDynamics(builder) { return builder(new DynamicsBuilder()).build(); }
exports.buildDynamics = buildDynamics;
class FingeringBuilder {
    build;
    patch;
    substitution;
    finger;
    alternate;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    fontFamily;
    fontWeight;
    fontStyle;
    fontSize;
    color;
    placement;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Fingering";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.substitution = (spec) => {
            updates["substitution"] = spec;
            delete childBuilders["substitution;"];
            modifiedKeys["substitution"] = true;
            return this;
        };
        this.finger = (spec) => {
            updates["finger"] = spec;
            delete childBuilders["finger;"];
            modifiedKeys["finger"] = true;
            return this;
        };
        this.alternate = (spec) => {
            updates["alternate"] = spec;
            delete childBuilders["alternate;"];
            modifiedKeys["alternate"] = true;
            return this;
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
        this.fontFamily = (spec) => {
            updates["fontFamily"] = spec;
            delete childBuilders["fontFamily;"];
            modifiedKeys["fontFamily"] = true;
            return this;
        };
        this.fontWeight = (spec) => {
            updates["fontWeight"] = spec;
            delete childBuilders["fontWeight;"];
            modifiedKeys["fontWeight"] = true;
            return this;
        };
        this.fontStyle = (spec) => {
            updates["fontStyle"] = spec;
            delete childBuilders["fontStyle;"];
            modifiedKeys["fontStyle"] = true;
            return this;
        };
        this.fontSize = (spec) => {
            updates["fontSize"] = spec;
            delete childBuilders["fontSize;"];
            modifiedKeys["fontSize"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
        this.placement = (spec) => {
            updates["placement"] = spec;
            delete childBuilders["placement;"];
            modifiedKeys["placement"] = true;
            return this;
        };
    }
}
function patchFingering(base, builder) { return builder(new FingeringBuilder(base)).patch(); }
exports.patchFingering = patchFingering;
function buildFingering(builder) { return builder(new FingeringBuilder()).build(); }
exports.buildFingering = buildFingering;
class FretBuilder {
    build;
    patch;
    fret;
    fontFamily;
    fontWeight;
    fontStyle;
    fontSize;
    color;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["fret"]) ||
                childBuilders["fret"] !== undefined ||
                updates.fret !== undefined, "fret is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Fret";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.fret = (spec) => {
            updates["fret"] = spec;
            delete childBuilders["fret;"];
            modifiedKeys["fret"] = true;
            return this;
        };
        this.fontFamily = (spec) => {
            updates["fontFamily"] = spec;
            delete childBuilders["fontFamily;"];
            modifiedKeys["fontFamily"] = true;
            return this;
        };
        this.fontWeight = (spec) => {
            updates["fontWeight"] = spec;
            delete childBuilders["fontWeight;"];
            modifiedKeys["fontWeight"] = true;
            return this;
        };
        this.fontStyle = (spec) => {
            updates["fontStyle"] = spec;
            delete childBuilders["fontStyle;"];
            modifiedKeys["fontStyle"] = true;
            return this;
        };
        this.fontSize = (spec) => {
            updates["fontSize"] = spec;
            delete childBuilders["fontSize;"];
            modifiedKeys["fontSize"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
    }
}
function patchFret(base, builder) { return builder(new FretBuilder(base)).patch(); }
exports.patchFret = patchFret;
function buildFret(builder) { return builder(new FretBuilder()).build(); }
exports.buildFret = buildFret;
class StringBuilder {
    build;
    patch;
    stringNum;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    fontFamily;
    fontWeight;
    fontStyle;
    fontSize;
    color;
    placement;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["stringNum"]) ||
                childBuilders["stringNum"] !== undefined ||
                updates.stringNum !== undefined, "stringNum is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "String";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.stringNum = (spec) => {
            updates["stringNum"] = spec;
            delete childBuilders["stringNum;"];
            modifiedKeys["stringNum"] = true;
            return this;
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
        this.fontFamily = (spec) => {
            updates["fontFamily"] = spec;
            delete childBuilders["fontFamily;"];
            modifiedKeys["fontFamily"] = true;
            return this;
        };
        this.fontWeight = (spec) => {
            updates["fontWeight"] = spec;
            delete childBuilders["fontWeight;"];
            modifiedKeys["fontWeight"] = true;
            return this;
        };
        this.fontStyle = (spec) => {
            updates["fontStyle"] = spec;
            delete childBuilders["fontStyle;"];
            modifiedKeys["fontStyle"] = true;
            return this;
        };
        this.fontSize = (spec) => {
            updates["fontSize"] = spec;
            delete childBuilders["fontSize;"];
            modifiedKeys["fontSize"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
        this.placement = (spec) => {
            updates["placement"] = spec;
            delete childBuilders["placement;"];
            modifiedKeys["placement"] = true;
            return this;
        };
    }
}
function patchString(base, builder) { return builder(new StringBuilder(base)).patch(); }
exports.patchString = patchString;
function buildString(builder) { return builder(new StringBuilder()).build(); }
exports.buildString = buildString;
class DisplayTextBuilder {
    build;
    patch;
    text;
    justify;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    fontFamily;
    fontWeight;
    fontStyle;
    fontSize;
    color;
    halign;
    valign;
    underline;
    overline;
    lineThrough;
    rotation;
    letterSpacing;
    lineHeight;
    dir;
    enclosure;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["text"]) ||
                childBuilders["text"] !== undefined ||
                updates.text !== undefined, "text is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "DisplayText";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.text = (spec) => {
            updates["text"] = spec;
            delete childBuilders["text;"];
            modifiedKeys["text"] = true;
            return this;
        };
        this.justify = (spec) => {
            updates["justify"] = spec;
            delete childBuilders["justify;"];
            modifiedKeys["justify"] = true;
            return this;
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
        this.fontFamily = (spec) => {
            updates["fontFamily"] = spec;
            delete childBuilders["fontFamily;"];
            modifiedKeys["fontFamily"] = true;
            return this;
        };
        this.fontWeight = (spec) => {
            updates["fontWeight"] = spec;
            delete childBuilders["fontWeight;"];
            modifiedKeys["fontWeight"] = true;
            return this;
        };
        this.fontStyle = (spec) => {
            updates["fontStyle"] = spec;
            delete childBuilders["fontStyle;"];
            modifiedKeys["fontStyle"] = true;
            return this;
        };
        this.fontSize = (spec) => {
            updates["fontSize"] = spec;
            delete childBuilders["fontSize;"];
            modifiedKeys["fontSize"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
        this.halign = (spec) => {
            updates["halign"] = spec;
            delete childBuilders["halign;"];
            modifiedKeys["halign"] = true;
            return this;
        };
        this.valign = (spec) => {
            updates["valign"] = spec;
            delete childBuilders["valign;"];
            modifiedKeys["valign"] = true;
            return this;
        };
        this.underline = (spec) => {
            updates["underline"] = spec;
            delete childBuilders["underline;"];
            modifiedKeys["underline"] = true;
            return this;
        };
        this.overline = (spec) => {
            updates["overline"] = spec;
            delete childBuilders["overline;"];
            modifiedKeys["overline"] = true;
            return this;
        };
        this.lineThrough = (spec) => {
            updates["lineThrough"] = spec;
            delete childBuilders["lineThrough;"];
            modifiedKeys["lineThrough"] = true;
            return this;
        };
        this.rotation = (spec) => {
            updates["rotation"] = spec;
            delete childBuilders["rotation;"];
            modifiedKeys["rotation"] = true;
            return this;
        };
        this.letterSpacing = (spec) => {
            updates["letterSpacing"] = spec;
            delete childBuilders["letterSpacing;"];
            modifiedKeys["letterSpacing"] = true;
            return this;
        };
        this.lineHeight = (spec) => {
            updates["lineHeight"] = spec;
            delete childBuilders["lineHeight;"];
            modifiedKeys["lineHeight"] = true;
            return this;
        };
        this.dir = (spec) => {
            updates["dir"] = spec;
            delete childBuilders["dir;"];
            modifiedKeys["dir"] = true;
            return this;
        };
        this.enclosure = (spec) => {
            updates["enclosure"] = spec;
            delete childBuilders["enclosure;"];
            modifiedKeys["enclosure"] = true;
            return this;
        };
    }
}
function patchDisplayText(base, builder) { return builder(new DisplayTextBuilder(base)).patch(); }
exports.patchDisplayText = patchDisplayText;
function buildDisplayText(builder) { return builder(new DisplayTextBuilder()).build(); }
exports.buildDisplayText = buildDisplayText;
class AccidentalTextBuilder {
    build;
    patch;
    text;
    justify;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    fontFamily;
    fontWeight;
    fontStyle;
    fontSize;
    color;
    halign;
    valign;
    underline;
    overline;
    lineThrough;
    rotation;
    letterSpacing;
    lineHeight;
    dir;
    enclosure;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["text"]) ||
                childBuilders["text"] !== undefined ||
                updates.text !== undefined, "text is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "AccidentalText";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.text = (spec) => {
            updates["text"] = spec;
            delete childBuilders["text;"];
            modifiedKeys["text"] = true;
            return this;
        };
        this.justify = (spec) => {
            updates["justify"] = spec;
            delete childBuilders["justify;"];
            modifiedKeys["justify"] = true;
            return this;
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
        this.fontFamily = (spec) => {
            updates["fontFamily"] = spec;
            delete childBuilders["fontFamily;"];
            modifiedKeys["fontFamily"] = true;
            return this;
        };
        this.fontWeight = (spec) => {
            updates["fontWeight"] = spec;
            delete childBuilders["fontWeight;"];
            modifiedKeys["fontWeight"] = true;
            return this;
        };
        this.fontStyle = (spec) => {
            updates["fontStyle"] = spec;
            delete childBuilders["fontStyle;"];
            modifiedKeys["fontStyle"] = true;
            return this;
        };
        this.fontSize = (spec) => {
            updates["fontSize"] = spec;
            delete childBuilders["fontSize;"];
            modifiedKeys["fontSize"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
        this.halign = (spec) => {
            updates["halign"] = spec;
            delete childBuilders["halign;"];
            modifiedKeys["halign"] = true;
            return this;
        };
        this.valign = (spec) => {
            updates["valign"] = spec;
            delete childBuilders["valign;"];
            modifiedKeys["valign"] = true;
            return this;
        };
        this.underline = (spec) => {
            updates["underline"] = spec;
            delete childBuilders["underline;"];
            modifiedKeys["underline"] = true;
            return this;
        };
        this.overline = (spec) => {
            updates["overline"] = spec;
            delete childBuilders["overline;"];
            modifiedKeys["overline"] = true;
            return this;
        };
        this.lineThrough = (spec) => {
            updates["lineThrough"] = spec;
            delete childBuilders["lineThrough;"];
            modifiedKeys["lineThrough"] = true;
            return this;
        };
        this.rotation = (spec) => {
            updates["rotation"] = spec;
            delete childBuilders["rotation;"];
            modifiedKeys["rotation"] = true;
            return this;
        };
        this.letterSpacing = (spec) => {
            updates["letterSpacing"] = spec;
            delete childBuilders["letterSpacing;"];
            modifiedKeys["letterSpacing"] = true;
            return this;
        };
        this.lineHeight = (spec) => {
            updates["lineHeight"] = spec;
            delete childBuilders["lineHeight;"];
            modifiedKeys["lineHeight"] = true;
            return this;
        };
        this.dir = (spec) => {
            updates["dir"] = spec;
            delete childBuilders["dir;"];
            modifiedKeys["dir"] = true;
            return this;
        };
        this.enclosure = (spec) => {
            updates["enclosure"] = spec;
            delete childBuilders["enclosure;"];
            modifiedKeys["enclosure"] = true;
            return this;
        };
    }
}
function patchAccidentalText(base, builder) { return builder(new AccidentalTextBuilder(base)).patch(); }
exports.patchAccidentalText = patchAccidentalText;
function buildAccidentalText(builder) { return builder(new AccidentalTextBuilder()).build(); }
exports.buildAccidentalText = buildAccidentalText;
class PartNameDisplayBuilder {
    build;
    patch;
    nameAt;
    nameSplice;
    name;
    printObject;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["name"]) ||
                childBuilders["name"] !== undefined ||
                updates.name !== undefined, "name is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "PartNameDisplay";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.name = (spec) => {
            updates["name"] = spec;
            delete childBuilders["name;"];
            modifiedKeys["name"] = true;
            return this;
        };
        this.nameAt = (idx, build) => {
            makeReference("name");
            if (frozen["name"][idx]) {
                throw new Error("Patching name." + idx + " twice in a builder is unsupported.");
            }
            if (original && original._snapshot && original._snapshot["name"] && original._snapshot["name"][idx] && !original["name"][idx]) {
                // Clone snapshot.
                patches.push({ p: ["name", idx], li: original._snapshot["name"] });
            }
            if (typeof build === 'function' && reference["name"][idx]) {
                let patch = build(new TextSegmentBuilder(reference["name"][idx])).patch();
                patches = patches.concat(patch.map(patch => {
                    // TODO: detach?
                    patch.p = ["name", idx].concat(patch.p);
                    return patch;
                }));
                frozen["name"][idx] = true;
                return this;
            }
            let update = typeof build === 'function' ? build(new TextSegmentBuilder(reference["name"][idx])).build() : build;
            if (original) {
                patches.push({ p: ["name", idx], li: update });
            }
            else {
                updates["name"] = reference["name"]; // TODO: Merge?
            }
            reference["name"][idx] = update;
            frozen["name"][idx] = true;
            return this;
        };
        this.nameSplice = (start, deleteCount, ...items) => {
            makeReference("name");
            let idx = start;
            if (original) {
                for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
                    if (frozen["name"][idx]) {
                        throw new Error("Replacing name." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["name"][idx];
                    patches.push({ p: ["name", idx], ld, li: items[idx - start] });
                    frozen["name"][idx] = true;
                }
                for (; idx < start + deleteCount; ++idx) {
                    if (frozen["name"][idx]) {
                        throw new Error("Removing name." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["name"][idx];
                    patches.push({ p: ["name", idx], ld });
                }
                for (; idx < start + items.length; ++idx) {
                    patches.push({ p: ["name", idx], li: items[idx - start] });
                    frozen["name"][idx] = true;
                }
            }
            reference["name"].splice(start, deleteCount, ...items);
            updates["name"] = reference["name"];
            frozen["name"].splice(start, deleteCount, ...items.map(i => true));
            return this;
        };
        this.printObject = (spec) => {
            updates["printObject"] = spec;
            delete childBuilders["printObject;"];
            modifiedKeys["printObject"] = true;
            return this;
        };
    }
}
function patchPartNameDisplay(base, builder) { return builder(new PartNameDisplayBuilder(base)).patch(); }
exports.patchPartNameDisplay = patchPartNameDisplay;
function buildPartNameDisplay(builder) { return builder(new PartNameDisplayBuilder()).build(); }
exports.buildPartNameDisplay = buildPartNameDisplay;
class PartAbbreviationDisplayBuilder {
    build;
    patch;
    nameAt;
    nameSplice;
    name;
    printObject;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["name"]) ||
                childBuilders["name"] !== undefined ||
                updates.name !== undefined, "name is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "PartAbbreviationDisplay";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.name = (spec) => {
            updates["name"] = spec;
            delete childBuilders["name;"];
            modifiedKeys["name"] = true;
            return this;
        };
        this.nameAt = (idx, build) => {
            makeReference("name");
            if (frozen["name"][idx]) {
                throw new Error("Patching name." + idx + " twice in a builder is unsupported.");
            }
            if (original && original._snapshot && original._snapshot["name"] && original._snapshot["name"][idx] && !original["name"][idx]) {
                // Clone snapshot.
                patches.push({ p: ["name", idx], li: original._snapshot["name"] });
            }
            if (typeof build === 'function' && reference["name"][idx]) {
                let patch = build(new TextSegmentBuilder(reference["name"][idx])).patch();
                patches = patches.concat(patch.map(patch => {
                    // TODO: detach?
                    patch.p = ["name", idx].concat(patch.p);
                    return patch;
                }));
                frozen["name"][idx] = true;
                return this;
            }
            let update = typeof build === 'function' ? build(new TextSegmentBuilder(reference["name"][idx])).build() : build;
            if (original) {
                patches.push({ p: ["name", idx], li: update });
            }
            else {
                updates["name"] = reference["name"]; // TODO: Merge?
            }
            reference["name"][idx] = update;
            frozen["name"][idx] = true;
            return this;
        };
        this.nameSplice = (start, deleteCount, ...items) => {
            makeReference("name");
            let idx = start;
            if (original) {
                for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
                    if (frozen["name"][idx]) {
                        throw new Error("Replacing name." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["name"][idx];
                    patches.push({ p: ["name", idx], ld, li: items[idx - start] });
                    frozen["name"][idx] = true;
                }
                for (; idx < start + deleteCount; ++idx) {
                    if (frozen["name"][idx]) {
                        throw new Error("Removing name." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["name"][idx];
                    patches.push({ p: ["name", idx], ld });
                }
                for (; idx < start + items.length; ++idx) {
                    patches.push({ p: ["name", idx], li: items[idx - start] });
                    frozen["name"][idx] = true;
                }
            }
            reference["name"].splice(start, deleteCount, ...items);
            updates["name"] = reference["name"];
            frozen["name"].splice(start, deleteCount, ...items.map(i => true));
            return this;
        };
        this.printObject = (spec) => {
            updates["printObject"] = spec;
            delete childBuilders["printObject;"];
            modifiedKeys["printObject"] = true;
            return this;
        };
    }
}
function patchPartAbbreviationDisplay(base, builder) { return builder(new PartAbbreviationDisplayBuilder(base)).patch(); }
exports.patchPartAbbreviationDisplay = patchPartAbbreviationDisplay;
function buildPartAbbreviationDisplay(builder) { return builder(new PartAbbreviationDisplayBuilder()).build(); }
exports.buildPartAbbreviationDisplay = buildPartAbbreviationDisplay;
class MidiDeviceBuilder {
    build;
    patch;
    port;
    deviceName;
    id;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["deviceName"]) ||
                childBuilders["deviceName"] !== undefined ||
                updates.deviceName !== undefined, "deviceName is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "MidiDevice";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.port = (spec) => {
            updates["port"] = spec;
            delete childBuilders["port;"];
            modifiedKeys["port"] = true;
            return this;
        };
        this.deviceName = (spec) => {
            updates["deviceName"] = spec;
            delete childBuilders["deviceName;"];
            modifiedKeys["deviceName"] = true;
            return this;
        };
        this.id = (spec) => {
            updates["id"] = spec;
            delete childBuilders["id;"];
            modifiedKeys["id"] = true;
            return this;
        };
    }
}
function patchMidiDevice(base, builder) { return builder(new MidiDeviceBuilder(base)).patch(); }
exports.patchMidiDevice = patchMidiDevice;
function buildMidiDevice(builder) { return builder(new MidiDeviceBuilder()).build(); }
exports.buildMidiDevice = buildMidiDevice;
class MidiInstrumentBuilder {
    build;
    patch;
    midiUnpitched;
    volume;
    pan;
    elevation;
    midiBank;
    midiProgram;
    id;
    midiChannel;
    midiName;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["id"]) ||
                childBuilders["id"] !== undefined ||
                updates.id !== undefined, "id is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "MidiInstrument";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.midiUnpitched = (spec) => {
            updates["midiUnpitched"] = spec;
            delete childBuilders["midiUnpitched;"];
            modifiedKeys["midiUnpitched"] = true;
            return this;
        };
        this.volume = (spec) => {
            updates["volume"] = spec;
            delete childBuilders["volume;"];
            modifiedKeys["volume"] = true;
            return this;
        };
        this.pan = (spec) => {
            updates["pan"] = spec;
            delete childBuilders["pan;"];
            modifiedKeys["pan"] = true;
            return this;
        };
        this.elevation = (spec) => {
            updates["elevation"] = spec;
            delete childBuilders["elevation;"];
            modifiedKeys["elevation"] = true;
            return this;
        };
        this.midiBank = (spec) => {
            updates["midiBank"] = spec;
            delete childBuilders["midiBank;"];
            modifiedKeys["midiBank"] = true;
            return this;
        };
        this.midiProgram = (spec) => {
            updates["midiProgram"] = spec;
            delete childBuilders["midiProgram;"];
            modifiedKeys["midiProgram"] = true;
            return this;
        };
        this.id = (spec) => {
            updates["id"] = spec;
            delete childBuilders["id;"];
            modifiedKeys["id"] = true;
            return this;
        };
        this.midiChannel = (spec) => {
            updates["midiChannel"] = spec;
            delete childBuilders["midiChannel;"];
            modifiedKeys["midiChannel"] = true;
            return this;
        };
        this.midiName = (spec) => {
            updates["midiName"] = spec;
            delete childBuilders["midiName;"];
            modifiedKeys["midiName"] = true;
            return this;
        };
    }
}
function patchMidiInstrument(base, builder) { return builder(new MidiInstrumentBuilder(base)).patch(); }
exports.patchMidiInstrument = patchMidiInstrument;
function buildMidiInstrument(builder) { return builder(new MidiInstrumentBuilder()).build(); }
exports.buildMidiInstrument = buildMidiInstrument;
class PlayBuilder {
    build;
    patch;
    ipa;
    mute;
    otherPlay;
    semiPitched;
    id;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["id"]) ||
                childBuilders["id"] !== undefined ||
                updates.id !== undefined, "id is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Play";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.ipa = (spec) => {
            updates["ipa"] = spec;
            delete childBuilders["ipa;"];
            modifiedKeys["ipa"] = true;
            return this;
        };
        this.mute = (spec) => {
            updates["mute"] = spec;
            delete childBuilders["mute;"];
            modifiedKeys["mute"] = true;
            return this;
        };
        this.otherPlay = (build) => {
            if (typeof build === 'function') {
                delete updates["otherPlay"];
                const builder = build(new OtherPlayBuilder(original && original["otherPlay"]));
                if (!original)
                    updates["otherPlay"] = builder.build();
                else
                    childBuilders["otherPlay"] = builder;
            }
            else {
                updates.otherPlay = build;
                delete childBuilders["otherPlay;"];
            }
            modifiedKeys["otherPlay"] = true;
            return this;
        };
        this.semiPitched = (spec) => {
            updates["semiPitched"] = spec;
            delete childBuilders["semiPitched;"];
            modifiedKeys["semiPitched"] = true;
            return this;
        };
        this.id = (spec) => {
            updates["id"] = spec;
            delete childBuilders["id;"];
            modifiedKeys["id"] = true;
            return this;
        };
    }
}
function patchPlay(base, builder) { return builder(new PlayBuilder(base)).patch(); }
exports.patchPlay = patchPlay;
function buildPlay(builder) { return builder(new PlayBuilder()).build(); }
exports.buildPlay = buildPlay;
class OtherPlayBuilder {
    build;
    patch;
    data;
    type;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["data"]) ||
                childBuilders["data"] !== undefined ||
                updates.data !== undefined, "data is a required field");
            console.assert((original && !modifiedKeys["type"]) ||
                childBuilders["type"] !== undefined ||
                updates.type !== undefined, "type is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "OtherPlay";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.data = (spec) => {
            updates["data"] = spec;
            delete childBuilders["data;"];
            modifiedKeys["data"] = true;
            return this;
        };
        this.type = (spec) => {
            updates["type"] = spec;
            delete childBuilders["type;"];
            modifiedKeys["type"] = true;
            return this;
        };
    }
}
function patchOtherPlay(base, builder) { return builder(new OtherPlayBuilder(base)).patch(); }
exports.patchOtherPlay = patchOtherPlay;
function buildOtherPlay(builder) { return builder(new OtherPlayBuilder()).build(); }
exports.buildOtherPlay = buildOtherPlay;
class ScalingBuilder {
    build;
    patch;
    tenths;
    millimeters;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Scaling";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.tenths = (spec) => {
            updates["tenths"] = spec;
            delete childBuilders["tenths;"];
            modifiedKeys["tenths"] = true;
            return this;
        };
        this.millimeters = (spec) => {
            updates["millimeters"] = spec;
            delete childBuilders["millimeters;"];
            modifiedKeys["millimeters"] = true;
            return this;
        };
    }
}
function patchScaling(base, builder) { return builder(new ScalingBuilder(base)).patch(); }
exports.patchScaling = patchScaling;
function buildScaling(builder) { return builder(new ScalingBuilder()).build(); }
exports.buildScaling = buildScaling;
class PageMarginsBuilder {
    build;
    patch;
    topMargin;
    leftMargin;
    bottomMargin;
    type;
    rightMargin;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["topMargin"]) ||
                childBuilders["topMargin"] !== undefined ||
                updates.topMargin !== undefined, "topMargin is a required field");
            console.assert((original && !modifiedKeys["leftMargin"]) ||
                childBuilders["leftMargin"] !== undefined ||
                updates.leftMargin !== undefined, "leftMargin is a required field");
            console.assert((original && !modifiedKeys["bottomMargin"]) ||
                childBuilders["bottomMargin"] !== undefined ||
                updates.bottomMargin !== undefined, "bottomMargin is a required field");
            console.assert((original && !modifiedKeys["rightMargin"]) ||
                childBuilders["rightMargin"] !== undefined ||
                updates.rightMargin !== undefined, "rightMargin is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "PageMargins";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.topMargin = (spec) => {
            updates["topMargin"] = spec;
            delete childBuilders["topMargin;"];
            modifiedKeys["topMargin"] = true;
            return this;
        };
        this.leftMargin = (spec) => {
            updates["leftMargin"] = spec;
            delete childBuilders["leftMargin;"];
            modifiedKeys["leftMargin"] = true;
            return this;
        };
        this.bottomMargin = (spec) => {
            updates["bottomMargin"] = spec;
            delete childBuilders["bottomMargin;"];
            modifiedKeys["bottomMargin"] = true;
            return this;
        };
        this.type = (spec) => {
            updates["type"] = spec;
            delete childBuilders["type;"];
            modifiedKeys["type"] = true;
            return this;
        };
        this.rightMargin = (spec) => {
            updates["rightMargin"] = spec;
            delete childBuilders["rightMargin;"];
            modifiedKeys["rightMargin"] = true;
            return this;
        };
    }
}
function patchPageMargins(base, builder) { return builder(new PageMarginsBuilder(base)).patch(); }
exports.patchPageMargins = patchPageMargins;
function buildPageMargins(builder) { return builder(new PageMarginsBuilder()).build(); }
exports.buildPageMargins = buildPageMargins;
class PageLayoutBuilder {
    build;
    patch;
    pageHeight;
    pageWidth;
    pageMarginsAt;
    pageMarginsSplice;
    pageMargins;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "PageLayout";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.pageHeight = (spec) => {
            updates["pageHeight"] = spec;
            delete childBuilders["pageHeight;"];
            modifiedKeys["pageHeight"] = true;
            return this;
        };
        this.pageWidth = (spec) => {
            updates["pageWidth"] = spec;
            delete childBuilders["pageWidth;"];
            modifiedKeys["pageWidth"] = true;
            return this;
        };
        this.pageMargins = (spec) => {
            updates["pageMargins"] = spec;
            delete childBuilders["pageMargins;"];
            modifiedKeys["pageMargins"] = true;
            return this;
        };
        this.pageMarginsAt = (idx, build) => {
            makeReference("pageMargins");
            if (frozen["pageMargins"][idx]) {
                throw new Error("Patching pageMargins." + idx + " twice in a builder is unsupported.");
            }
            if (original && original._snapshot && original._snapshot["pageMargins"] && original._snapshot["pageMargins"][idx] && !original["pageMargins"][idx]) {
                // Clone snapshot.
                patches.push({ p: ["pageMargins", idx], li: original._snapshot["pageMargins"] });
            }
            if (typeof build === 'function' && reference["pageMargins"][idx]) {
                let patch = build(new PageMarginsBuilder(reference["pageMargins"][idx])).patch();
                patches = patches.concat(patch.map(patch => {
                    // TODO: detach?
                    patch.p = ["pageMargins", idx].concat(patch.p);
                    return patch;
                }));
                frozen["pageMargins"][idx] = true;
                return this;
            }
            let update = typeof build === 'function' ? build(new PageMarginsBuilder(reference["pageMargins"][idx])).build() : build;
            if (original) {
                patches.push({ p: ["pageMargins", idx], li: update });
            }
            else {
                updates["pageMargins"] = reference["pageMargins"]; // TODO: Merge?
            }
            reference["pageMargins"][idx] = update;
            frozen["pageMargins"][idx] = true;
            return this;
        };
        this.pageMarginsSplice = (start, deleteCount, ...items) => {
            makeReference("pageMargins");
            let idx = start;
            if (original) {
                for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
                    if (frozen["pageMargins"][idx]) {
                        throw new Error("Replacing pageMargins." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["pageMargins"][idx];
                    patches.push({ p: ["pageMargins", idx], ld, li: items[idx - start] });
                    frozen["pageMargins"][idx] = true;
                }
                for (; idx < start + deleteCount; ++idx) {
                    if (frozen["pageMargins"][idx]) {
                        throw new Error("Removing pageMargins." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["pageMargins"][idx];
                    patches.push({ p: ["pageMargins", idx], ld });
                }
                for (; idx < start + items.length; ++idx) {
                    patches.push({ p: ["pageMargins", idx], li: items[idx - start] });
                    frozen["pageMargins"][idx] = true;
                }
            }
            reference["pageMargins"].splice(start, deleteCount, ...items);
            updates["pageMargins"] = reference["pageMargins"];
            frozen["pageMargins"].splice(start, deleteCount, ...items.map(i => true));
            return this;
        };
    }
}
function patchPageLayout(base, builder) { return builder(new PageLayoutBuilder(base)).patch(); }
exports.patchPageLayout = patchPageLayout;
function buildPageLayout(builder) { return builder(new PageLayoutBuilder()).build(); }
exports.buildPageLayout = buildPageLayout;
class SystemLayoutBuilder {
    build;
    patch;
    systemDividers;
    systemMargins;
    systemDistance;
    topSystemDistance;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "SystemLayout";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.systemDividers = (build) => {
            if (typeof build === 'function') {
                delete updates["systemDividers"];
                const builder = build(new SystemDividersBuilder(original && original["systemDividers"]));
                if (!original)
                    updates["systemDividers"] = builder.build();
                else
                    childBuilders["systemDividers"] = builder;
            }
            else {
                updates.systemDividers = build;
                delete childBuilders["systemDividers;"];
            }
            modifiedKeys["systemDividers"] = true;
            return this;
        };
        this.systemMargins = (build) => {
            if (typeof build === 'function') {
                delete updates["systemMargins"];
                const builder = build(new SystemMarginsBuilder(original && original["systemMargins"]));
                if (!original)
                    updates["systemMargins"] = builder.build();
                else
                    childBuilders["systemMargins"] = builder;
            }
            else {
                updates.systemMargins = build;
                delete childBuilders["systemMargins;"];
            }
            modifiedKeys["systemMargins"] = true;
            return this;
        };
        this.systemDistance = (spec) => {
            updates["systemDistance"] = spec;
            delete childBuilders["systemDistance;"];
            modifiedKeys["systemDistance"] = true;
            return this;
        };
        this.topSystemDistance = (spec) => {
            updates["topSystemDistance"] = spec;
            delete childBuilders["topSystemDistance;"];
            modifiedKeys["topSystemDistance"] = true;
            return this;
        };
    }
}
function patchSystemLayout(base, builder) { return builder(new SystemLayoutBuilder(base)).patch(); }
exports.patchSystemLayout = patchSystemLayout;
function buildSystemLayout(builder) { return builder(new SystemLayoutBuilder()).build(); }
exports.buildSystemLayout = buildSystemLayout;
class SystemMarginsBuilder {
    build;
    patch;
    leftMargin;
    rightMargin;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["leftMargin"]) ||
                childBuilders["leftMargin"] !== undefined ||
                updates.leftMargin !== undefined, "leftMargin is a required field");
            console.assert((original && !modifiedKeys["rightMargin"]) ||
                childBuilders["rightMargin"] !== undefined ||
                updates.rightMargin !== undefined, "rightMargin is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "SystemMargins";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.leftMargin = (spec) => {
            updates["leftMargin"] = spec;
            delete childBuilders["leftMargin;"];
            modifiedKeys["leftMargin"] = true;
            return this;
        };
        this.rightMargin = (spec) => {
            updates["rightMargin"] = spec;
            delete childBuilders["rightMargin;"];
            modifiedKeys["rightMargin"] = true;
            return this;
        };
    }
}
function patchSystemMargins(base, builder) { return builder(new SystemMarginsBuilder(base)).patch(); }
exports.patchSystemMargins = patchSystemMargins;
function buildSystemMargins(builder) { return builder(new SystemMarginsBuilder()).build(); }
exports.buildSystemMargins = buildSystemMargins;
class SystemDividersBuilder {
    build;
    patch;
    rightDivider;
    leftDivider;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["rightDivider"]) ||
                childBuilders["rightDivider"] !== undefined ||
                updates.rightDivider !== undefined, "rightDivider is a required field");
            console.assert((original && !modifiedKeys["leftDivider"]) ||
                childBuilders["leftDivider"] !== undefined ||
                updates.leftDivider !== undefined, "leftDivider is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "SystemDividers";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.rightDivider = (build) => {
            if (typeof build === 'function') {
                delete updates["rightDivider"];
                const builder = build(new RightDividerBuilder(original && original["rightDivider"]));
                if (!original)
                    updates["rightDivider"] = builder.build();
                else
                    childBuilders["rightDivider"] = builder;
            }
            else {
                updates.rightDivider = build;
                delete childBuilders["rightDivider;"];
            }
            modifiedKeys["rightDivider"] = true;
            return this;
        };
        this.leftDivider = (build) => {
            if (typeof build === 'function') {
                delete updates["leftDivider"];
                const builder = build(new LeftDividerBuilder(original && original["leftDivider"]));
                if (!original)
                    updates["leftDivider"] = builder.build();
                else
                    childBuilders["leftDivider"] = builder;
            }
            else {
                updates.leftDivider = build;
                delete childBuilders["leftDivider;"];
            }
            modifiedKeys["leftDivider"] = true;
            return this;
        };
    }
}
function patchSystemDividers(base, builder) { return builder(new SystemDividersBuilder(base)).patch(); }
exports.patchSystemDividers = patchSystemDividers;
function buildSystemDividers(builder) { return builder(new SystemDividersBuilder()).build(); }
exports.buildSystemDividers = buildSystemDividers;
class LeftDividerBuilder {
    build;
    patch;
    printObject;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    fontFamily;
    fontWeight;
    fontStyle;
    fontSize;
    color;
    halign;
    valign;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "LeftDivider";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.printObject = (spec) => {
            updates["printObject"] = spec;
            delete childBuilders["printObject;"];
            modifiedKeys["printObject"] = true;
            return this;
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
        this.fontFamily = (spec) => {
            updates["fontFamily"] = spec;
            delete childBuilders["fontFamily;"];
            modifiedKeys["fontFamily"] = true;
            return this;
        };
        this.fontWeight = (spec) => {
            updates["fontWeight"] = spec;
            delete childBuilders["fontWeight;"];
            modifiedKeys["fontWeight"] = true;
            return this;
        };
        this.fontStyle = (spec) => {
            updates["fontStyle"] = spec;
            delete childBuilders["fontStyle;"];
            modifiedKeys["fontStyle"] = true;
            return this;
        };
        this.fontSize = (spec) => {
            updates["fontSize"] = spec;
            delete childBuilders["fontSize;"];
            modifiedKeys["fontSize"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
        this.halign = (spec) => {
            updates["halign"] = spec;
            delete childBuilders["halign;"];
            modifiedKeys["halign"] = true;
            return this;
        };
        this.valign = (spec) => {
            updates["valign"] = spec;
            delete childBuilders["valign;"];
            modifiedKeys["valign"] = true;
            return this;
        };
    }
}
function patchLeftDivider(base, builder) { return builder(new LeftDividerBuilder(base)).patch(); }
exports.patchLeftDivider = patchLeftDivider;
function buildLeftDivider(builder) { return builder(new LeftDividerBuilder()).build(); }
exports.buildLeftDivider = buildLeftDivider;
class RightDividerBuilder {
    build;
    patch;
    printObject;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    fontFamily;
    fontWeight;
    fontStyle;
    fontSize;
    color;
    halign;
    valign;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "RightDivider";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.printObject = (spec) => {
            updates["printObject"] = spec;
            delete childBuilders["printObject;"];
            modifiedKeys["printObject"] = true;
            return this;
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
        this.fontFamily = (spec) => {
            updates["fontFamily"] = spec;
            delete childBuilders["fontFamily;"];
            modifiedKeys["fontFamily"] = true;
            return this;
        };
        this.fontWeight = (spec) => {
            updates["fontWeight"] = spec;
            delete childBuilders["fontWeight;"];
            modifiedKeys["fontWeight"] = true;
            return this;
        };
        this.fontStyle = (spec) => {
            updates["fontStyle"] = spec;
            delete childBuilders["fontStyle;"];
            modifiedKeys["fontStyle"] = true;
            return this;
        };
        this.fontSize = (spec) => {
            updates["fontSize"] = spec;
            delete childBuilders["fontSize;"];
            modifiedKeys["fontSize"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
        this.halign = (spec) => {
            updates["halign"] = spec;
            delete childBuilders["halign;"];
            modifiedKeys["halign"] = true;
            return this;
        };
        this.valign = (spec) => {
            updates["valign"] = spec;
            delete childBuilders["valign;"];
            modifiedKeys["valign"] = true;
            return this;
        };
    }
}
function patchRightDivider(base, builder) { return builder(new RightDividerBuilder(base)).patch(); }
exports.patchRightDivider = patchRightDivider;
function buildRightDivider(builder) { return builder(new RightDividerBuilder()).build(); }
exports.buildRightDivider = buildRightDivider;
class StaffLayoutBuilder {
    build;
    patch;
    staffDistance;
    number;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["number"]) ||
                childBuilders["number"] !== undefined ||
                updates.number !== undefined, "number is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "StaffLayout";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.staffDistance = (spec) => {
            updates["staffDistance"] = spec;
            delete childBuilders["staffDistance;"];
            modifiedKeys["staffDistance"] = true;
            return this;
        };
        this.number = (spec) => {
            updates["number"] = spec;
            delete childBuilders["number;"];
            modifiedKeys["number"] = true;
            return this;
        };
    }
}
function patchStaffLayout(base, builder) { return builder(new StaffLayoutBuilder(base)).patch(); }
exports.patchStaffLayout = patchStaffLayout;
function buildStaffLayout(builder) { return builder(new StaffLayoutBuilder()).build(); }
exports.buildStaffLayout = buildStaffLayout;
class MeasureLayoutBuilder {
    build;
    patch;
    measureDistance;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "MeasureLayout";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.measureDistance = (spec) => {
            updates["measureDistance"] = spec;
            delete childBuilders["measureDistance;"];
            modifiedKeys["measureDistance"] = true;
            return this;
        };
    }
}
function patchMeasureLayout(base, builder) { return builder(new MeasureLayoutBuilder(base)).patch(); }
exports.patchMeasureLayout = patchMeasureLayout;
function buildMeasureLayout(builder) { return builder(new MeasureLayoutBuilder()).build(); }
exports.buildMeasureLayout = buildMeasureLayout;
class LineWidthBuilder {
    build;
    patch;
    tenths;
    type;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["tenths"]) ||
                childBuilders["tenths"] !== undefined ||
                updates.tenths !== undefined, "tenths is a required field");
            console.assert((original && !modifiedKeys["type"]) ||
                childBuilders["type"] !== undefined ||
                updates.type !== undefined, "type is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "LineWidth";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.tenths = (spec) => {
            updates["tenths"] = spec;
            delete childBuilders["tenths;"];
            modifiedKeys["tenths"] = true;
            return this;
        };
        this.type = (spec) => {
            updates["type"] = spec;
            delete childBuilders["type;"];
            modifiedKeys["type"] = true;
            return this;
        };
    }
}
function patchLineWidth(base, builder) { return builder(new LineWidthBuilder(base)).patch(); }
exports.patchLineWidth = patchLineWidth;
function buildLineWidth(builder) { return builder(new LineWidthBuilder()).build(); }
exports.buildLineWidth = buildLineWidth;
class NoteSizeBuilder {
    build;
    patch;
    size;
    type;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["size"]) ||
                childBuilders["size"] !== undefined ||
                updates.size !== undefined, "size is a required field");
            console.assert((original && !modifiedKeys["type"]) ||
                childBuilders["type"] !== undefined ||
                updates.type !== undefined, "type is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "NoteSize";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.size = (spec) => {
            updates["size"] = spec;
            delete childBuilders["size;"];
            modifiedKeys["size"] = true;
            return this;
        };
        this.type = (spec) => {
            updates["type"] = spec;
            delete childBuilders["type;"];
            modifiedKeys["type"] = true;
            return this;
        };
    }
}
function patchNoteSize(base, builder) { return builder(new NoteSizeBuilder(base)).patch(); }
exports.patchNoteSize = patchNoteSize;
function buildNoteSize(builder) { return builder(new NoteSizeBuilder()).build(); }
exports.buildNoteSize = buildNoteSize;
class DistanceBuilder {
    build;
    patch;
    tenths;
    type;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["tenths"]) ||
                childBuilders["tenths"] !== undefined ||
                updates.tenths !== undefined, "tenths is a required field");
            console.assert((original && !modifiedKeys["type"]) ||
                childBuilders["type"] !== undefined ||
                updates.type !== undefined, "type is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Distance";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.tenths = (spec) => {
            updates["tenths"] = spec;
            delete childBuilders["tenths;"];
            modifiedKeys["tenths"] = true;
            return this;
        };
        this.type = (spec) => {
            updates["type"] = spec;
            delete childBuilders["type;"];
            modifiedKeys["type"] = true;
            return this;
        };
    }
}
function patchDistance(base, builder) { return builder(new DistanceBuilder(base)).patch(); }
exports.patchDistance = patchDistance;
function buildDistance(builder) { return builder(new DistanceBuilder()).build(); }
exports.buildDistance = buildDistance;
class AppearanceBuilder {
    build;
    patch;
    set;
    otherAppearances;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Appearance";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.set = (key, val) => {
            updates[key] = val;
            modifiedKeys[key] = true;
            return this;
        };
        this.otherAppearances = (spec) => {
            updates["otherAppearances"] = spec;
            delete childBuilders["otherAppearances;"];
            modifiedKeys["otherAppearances"] = true;
            return this;
        };
    }
}
function patchAppearance(base, builder) { return builder(new AppearanceBuilder(base)).patch(); }
exports.patchAppearance = patchAppearance;
function buildAppearance(builder) { return builder(new AppearanceBuilder()).build(); }
exports.buildAppearance = buildAppearance;
class CreatorBuilder {
    build;
    patch;
    creator;
    type;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["creator"]) ||
                childBuilders["creator"] !== undefined ||
                updates.creator !== undefined, "creator is a required field");
            console.assert((original && !modifiedKeys["type"]) ||
                childBuilders["type"] !== undefined ||
                updates.type !== undefined, "type is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Creator";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.creator = (spec) => {
            updates["creator"] = spec;
            delete childBuilders["creator;"];
            modifiedKeys["creator"] = true;
            return this;
        };
        this.type = (spec) => {
            updates["type"] = spec;
            delete childBuilders["type;"];
            modifiedKeys["type"] = true;
            return this;
        };
    }
}
function patchCreator(base, builder) { return builder(new CreatorBuilder(base)).patch(); }
exports.patchCreator = patchCreator;
function buildCreator(builder) { return builder(new CreatorBuilder()).build(); }
exports.buildCreator = buildCreator;
class RightsBuilder {
    build;
    patch;
    type;
    rights;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["type"]) ||
                childBuilders["type"] !== undefined ||
                updates.type !== undefined, "type is a required field");
            console.assert((original && !modifiedKeys["rights"]) ||
                childBuilders["rights"] !== undefined ||
                updates.rights !== undefined, "rights is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Rights";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.type = (spec) => {
            updates["type"] = spec;
            delete childBuilders["type;"];
            modifiedKeys["type"] = true;
            return this;
        };
        this.rights = (spec) => {
            updates["rights"] = spec;
            delete childBuilders["rights;"];
            modifiedKeys["rights"] = true;
            return this;
        };
    }
}
function patchRights(base, builder) { return builder(new RightsBuilder(base)).patch(); }
exports.patchRights = patchRights;
function buildRights(builder) { return builder(new RightsBuilder()).build(); }
exports.buildRights = buildRights;
class EncoderBuilder {
    build;
    patch;
    encoder;
    type;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["encoder"]) ||
                childBuilders["encoder"] !== undefined ||
                updates.encoder !== undefined, "encoder is a required field");
            console.assert((original && !modifiedKeys["type"]) ||
                childBuilders["type"] !== undefined ||
                updates.type !== undefined, "type is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Encoder";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.encoder = (spec) => {
            updates["encoder"] = spec;
            delete childBuilders["encoder;"];
            modifiedKeys["encoder"] = true;
            return this;
        };
        this.type = (spec) => {
            updates["type"] = spec;
            delete childBuilders["type;"];
            modifiedKeys["type"] = true;
            return this;
        };
    }
}
function patchEncoder(base, builder) { return builder(new EncoderBuilder(base)).patch(); }
exports.patchEncoder = patchEncoder;
function buildEncoder(builder) { return builder(new EncoderBuilder()).build(); }
exports.buildEncoder = buildEncoder;
class RelationBuilder {
    build;
    patch;
    type;
    data;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["type"]) ||
                childBuilders["type"] !== undefined ||
                updates.type !== undefined, "type is a required field");
            console.assert((original && !modifiedKeys["data"]) ||
                childBuilders["data"] !== undefined ||
                updates.data !== undefined, "data is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Relation";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.type = (spec) => {
            updates["type"] = spec;
            delete childBuilders["type;"];
            modifiedKeys["type"] = true;
            return this;
        };
        this.data = (spec) => {
            updates["data"] = spec;
            delete childBuilders["data;"];
            modifiedKeys["data"] = true;
            return this;
        };
    }
}
function patchRelation(base, builder) { return builder(new RelationBuilder(base)).patch(); }
exports.patchRelation = patchRelation;
function buildRelation(builder) { return builder(new RelationBuilder()).build(); }
exports.buildRelation = buildRelation;
class MiscellaneousFieldBuilder {
    build;
    patch;
    data;
    name;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["data"]) ||
                childBuilders["data"] !== undefined ||
                updates.data !== undefined, "data is a required field");
            console.assert((original && !modifiedKeys["name"]) ||
                childBuilders["name"] !== undefined ||
                updates.name !== undefined, "name is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "MiscellaneousField";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.data = (spec) => {
            updates["data"] = spec;
            delete childBuilders["data;"];
            modifiedKeys["data"] = true;
            return this;
        };
        this.name = (spec) => {
            updates["name"] = spec;
            delete childBuilders["name;"];
            modifiedKeys["name"] = true;
            return this;
        };
    }
}
function patchMiscellaneousField(base, builder) { return builder(new MiscellaneousFieldBuilder(base)).patch(); }
exports.patchMiscellaneousField = patchMiscellaneousField;
function buildMiscellaneousField(builder) { return builder(new MiscellaneousFieldBuilder()).build(); }
exports.buildMiscellaneousField = buildMiscellaneousField;
class MiscellaneousBuilder {
    build;
    patch;
    miscellaneousFieldsAt;
    miscellaneousFieldsSplice;
    miscellaneousFields;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Miscellaneous";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.miscellaneousFields = (spec) => {
            updates["miscellaneousFields"] = spec;
            delete childBuilders["miscellaneousFields;"];
            modifiedKeys["miscellaneousFields"] = true;
            return this;
        };
        this.miscellaneousFieldsAt = (idx, build) => {
            makeReference("miscellaneousFields");
            if (frozen["miscellaneousFields"][idx]) {
                throw new Error("Patching miscellaneousFields." + idx + " twice in a builder is unsupported.");
            }
            if (original && original._snapshot && original._snapshot["miscellaneousFields"] && original._snapshot["miscellaneousFields"][idx] && !original["miscellaneousFields"][idx]) {
                // Clone snapshot.
                patches.push({ p: ["miscellaneousFields", idx], li: original._snapshot["miscellaneousFields"] });
            }
            if (typeof build === 'function' && reference["miscellaneousFields"][idx]) {
                let patch = build(new MiscellaneousFieldBuilder(reference["miscellaneousFields"][idx])).patch();
                patches = patches.concat(patch.map(patch => {
                    // TODO: detach?
                    patch.p = ["miscellaneousFields", idx].concat(patch.p);
                    return patch;
                }));
                frozen["miscellaneousFields"][idx] = true;
                return this;
            }
            let update = typeof build === 'function' ? build(new MiscellaneousFieldBuilder(reference["miscellaneousFields"][idx])).build() : build;
            if (original) {
                patches.push({ p: ["miscellaneousFields", idx], li: update });
            }
            else {
                updates["miscellaneousFields"] = reference["miscellaneousFields"]; // TODO: Merge?
            }
            reference["miscellaneousFields"][idx] = update;
            frozen["miscellaneousFields"][idx] = true;
            return this;
        };
        this.miscellaneousFieldsSplice = (start, deleteCount, ...items) => {
            makeReference("miscellaneousFields");
            let idx = start;
            if (original) {
                for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
                    if (frozen["miscellaneousFields"][idx]) {
                        throw new Error("Replacing miscellaneousFields." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["miscellaneousFields"][idx];
                    patches.push({ p: ["miscellaneousFields", idx], ld, li: items[idx - start] });
                    frozen["miscellaneousFields"][idx] = true;
                }
                for (; idx < start + deleteCount; ++idx) {
                    if (frozen["miscellaneousFields"][idx]) {
                        throw new Error("Removing miscellaneousFields." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["miscellaneousFields"][idx];
                    patches.push({ p: ["miscellaneousFields", idx], ld });
                }
                for (; idx < start + items.length; ++idx) {
                    patches.push({ p: ["miscellaneousFields", idx], li: items[idx - start] });
                    frozen["miscellaneousFields"][idx] = true;
                }
            }
            reference["miscellaneousFields"].splice(start, deleteCount, ...items);
            updates["miscellaneousFields"] = reference["miscellaneousFields"];
            frozen["miscellaneousFields"].splice(start, deleteCount, ...items.map(i => true));
            return this;
        };
    }
}
function patchMiscellaneous(base, builder) { return builder(new MiscellaneousBuilder(base)).patch(); }
exports.patchMiscellaneous = patchMiscellaneous;
function buildMiscellaneous(builder) { return builder(new MiscellaneousBuilder()).build(); }
exports.buildMiscellaneous = buildMiscellaneous;
class IdentificationBuilder {
    build;
    patch;
    miscellaneous;
    creatorsAt;
    creatorsSplice;
    creators;
    relationsAt;
    relationsSplice;
    relations;
    rightsAt;
    rightsSplice;
    rights;
    encoding;
    source;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Identification";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.miscellaneous = (build) => {
            if (typeof build === 'function') {
                delete updates["miscellaneous"];
                const builder = build(new MiscellaneousBuilder(original && original["miscellaneous"]));
                if (!original)
                    updates["miscellaneous"] = builder.build();
                else
                    childBuilders["miscellaneous"] = builder;
            }
            else {
                updates.miscellaneous = build;
                delete childBuilders["miscellaneous;"];
            }
            modifiedKeys["miscellaneous"] = true;
            return this;
        };
        this.creators = (spec) => {
            updates["creators"] = spec;
            delete childBuilders["creators;"];
            modifiedKeys["creators"] = true;
            return this;
        };
        this.creatorsAt = (idx, build) => {
            makeReference("creators");
            if (frozen["creators"][idx]) {
                throw new Error("Patching creators." + idx + " twice in a builder is unsupported.");
            }
            if (original && original._snapshot && original._snapshot["creators"] && original._snapshot["creators"][idx] && !original["creators"][idx]) {
                // Clone snapshot.
                patches.push({ p: ["creators", idx], li: original._snapshot["creators"] });
            }
            if (typeof build === 'function' && reference["creators"][idx]) {
                let patch = build(new CreatorBuilder(reference["creators"][idx])).patch();
                patches = patches.concat(patch.map(patch => {
                    // TODO: detach?
                    patch.p = ["creators", idx].concat(patch.p);
                    return patch;
                }));
                frozen["creators"][idx] = true;
                return this;
            }
            let update = typeof build === 'function' ? build(new CreatorBuilder(reference["creators"][idx])).build() : build;
            if (original) {
                patches.push({ p: ["creators", idx], li: update });
            }
            else {
                updates["creators"] = reference["creators"]; // TODO: Merge?
            }
            reference["creators"][idx] = update;
            frozen["creators"][idx] = true;
            return this;
        };
        this.creatorsSplice = (start, deleteCount, ...items) => {
            makeReference("creators");
            let idx = start;
            if (original) {
                for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
                    if (frozen["creators"][idx]) {
                        throw new Error("Replacing creators." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["creators"][idx];
                    patches.push({ p: ["creators", idx], ld, li: items[idx - start] });
                    frozen["creators"][idx] = true;
                }
                for (; idx < start + deleteCount; ++idx) {
                    if (frozen["creators"][idx]) {
                        throw new Error("Removing creators." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["creators"][idx];
                    patches.push({ p: ["creators", idx], ld });
                }
                for (; idx < start + items.length; ++idx) {
                    patches.push({ p: ["creators", idx], li: items[idx - start] });
                    frozen["creators"][idx] = true;
                }
            }
            reference["creators"].splice(start, deleteCount, ...items);
            updates["creators"] = reference["creators"];
            frozen["creators"].splice(start, deleteCount, ...items.map(i => true));
            return this;
        };
        this.relations = (spec) => {
            updates["relations"] = spec;
            delete childBuilders["relations;"];
            modifiedKeys["relations"] = true;
            return this;
        };
        this.relationsAt = (idx, build) => {
            makeReference("relations");
            if (frozen["relations"][idx]) {
                throw new Error("Patching relations." + idx + " twice in a builder is unsupported.");
            }
            if (original && original._snapshot && original._snapshot["relations"] && original._snapshot["relations"][idx] && !original["relations"][idx]) {
                // Clone snapshot.
                patches.push({ p: ["relations", idx], li: original._snapshot["relations"] });
            }
            if (typeof build === 'function' && reference["relations"][idx]) {
                let patch = build(new RelationBuilder(reference["relations"][idx])).patch();
                patches = patches.concat(patch.map(patch => {
                    // TODO: detach?
                    patch.p = ["relations", idx].concat(patch.p);
                    return patch;
                }));
                frozen["relations"][idx] = true;
                return this;
            }
            let update = typeof build === 'function' ? build(new RelationBuilder(reference["relations"][idx])).build() : build;
            if (original) {
                patches.push({ p: ["relations", idx], li: update });
            }
            else {
                updates["relations"] = reference["relations"]; // TODO: Merge?
            }
            reference["relations"][idx] = update;
            frozen["relations"][idx] = true;
            return this;
        };
        this.relationsSplice = (start, deleteCount, ...items) => {
            makeReference("relations");
            let idx = start;
            if (original) {
                for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
                    if (frozen["relations"][idx]) {
                        throw new Error("Replacing relations." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["relations"][idx];
                    patches.push({ p: ["relations", idx], ld, li: items[idx - start] });
                    frozen["relations"][idx] = true;
                }
                for (; idx < start + deleteCount; ++idx) {
                    if (frozen["relations"][idx]) {
                        throw new Error("Removing relations." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["relations"][idx];
                    patches.push({ p: ["relations", idx], ld });
                }
                for (; idx < start + items.length; ++idx) {
                    patches.push({ p: ["relations", idx], li: items[idx - start] });
                    frozen["relations"][idx] = true;
                }
            }
            reference["relations"].splice(start, deleteCount, ...items);
            updates["relations"] = reference["relations"];
            frozen["relations"].splice(start, deleteCount, ...items.map(i => true));
            return this;
        };
        this.rights = (spec) => {
            updates["rights"] = spec;
            delete childBuilders["rights;"];
            modifiedKeys["rights"] = true;
            return this;
        };
        this.rightsAt = (idx, build) => {
            makeReference("rights");
            if (frozen["rights"][idx]) {
                throw new Error("Patching rights." + idx + " twice in a builder is unsupported.");
            }
            if (original && original._snapshot && original._snapshot["rights"] && original._snapshot["rights"][idx] && !original["rights"][idx]) {
                // Clone snapshot.
                patches.push({ p: ["rights", idx], li: original._snapshot["rights"] });
            }
            if (typeof build === 'function' && reference["rights"][idx]) {
                let patch = build(new RightsBuilder(reference["rights"][idx])).patch();
                patches = patches.concat(patch.map(patch => {
                    // TODO: detach?
                    patch.p = ["rights", idx].concat(patch.p);
                    return patch;
                }));
                frozen["rights"][idx] = true;
                return this;
            }
            let update = typeof build === 'function' ? build(new RightsBuilder(reference["rights"][idx])).build() : build;
            if (original) {
                patches.push({ p: ["rights", idx], li: update });
            }
            else {
                updates["rights"] = reference["rights"]; // TODO: Merge?
            }
            reference["rights"][idx] = update;
            frozen["rights"][idx] = true;
            return this;
        };
        this.rightsSplice = (start, deleteCount, ...items) => {
            makeReference("rights");
            let idx = start;
            if (original) {
                for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
                    if (frozen["rights"][idx]) {
                        throw new Error("Replacing rights." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["rights"][idx];
                    patches.push({ p: ["rights", idx], ld, li: items[idx - start] });
                    frozen["rights"][idx] = true;
                }
                for (; idx < start + deleteCount; ++idx) {
                    if (frozen["rights"][idx]) {
                        throw new Error("Removing rights." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["rights"][idx];
                    patches.push({ p: ["rights", idx], ld });
                }
                for (; idx < start + items.length; ++idx) {
                    patches.push({ p: ["rights", idx], li: items[idx - start] });
                    frozen["rights"][idx] = true;
                }
            }
            reference["rights"].splice(start, deleteCount, ...items);
            updates["rights"] = reference["rights"];
            frozen["rights"].splice(start, deleteCount, ...items.map(i => true));
            return this;
        };
        this.encoding = (build) => {
            if (typeof build === 'function') {
                delete updates["encoding"];
                const builder = build(new EncodingBuilder(original && original["encoding"]));
                if (!original)
                    updates["encoding"] = builder.build();
                else
                    childBuilders["encoding"] = builder;
            }
            else {
                updates.encoding = build;
                delete childBuilders["encoding;"];
            }
            modifiedKeys["encoding"] = true;
            return this;
        };
        this.source = (spec) => {
            updates["source"] = spec;
            delete childBuilders["source;"];
            modifiedKeys["source"] = true;
            return this;
        };
    }
}
function patchIdentification(base, builder) { return builder(new IdentificationBuilder(base)).patch(); }
exports.patchIdentification = patchIdentification;
function buildIdentification(builder) { return builder(new IdentificationBuilder()).build(); }
exports.buildIdentification = buildIdentification;
class SupportsBuilder {
    build;
    patch;
    element;
    attribute;
    value;
    type;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["element"]) ||
                childBuilders["element"] !== undefined ||
                updates.element !== undefined, "element is a required field");
            console.assert((original && !modifiedKeys["type"]) ||
                childBuilders["type"] !== undefined ||
                updates.type !== undefined, "type is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Supports";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.element = (spec) => {
            updates["element"] = spec;
            delete childBuilders["element;"];
            modifiedKeys["element"] = true;
            return this;
        };
        this.attribute = (spec) => {
            updates["attribute"] = spec;
            delete childBuilders["attribute;"];
            modifiedKeys["attribute"] = true;
            return this;
        };
        this.value = (spec) => {
            updates["value"] = spec;
            delete childBuilders["value;"];
            modifiedKeys["value"] = true;
            return this;
        };
        this.type = (spec) => {
            updates["type"] = spec;
            delete childBuilders["type;"];
            modifiedKeys["type"] = true;
            return this;
        };
    }
}
function patchSupports(base, builder) { return builder(new SupportsBuilder(base)).patch(); }
exports.patchSupports = patchSupports;
function buildSupports(builder) { return builder(new SupportsBuilder()).build(); }
exports.buildSupports = buildSupports;
class EncodingBuilder {
    build;
    patch;
    encodingDescriptions;
    encodingDate;
    set;
    encodersAt;
    encodersSplice;
    encoders;
    softwares;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Encoding";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.encodingDescriptions = (spec) => {
            updates["encodingDescriptions"] = spec;
            delete childBuilders["encodingDescriptions;"];
            modifiedKeys["encodingDescriptions"] = true;
            return this;
        };
        this.encodingDate = (build) => {
            if (typeof build === 'function') {
                delete updates["encodingDate"];
                const builder = build(new EncodingDateBuilder(original && original["encodingDate"]));
                if (!original)
                    updates["encodingDate"] = builder.build();
                else
                    childBuilders["encodingDate"] = builder;
            }
            else {
                updates.encodingDate = build;
                delete childBuilders["encodingDate;"];
            }
            modifiedKeys["encodingDate"] = true;
            return this;
        };
        this.set = (key, val) => {
            updates[key] = val;
            modifiedKeys[key] = true;
            return this;
        };
        this.encoders = (spec) => {
            updates["encoders"] = spec;
            delete childBuilders["encoders;"];
            modifiedKeys["encoders"] = true;
            return this;
        };
        this.encodersAt = (idx, build) => {
            makeReference("encoders");
            if (frozen["encoders"][idx]) {
                throw new Error("Patching encoders." + idx + " twice in a builder is unsupported.");
            }
            if (original && original._snapshot && original._snapshot["encoders"] && original._snapshot["encoders"][idx] && !original["encoders"][idx]) {
                // Clone snapshot.
                patches.push({ p: ["encoders", idx], li: original._snapshot["encoders"] });
            }
            if (typeof build === 'function' && reference["encoders"][idx]) {
                let patch = build(new EncoderBuilder(reference["encoders"][idx])).patch();
                patches = patches.concat(patch.map(patch => {
                    // TODO: detach?
                    patch.p = ["encoders", idx].concat(patch.p);
                    return patch;
                }));
                frozen["encoders"][idx] = true;
                return this;
            }
            let update = typeof build === 'function' ? build(new EncoderBuilder(reference["encoders"][idx])).build() : build;
            if (original) {
                patches.push({ p: ["encoders", idx], li: update });
            }
            else {
                updates["encoders"] = reference["encoders"]; // TODO: Merge?
            }
            reference["encoders"][idx] = update;
            frozen["encoders"][idx] = true;
            return this;
        };
        this.encodersSplice = (start, deleteCount, ...items) => {
            makeReference("encoders");
            let idx = start;
            if (original) {
                for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
                    if (frozen["encoders"][idx]) {
                        throw new Error("Replacing encoders." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["encoders"][idx];
                    patches.push({ p: ["encoders", idx], ld, li: items[idx - start] });
                    frozen["encoders"][idx] = true;
                }
                for (; idx < start + deleteCount; ++idx) {
                    if (frozen["encoders"][idx]) {
                        throw new Error("Removing encoders." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["encoders"][idx];
                    patches.push({ p: ["encoders", idx], ld });
                }
                for (; idx < start + items.length; ++idx) {
                    patches.push({ p: ["encoders", idx], li: items[idx - start] });
                    frozen["encoders"][idx] = true;
                }
            }
            reference["encoders"].splice(start, deleteCount, ...items);
            updates["encoders"] = reference["encoders"];
            frozen["encoders"].splice(start, deleteCount, ...items.map(i => true));
            return this;
        };
        this.softwares = (spec) => {
            updates["softwares"] = spec;
            delete childBuilders["softwares;"];
            modifiedKeys["softwares"] = true;
            return this;
        };
    }
}
function patchEncoding(base, builder) { return builder(new EncodingBuilder(base)).patch(); }
exports.patchEncoding = patchEncoding;
function buildEncoding(builder) { return builder(new EncodingBuilder()).build(); }
exports.buildEncoding = buildEncoding;
class TimeSeparatorBuilder {
    build;
    patch;
    separator;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "TimeSeparator";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.separator = (spec) => {
            updates["separator"] = spec;
            delete childBuilders["separator;"];
            modifiedKeys["separator"] = true;
            return this;
        };
    }
}
function patchTimeSeparator(base, builder) { return builder(new TimeSeparatorBuilder(base)).patch(); }
exports.patchTimeSeparator = patchTimeSeparator;
function buildTimeSeparator(builder) { return builder(new TimeSeparatorBuilder()).build(); }
exports.buildTimeSeparator = buildTimeSeparator;
class TimeSymbolBuilder {
    build;
    patch;
    symbol;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "TimeSymbol";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.symbol = (spec) => {
            updates["symbol"] = spec;
            delete childBuilders["symbol;"];
            modifiedKeys["symbol"] = true;
            return this;
        };
    }
}
function patchTimeSymbol(base, builder) { return builder(new TimeSymbolBuilder(base)).patch(); }
exports.patchTimeSymbol = patchTimeSymbol;
function buildTimeSymbol(builder) { return builder(new TimeSymbolBuilder()).build(); }
exports.buildTimeSymbol = buildTimeSymbol;
class CancelBuilder {
    build;
    patch;
    fifths;
    location;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["fifths"]) ||
                childBuilders["fifths"] !== undefined ||
                updates.fifths !== undefined, "fifths is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Cancel";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.fifths = (spec) => {
            updates["fifths"] = spec;
            delete childBuilders["fifths;"];
            modifiedKeys["fifths"] = true;
            return this;
        };
        this.location = (spec) => {
            updates["location"] = spec;
            delete childBuilders["location;"];
            modifiedKeys["location"] = true;
            return this;
        };
    }
}
function patchCancel(base, builder) { return builder(new CancelBuilder(base)).patch(); }
exports.patchCancel = patchCancel;
function buildCancel(builder) { return builder(new CancelBuilder()).build(); }
exports.buildCancel = buildCancel;
class KeyOctaveBuilder {
    build;
    patch;
    octave;
    number;
    cancel;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["octave"]) ||
                childBuilders["octave"] !== undefined ||
                updates.octave !== undefined, "octave is a required field");
            console.assert((original && !modifiedKeys["number"]) ||
                childBuilders["number"] !== undefined ||
                updates.number !== undefined, "number is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "KeyOctave";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.octave = (spec) => {
            updates["octave"] = spec;
            delete childBuilders["octave;"];
            modifiedKeys["octave"] = true;
            return this;
        };
        this.number = (spec) => {
            updates["number"] = spec;
            delete childBuilders["number;"];
            modifiedKeys["number"] = true;
            return this;
        };
        this.cancel = (spec) => {
            updates["cancel"] = spec;
            delete childBuilders["cancel;"];
            modifiedKeys["cancel"] = true;
            return this;
        };
    }
}
function patchKeyOctave(base, builder) { return builder(new KeyOctaveBuilder(base)).patch(); }
exports.patchKeyOctave = patchKeyOctave;
function buildKeyOctave(builder) { return builder(new KeyOctaveBuilder()).build(); }
exports.buildKeyOctave = buildKeyOctave;
class KeyBuilder {
    build;
    patch;
    cancel;
    keySteps;
    keyOctavesAt;
    keyOctavesSplice;
    keyOctaves;
    number;
    fifths;
    keyAlters;
    keyAccidentals;
    mode;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    fontFamily;
    fontWeight;
    fontStyle;
    fontSize;
    color;
    printObject;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Key";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.cancel = (build) => {
            if (typeof build === 'function') {
                delete updates["cancel"];
                const builder = build(new CancelBuilder(original && original["cancel"]));
                if (!original)
                    updates["cancel"] = builder.build();
                else
                    childBuilders["cancel"] = builder;
            }
            else {
                updates.cancel = build;
                delete childBuilders["cancel;"];
            }
            modifiedKeys["cancel"] = true;
            return this;
        };
        this.keySteps = (spec) => {
            updates["keySteps"] = spec;
            delete childBuilders["keySteps;"];
            modifiedKeys["keySteps"] = true;
            return this;
        };
        this.keyOctaves = (spec) => {
            updates["keyOctaves"] = spec;
            delete childBuilders["keyOctaves;"];
            modifiedKeys["keyOctaves"] = true;
            return this;
        };
        this.keyOctavesAt = (idx, build) => {
            makeReference("keyOctaves");
            if (frozen["keyOctaves"][idx]) {
                throw new Error("Patching keyOctaves." + idx + " twice in a builder is unsupported.");
            }
            if (original && original._snapshot && original._snapshot["keyOctaves"] && original._snapshot["keyOctaves"][idx] && !original["keyOctaves"][idx]) {
                // Clone snapshot.
                patches.push({ p: ["keyOctaves", idx], li: original._snapshot["keyOctaves"] });
            }
            if (typeof build === 'function' && reference["keyOctaves"][idx]) {
                let patch = build(new KeyOctaveBuilder(reference["keyOctaves"][idx])).patch();
                patches = patches.concat(patch.map(patch => {
                    // TODO: detach?
                    patch.p = ["keyOctaves", idx].concat(patch.p);
                    return patch;
                }));
                frozen["keyOctaves"][idx] = true;
                return this;
            }
            let update = typeof build === 'function' ? build(new KeyOctaveBuilder(reference["keyOctaves"][idx])).build() : build;
            if (original) {
                patches.push({ p: ["keyOctaves", idx], li: update });
            }
            else {
                updates["keyOctaves"] = reference["keyOctaves"]; // TODO: Merge?
            }
            reference["keyOctaves"][idx] = update;
            frozen["keyOctaves"][idx] = true;
            return this;
        };
        this.keyOctavesSplice = (start, deleteCount, ...items) => {
            makeReference("keyOctaves");
            let idx = start;
            if (original) {
                for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
                    if (frozen["keyOctaves"][idx]) {
                        throw new Error("Replacing keyOctaves." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["keyOctaves"][idx];
                    patches.push({ p: ["keyOctaves", idx], ld, li: items[idx - start] });
                    frozen["keyOctaves"][idx] = true;
                }
                for (; idx < start + deleteCount; ++idx) {
                    if (frozen["keyOctaves"][idx]) {
                        throw new Error("Removing keyOctaves." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["keyOctaves"][idx];
                    patches.push({ p: ["keyOctaves", idx], ld });
                }
                for (; idx < start + items.length; ++idx) {
                    patches.push({ p: ["keyOctaves", idx], li: items[idx - start] });
                    frozen["keyOctaves"][idx] = true;
                }
            }
            reference["keyOctaves"].splice(start, deleteCount, ...items);
            updates["keyOctaves"] = reference["keyOctaves"];
            frozen["keyOctaves"].splice(start, deleteCount, ...items.map(i => true));
            return this;
        };
        this.number = (spec) => {
            updates["number"] = spec;
            delete childBuilders["number;"];
            modifiedKeys["number"] = true;
            return this;
        };
        this.fifths = (spec) => {
            updates["fifths"] = spec;
            delete childBuilders["fifths;"];
            modifiedKeys["fifths"] = true;
            return this;
        };
        this.keyAlters = (spec) => {
            updates["keyAlters"] = spec;
            delete childBuilders["keyAlters;"];
            modifiedKeys["keyAlters"] = true;
            return this;
        };
        this.keyAccidentals = (spec) => {
            updates["keyAccidentals"] = spec;
            delete childBuilders["keyAccidentals;"];
            modifiedKeys["keyAccidentals"] = true;
            return this;
        };
        this.mode = (spec) => {
            updates["mode"] = spec;
            delete childBuilders["mode;"];
            modifiedKeys["mode"] = true;
            return this;
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
        this.fontFamily = (spec) => {
            updates["fontFamily"] = spec;
            delete childBuilders["fontFamily;"];
            modifiedKeys["fontFamily"] = true;
            return this;
        };
        this.fontWeight = (spec) => {
            updates["fontWeight"] = spec;
            delete childBuilders["fontWeight;"];
            modifiedKeys["fontWeight"] = true;
            return this;
        };
        this.fontStyle = (spec) => {
            updates["fontStyle"] = spec;
            delete childBuilders["fontStyle;"];
            modifiedKeys["fontStyle"] = true;
            return this;
        };
        this.fontSize = (spec) => {
            updates["fontSize"] = spec;
            delete childBuilders["fontSize;"];
            modifiedKeys["fontSize"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
        this.printObject = (spec) => {
            updates["printObject"] = spec;
            delete childBuilders["printObject;"];
            modifiedKeys["printObject"] = true;
            return this;
        };
    }
}
function patchKey(base, builder) { return builder(new KeyBuilder(base)).patch(); }
exports.patchKey = patchKey;
function buildKey(builder) { return builder(new KeyBuilder()).build(); }
exports.buildKey = buildKey;
class TimeBuilder {
    build;
    patch;
    interchangeable;
    beats;
    beatTypes;
    senzaMisura;
    number;
    printObject;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    fontFamily;
    fontWeight;
    fontStyle;
    fontSize;
    color;
    halign;
    valign;
    symbol;
    separator;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["beats"]) ||
                childBuilders["beats"] !== undefined ||
                updates.beats !== undefined, "beats is a required field");
            console.assert((original && !modifiedKeys["beatTypes"]) ||
                childBuilders["beatTypes"] !== undefined ||
                updates.beatTypes !== undefined, "beatTypes is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Time";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.interchangeable = (build) => {
            if (typeof build === 'function') {
                delete updates["interchangeable"];
                const builder = build(new InterchangeableBuilder(original && original["interchangeable"]));
                if (!original)
                    updates["interchangeable"] = builder.build();
                else
                    childBuilders["interchangeable"] = builder;
            }
            else {
                updates.interchangeable = build;
                delete childBuilders["interchangeable;"];
            }
            modifiedKeys["interchangeable"] = true;
            return this;
        };
        this.beats = (spec) => {
            updates["beats"] = spec;
            delete childBuilders["beats;"];
            modifiedKeys["beats"] = true;
            return this;
        };
        this.beatTypes = (spec) => {
            updates["beatTypes"] = spec;
            delete childBuilders["beatTypes;"];
            modifiedKeys["beatTypes"] = true;
            return this;
        };
        this.senzaMisura = (spec) => {
            updates["senzaMisura"] = spec;
            delete childBuilders["senzaMisura;"];
            modifiedKeys["senzaMisura"] = true;
            return this;
        };
        this.number = (spec) => {
            updates["number"] = spec;
            delete childBuilders["number;"];
            modifiedKeys["number"] = true;
            return this;
        };
        this.printObject = (spec) => {
            updates["printObject"] = spec;
            delete childBuilders["printObject;"];
            modifiedKeys["printObject"] = true;
            return this;
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
        this.fontFamily = (spec) => {
            updates["fontFamily"] = spec;
            delete childBuilders["fontFamily;"];
            modifiedKeys["fontFamily"] = true;
            return this;
        };
        this.fontWeight = (spec) => {
            updates["fontWeight"] = spec;
            delete childBuilders["fontWeight;"];
            modifiedKeys["fontWeight"] = true;
            return this;
        };
        this.fontStyle = (spec) => {
            updates["fontStyle"] = spec;
            delete childBuilders["fontStyle;"];
            modifiedKeys["fontStyle"] = true;
            return this;
        };
        this.fontSize = (spec) => {
            updates["fontSize"] = spec;
            delete childBuilders["fontSize;"];
            modifiedKeys["fontSize"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
        this.halign = (spec) => {
            updates["halign"] = spec;
            delete childBuilders["halign;"];
            modifiedKeys["halign"] = true;
            return this;
        };
        this.valign = (spec) => {
            updates["valign"] = spec;
            delete childBuilders["valign;"];
            modifiedKeys["valign"] = true;
            return this;
        };
        this.symbol = (spec) => {
            updates["symbol"] = spec;
            delete childBuilders["symbol;"];
            modifiedKeys["symbol"] = true;
            return this;
        };
        this.separator = (spec) => {
            updates["separator"] = spec;
            delete childBuilders["separator;"];
            modifiedKeys["separator"] = true;
            return this;
        };
    }
}
function patchTime(base, builder) { return builder(new TimeBuilder(base)).patch(); }
exports.patchTime = patchTime;
function buildTime(builder) { return builder(new TimeBuilder()).build(); }
exports.buildTime = buildTime;
class InterchangeableBuilder {
    build;
    patch;
    beats;
    beatTypes;
    timeRelation;
    symbol;
    separator;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["beats"]) ||
                childBuilders["beats"] !== undefined ||
                updates.beats !== undefined, "beats is a required field");
            console.assert((original && !modifiedKeys["beatTypes"]) ||
                childBuilders["beatTypes"] !== undefined ||
                updates.beatTypes !== undefined, "beatTypes is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Interchangeable";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.beats = (spec) => {
            updates["beats"] = spec;
            delete childBuilders["beats;"];
            modifiedKeys["beats"] = true;
            return this;
        };
        this.beatTypes = (spec) => {
            updates["beatTypes"] = spec;
            delete childBuilders["beatTypes;"];
            modifiedKeys["beatTypes"] = true;
            return this;
        };
        this.timeRelation = (spec) => {
            updates["timeRelation"] = spec;
            delete childBuilders["timeRelation;"];
            modifiedKeys["timeRelation"] = true;
            return this;
        };
        this.symbol = (spec) => {
            updates["symbol"] = spec;
            delete childBuilders["symbol;"];
            modifiedKeys["symbol"] = true;
            return this;
        };
        this.separator = (spec) => {
            updates["separator"] = spec;
            delete childBuilders["separator;"];
            modifiedKeys["separator"] = true;
            return this;
        };
    }
}
function patchInterchangeable(base, builder) { return builder(new InterchangeableBuilder(base)).patch(); }
exports.patchInterchangeable = patchInterchangeable;
function buildInterchangeable(builder) { return builder(new InterchangeableBuilder()).build(); }
exports.buildInterchangeable = buildInterchangeable;
class PartSymbolBuilder {
    build;
    patch;
    topStaff;
    type;
    bottomStaff;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    color;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["type"]) ||
                childBuilders["type"] !== undefined ||
                updates.type !== undefined, "type is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "PartSymbol";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.topStaff = (spec) => {
            updates["topStaff"] = spec;
            delete childBuilders["topStaff;"];
            modifiedKeys["topStaff"] = true;
            return this;
        };
        this.type = (spec) => {
            updates["type"] = spec;
            delete childBuilders["type;"];
            modifiedKeys["type"] = true;
            return this;
        };
        this.bottomStaff = (spec) => {
            updates["bottomStaff"] = spec;
            delete childBuilders["bottomStaff;"];
            modifiedKeys["bottomStaff"] = true;
            return this;
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
    }
}
function patchPartSymbol(base, builder) { return builder(new PartSymbolBuilder(base)).patch(); }
exports.patchPartSymbol = patchPartSymbol;
function buildPartSymbol(builder) { return builder(new PartSymbolBuilder()).build(); }
exports.buildPartSymbol = buildPartSymbol;
class ClefBuilder {
    build;
    patch;
    clefOctaveChange;
    sign;
    number;
    size;
    line;
    afterBarline;
    additional;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    fontFamily;
    fontWeight;
    fontStyle;
    fontSize;
    color;
    printObject;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["sign"]) ||
                childBuilders["sign"] !== undefined ||
                updates.sign !== undefined, "sign is a required field");
            console.assert((original && !modifiedKeys["line"]) ||
                childBuilders["line"] !== undefined ||
                updates.line !== undefined, "line is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Clef";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.clefOctaveChange = (spec) => {
            updates["clefOctaveChange"] = spec;
            delete childBuilders["clefOctaveChange;"];
            modifiedKeys["clefOctaveChange"] = true;
            return this;
        };
        this.sign = (spec) => {
            updates["sign"] = spec;
            delete childBuilders["sign;"];
            modifiedKeys["sign"] = true;
            return this;
        };
        this.number = (spec) => {
            updates["number"] = spec;
            delete childBuilders["number;"];
            modifiedKeys["number"] = true;
            return this;
        };
        this.size = (spec) => {
            updates["size"] = spec;
            delete childBuilders["size;"];
            modifiedKeys["size"] = true;
            return this;
        };
        this.line = (spec) => {
            updates["line"] = spec;
            delete childBuilders["line;"];
            modifiedKeys["line"] = true;
            return this;
        };
        this.afterBarline = (spec) => {
            updates["afterBarline"] = spec;
            delete childBuilders["afterBarline;"];
            modifiedKeys["afterBarline"] = true;
            return this;
        };
        this.additional = (spec) => {
            updates["additional"] = spec;
            delete childBuilders["additional;"];
            modifiedKeys["additional"] = true;
            return this;
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
        this.fontFamily = (spec) => {
            updates["fontFamily"] = spec;
            delete childBuilders["fontFamily;"];
            modifiedKeys["fontFamily"] = true;
            return this;
        };
        this.fontWeight = (spec) => {
            updates["fontWeight"] = spec;
            delete childBuilders["fontWeight;"];
            modifiedKeys["fontWeight"] = true;
            return this;
        };
        this.fontStyle = (spec) => {
            updates["fontStyle"] = spec;
            delete childBuilders["fontStyle;"];
            modifiedKeys["fontStyle"] = true;
            return this;
        };
        this.fontSize = (spec) => {
            updates["fontSize"] = spec;
            delete childBuilders["fontSize;"];
            modifiedKeys["fontSize"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
        this.printObject = (spec) => {
            updates["printObject"] = spec;
            delete childBuilders["printObject;"];
            modifiedKeys["printObject"] = true;
            return this;
        };
    }
}
function patchClef(base, builder) { return builder(new ClefBuilder(base)).patch(); }
exports.patchClef = patchClef;
function buildClef(builder) { return builder(new ClefBuilder()).build(); }
exports.buildClef = buildClef;
class StaffTuningBuilder {
    build;
    patch;
    tuningAlter;
    line;
    tuningStep;
    tuningOctave;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["line"]) ||
                childBuilders["line"] !== undefined ||
                updates.line !== undefined, "line is a required field");
            console.assert((original && !modifiedKeys["tuningStep"]) ||
                childBuilders["tuningStep"] !== undefined ||
                updates.tuningStep !== undefined, "tuningStep is a required field");
            console.assert((original && !modifiedKeys["tuningOctave"]) ||
                childBuilders["tuningOctave"] !== undefined ||
                updates.tuningOctave !== undefined, "tuningOctave is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "StaffTuning";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.tuningAlter = (spec) => {
            updates["tuningAlter"] = spec;
            delete childBuilders["tuningAlter;"];
            modifiedKeys["tuningAlter"] = true;
            return this;
        };
        this.line = (spec) => {
            updates["line"] = spec;
            delete childBuilders["line;"];
            modifiedKeys["line"] = true;
            return this;
        };
        this.tuningStep = (spec) => {
            updates["tuningStep"] = spec;
            delete childBuilders["tuningStep;"];
            modifiedKeys["tuningStep"] = true;
            return this;
        };
        this.tuningOctave = (spec) => {
            updates["tuningOctave"] = spec;
            delete childBuilders["tuningOctave;"];
            modifiedKeys["tuningOctave"] = true;
            return this;
        };
    }
}
function patchStaffTuning(base, builder) { return builder(new StaffTuningBuilder(base)).patch(); }
exports.patchStaffTuning = patchStaffTuning;
function buildStaffTuning(builder) { return builder(new StaffTuningBuilder()).build(); }
exports.buildStaffTuning = buildStaffTuning;
class StaffDetailsBuilder {
    build;
    patch;
    staffLines;
    staffTuningsAt;
    staffTuningsSplice;
    staffTunings;
    staffSize;
    showFrets;
    capo;
    number;
    staffType;
    printObject;
    printSpacing;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "StaffDetails";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.staffLines = (spec) => {
            updates["staffLines"] = spec;
            delete childBuilders["staffLines;"];
            modifiedKeys["staffLines"] = true;
            return this;
        };
        this.staffTunings = (spec) => {
            updates["staffTunings"] = spec;
            delete childBuilders["staffTunings;"];
            modifiedKeys["staffTunings"] = true;
            return this;
        };
        this.staffTuningsAt = (idx, build) => {
            makeReference("staffTunings");
            if (frozen["staffTunings"][idx]) {
                throw new Error("Patching staffTunings." + idx + " twice in a builder is unsupported.");
            }
            if (original && original._snapshot && original._snapshot["staffTunings"] && original._snapshot["staffTunings"][idx] && !original["staffTunings"][idx]) {
                // Clone snapshot.
                patches.push({ p: ["staffTunings", idx], li: original._snapshot["staffTunings"] });
            }
            if (typeof build === 'function' && reference["staffTunings"][idx]) {
                let patch = build(new StaffTuningBuilder(reference["staffTunings"][idx])).patch();
                patches = patches.concat(patch.map(patch => {
                    // TODO: detach?
                    patch.p = ["staffTunings", idx].concat(patch.p);
                    return patch;
                }));
                frozen["staffTunings"][idx] = true;
                return this;
            }
            let update = typeof build === 'function' ? build(new StaffTuningBuilder(reference["staffTunings"][idx])).build() : build;
            if (original) {
                patches.push({ p: ["staffTunings", idx], li: update });
            }
            else {
                updates["staffTunings"] = reference["staffTunings"]; // TODO: Merge?
            }
            reference["staffTunings"][idx] = update;
            frozen["staffTunings"][idx] = true;
            return this;
        };
        this.staffTuningsSplice = (start, deleteCount, ...items) => {
            makeReference("staffTunings");
            let idx = start;
            if (original) {
                for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
                    if (frozen["staffTunings"][idx]) {
                        throw new Error("Replacing staffTunings." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["staffTunings"][idx];
                    patches.push({ p: ["staffTunings", idx], ld, li: items[idx - start] });
                    frozen["staffTunings"][idx] = true;
                }
                for (; idx < start + deleteCount; ++idx) {
                    if (frozen["staffTunings"][idx]) {
                        throw new Error("Removing staffTunings." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["staffTunings"][idx];
                    patches.push({ p: ["staffTunings", idx], ld });
                }
                for (; idx < start + items.length; ++idx) {
                    patches.push({ p: ["staffTunings", idx], li: items[idx - start] });
                    frozen["staffTunings"][idx] = true;
                }
            }
            reference["staffTunings"].splice(start, deleteCount, ...items);
            updates["staffTunings"] = reference["staffTunings"];
            frozen["staffTunings"].splice(start, deleteCount, ...items.map(i => true));
            return this;
        };
        this.staffSize = (spec) => {
            updates["staffSize"] = spec;
            delete childBuilders["staffSize;"];
            modifiedKeys["staffSize"] = true;
            return this;
        };
        this.showFrets = (spec) => {
            updates["showFrets"] = spec;
            delete childBuilders["showFrets;"];
            modifiedKeys["showFrets"] = true;
            return this;
        };
        this.capo = (spec) => {
            updates["capo"] = spec;
            delete childBuilders["capo;"];
            modifiedKeys["capo"] = true;
            return this;
        };
        this.number = (spec) => {
            updates["number"] = spec;
            delete childBuilders["number;"];
            modifiedKeys["number"] = true;
            return this;
        };
        this.staffType = (spec) => {
            updates["staffType"] = spec;
            delete childBuilders["staffType;"];
            modifiedKeys["staffType"] = true;
            return this;
        };
        this.printObject = (spec) => {
            updates["printObject"] = spec;
            delete childBuilders["printObject;"];
            modifiedKeys["printObject"] = true;
            return this;
        };
        this.printSpacing = (spec) => {
            updates["printSpacing"] = spec;
            delete childBuilders["printSpacing;"];
            modifiedKeys["printSpacing"] = true;
            return this;
        };
    }
}
function patchStaffDetails(base, builder) { return builder(new StaffDetailsBuilder(base)).patch(); }
exports.patchStaffDetails = patchStaffDetails;
function buildStaffDetails(builder) { return builder(new StaffDetailsBuilder()).build(); }
exports.buildStaffDetails = buildStaffDetails;
class DoubleBuilder {
    build;
    patch;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Double";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
    }
}
function patchDouble(base, builder) { return builder(new DoubleBuilder(base)).patch(); }
exports.patchDouble = patchDouble;
function buildDouble(builder) { return builder(new DoubleBuilder()).build(); }
exports.buildDouble = buildDouble;
class TransposeBuilder {
    build;
    patch;
    number;
    diatonic;
    octaveChange;
    double;
    chromatic;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["chromatic"]) ||
                childBuilders["chromatic"] !== undefined ||
                updates.chromatic !== undefined, "chromatic is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Transpose";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.number = (spec) => {
            updates["number"] = spec;
            delete childBuilders["number;"];
            modifiedKeys["number"] = true;
            return this;
        };
        this.diatonic = (spec) => {
            updates["diatonic"] = spec;
            delete childBuilders["diatonic;"];
            modifiedKeys["diatonic"] = true;
            return this;
        };
        this.octaveChange = (spec) => {
            updates["octaveChange"] = spec;
            delete childBuilders["octaveChange;"];
            modifiedKeys["octaveChange"] = true;
            return this;
        };
        this.double = (build) => {
            if (typeof build === 'function') {
                delete updates["double"];
                const builder = build(new DoubleBuilder(original && original["double"]));
                if (!original)
                    updates["double"] = builder.build();
                else
                    childBuilders["double"] = builder;
            }
            else {
                updates.double = build;
                delete childBuilders["double;"];
            }
            modifiedKeys["double"] = true;
            return this;
        };
        this.chromatic = (spec) => {
            updates["chromatic"] = spec;
            delete childBuilders["chromatic;"];
            modifiedKeys["chromatic"] = true;
            return this;
        };
    }
}
function patchTranspose(base, builder) { return builder(new TransposeBuilder(base)).patch(); }
exports.patchTranspose = patchTranspose;
function buildTranspose(builder) { return builder(new TransposeBuilder()).build(); }
exports.buildTranspose = buildTranspose;
class DirectiveBuilder {
    build;
    patch;
    data;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    fontFamily;
    fontWeight;
    fontStyle;
    fontSize;
    color;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["data"]) ||
                childBuilders["data"] !== undefined ||
                updates.data !== undefined, "data is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Directive";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.data = (spec) => {
            updates["data"] = spec;
            delete childBuilders["data;"];
            modifiedKeys["data"] = true;
            return this;
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
        this.fontFamily = (spec) => {
            updates["fontFamily"] = spec;
            delete childBuilders["fontFamily;"];
            modifiedKeys["fontFamily"] = true;
            return this;
        };
        this.fontWeight = (spec) => {
            updates["fontWeight"] = spec;
            delete childBuilders["fontWeight;"];
            modifiedKeys["fontWeight"] = true;
            return this;
        };
        this.fontStyle = (spec) => {
            updates["fontStyle"] = spec;
            delete childBuilders["fontStyle;"];
            modifiedKeys["fontStyle"] = true;
            return this;
        };
        this.fontSize = (spec) => {
            updates["fontSize"] = spec;
            delete childBuilders["fontSize;"];
            modifiedKeys["fontSize"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
    }
}
function patchDirective(base, builder) { return builder(new DirectiveBuilder(base)).patch(); }
exports.patchDirective = patchDirective;
function buildDirective(builder) { return builder(new DirectiveBuilder()).build(); }
exports.buildDirective = buildDirective;
class SlashDotBuilder {
    build;
    patch;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "SlashDot";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
    }
}
function patchSlashDot(base, builder) { return builder(new SlashDotBuilder(base)).patch(); }
exports.patchSlashDot = patchSlashDot;
function buildSlashDot(builder) { return builder(new SlashDotBuilder()).build(); }
exports.buildSlashDot = buildSlashDot;
class MultipleRestBuilder {
    build;
    patch;
    useSymbols;
    count;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["count"]) ||
                childBuilders["count"] !== undefined ||
                updates.count !== undefined, "count is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "MultipleRest";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.useSymbols = (spec) => {
            updates["useSymbols"] = spec;
            delete childBuilders["useSymbols;"];
            modifiedKeys["useSymbols"] = true;
            return this;
        };
        this.count = (spec) => {
            updates["count"] = spec;
            delete childBuilders["count;"];
            modifiedKeys["count"] = true;
            return this;
        };
    }
}
function patchMultipleRest(base, builder) { return builder(new MultipleRestBuilder(base)).patch(); }
exports.patchMultipleRest = patchMultipleRest;
function buildMultipleRest(builder) { return builder(new MultipleRestBuilder()).build(); }
exports.buildMultipleRest = buildMultipleRest;
class MeasureRepeatBuilder {
    build;
    patch;
    data;
    type;
    slashes;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["type"]) ||
                childBuilders["type"] !== undefined ||
                updates.type !== undefined, "type is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "MeasureRepeat";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.data = (spec) => {
            updates["data"] = spec;
            delete childBuilders["data;"];
            modifiedKeys["data"] = true;
            return this;
        };
        this.type = (spec) => {
            updates["type"] = spec;
            delete childBuilders["type;"];
            modifiedKeys["type"] = true;
            return this;
        };
        this.slashes = (spec) => {
            updates["slashes"] = spec;
            delete childBuilders["slashes;"];
            modifiedKeys["slashes"] = true;
            return this;
        };
    }
}
function patchMeasureRepeat(base, builder) { return builder(new MeasureRepeatBuilder(base)).patch(); }
exports.patchMeasureRepeat = patchMeasureRepeat;
function buildMeasureRepeat(builder) { return builder(new MeasureRepeatBuilder()).build(); }
exports.buildMeasureRepeat = buildMeasureRepeat;
class BeatRepeatBuilder {
    build;
    patch;
    slashType;
    useDots;
    slashDotsAt;
    slashDotsSplice;
    slashDots;
    slases;
    type;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["type"]) ||
                childBuilders["type"] !== undefined ||
                updates.type !== undefined, "type is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "BeatRepeat";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.slashType = (spec) => {
            updates["slashType"] = spec;
            delete childBuilders["slashType;"];
            modifiedKeys["slashType"] = true;
            return this;
        };
        this.useDots = (spec) => {
            updates["useDots"] = spec;
            delete childBuilders["useDots;"];
            modifiedKeys["useDots"] = true;
            return this;
        };
        this.slashDots = (spec) => {
            updates["slashDots"] = spec;
            delete childBuilders["slashDots;"];
            modifiedKeys["slashDots"] = true;
            return this;
        };
        this.slashDotsAt = (idx, build) => {
            makeReference("slashDots");
            if (frozen["slashDots"][idx]) {
                throw new Error("Patching slashDots." + idx + " twice in a builder is unsupported.");
            }
            if (original && original._snapshot && original._snapshot["slashDots"] && original._snapshot["slashDots"][idx] && !original["slashDots"][idx]) {
                // Clone snapshot.
                patches.push({ p: ["slashDots", idx], li: original._snapshot["slashDots"] });
            }
            if (typeof build === 'function' && reference["slashDots"][idx]) {
                let patch = build(new SlashDotBuilder(reference["slashDots"][idx])).patch();
                patches = patches.concat(patch.map(patch => {
                    // TODO: detach?
                    patch.p = ["slashDots", idx].concat(patch.p);
                    return patch;
                }));
                frozen["slashDots"][idx] = true;
                return this;
            }
            let update = typeof build === 'function' ? build(new SlashDotBuilder(reference["slashDots"][idx])).build() : build;
            if (original) {
                patches.push({ p: ["slashDots", idx], li: update });
            }
            else {
                updates["slashDots"] = reference["slashDots"]; // TODO: Merge?
            }
            reference["slashDots"][idx] = update;
            frozen["slashDots"][idx] = true;
            return this;
        };
        this.slashDotsSplice = (start, deleteCount, ...items) => {
            makeReference("slashDots");
            let idx = start;
            if (original) {
                for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
                    if (frozen["slashDots"][idx]) {
                        throw new Error("Replacing slashDots." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["slashDots"][idx];
                    patches.push({ p: ["slashDots", idx], ld, li: items[idx - start] });
                    frozen["slashDots"][idx] = true;
                }
                for (; idx < start + deleteCount; ++idx) {
                    if (frozen["slashDots"][idx]) {
                        throw new Error("Removing slashDots." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["slashDots"][idx];
                    patches.push({ p: ["slashDots", idx], ld });
                }
                for (; idx < start + items.length; ++idx) {
                    patches.push({ p: ["slashDots", idx], li: items[idx - start] });
                    frozen["slashDots"][idx] = true;
                }
            }
            reference["slashDots"].splice(start, deleteCount, ...items);
            updates["slashDots"] = reference["slashDots"];
            frozen["slashDots"].splice(start, deleteCount, ...items.map(i => true));
            return this;
        };
        this.slases = (spec) => {
            updates["slases"] = spec;
            delete childBuilders["slases;"];
            modifiedKeys["slases"] = true;
            return this;
        };
        this.type = (spec) => {
            updates["type"] = spec;
            delete childBuilders["type;"];
            modifiedKeys["type"] = true;
            return this;
        };
    }
}
function patchBeatRepeat(base, builder) { return builder(new BeatRepeatBuilder(base)).patch(); }
exports.patchBeatRepeat = patchBeatRepeat;
function buildBeatRepeat(builder) { return builder(new BeatRepeatBuilder()).build(); }
exports.buildBeatRepeat = buildBeatRepeat;
class SlashBuilder {
    build;
    patch;
    slashType;
    useDots;
    useStems;
    slashDotsAt;
    slashDotsSplice;
    slashDots;
    type;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["type"]) ||
                childBuilders["type"] !== undefined ||
                updates.type !== undefined, "type is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Slash";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.slashType = (spec) => {
            updates["slashType"] = spec;
            delete childBuilders["slashType;"];
            modifiedKeys["slashType"] = true;
            return this;
        };
        this.useDots = (spec) => {
            updates["useDots"] = spec;
            delete childBuilders["useDots;"];
            modifiedKeys["useDots"] = true;
            return this;
        };
        this.useStems = (spec) => {
            updates["useStems"] = spec;
            delete childBuilders["useStems;"];
            modifiedKeys["useStems"] = true;
            return this;
        };
        this.slashDots = (spec) => {
            updates["slashDots"] = spec;
            delete childBuilders["slashDots;"];
            modifiedKeys["slashDots"] = true;
            return this;
        };
        this.slashDotsAt = (idx, build) => {
            makeReference("slashDots");
            if (frozen["slashDots"][idx]) {
                throw new Error("Patching slashDots." + idx + " twice in a builder is unsupported.");
            }
            if (original && original._snapshot && original._snapshot["slashDots"] && original._snapshot["slashDots"][idx] && !original["slashDots"][idx]) {
                // Clone snapshot.
                patches.push({ p: ["slashDots", idx], li: original._snapshot["slashDots"] });
            }
            if (typeof build === 'function' && reference["slashDots"][idx]) {
                let patch = build(new SlashDotBuilder(reference["slashDots"][idx])).patch();
                patches = patches.concat(patch.map(patch => {
                    // TODO: detach?
                    patch.p = ["slashDots", idx].concat(patch.p);
                    return patch;
                }));
                frozen["slashDots"][idx] = true;
                return this;
            }
            let update = typeof build === 'function' ? build(new SlashDotBuilder(reference["slashDots"][idx])).build() : build;
            if (original) {
                patches.push({ p: ["slashDots", idx], li: update });
            }
            else {
                updates["slashDots"] = reference["slashDots"]; // TODO: Merge?
            }
            reference["slashDots"][idx] = update;
            frozen["slashDots"][idx] = true;
            return this;
        };
        this.slashDotsSplice = (start, deleteCount, ...items) => {
            makeReference("slashDots");
            let idx = start;
            if (original) {
                for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
                    if (frozen["slashDots"][idx]) {
                        throw new Error("Replacing slashDots." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["slashDots"][idx];
                    patches.push({ p: ["slashDots", idx], ld, li: items[idx - start] });
                    frozen["slashDots"][idx] = true;
                }
                for (; idx < start + deleteCount; ++idx) {
                    if (frozen["slashDots"][idx]) {
                        throw new Error("Removing slashDots." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["slashDots"][idx];
                    patches.push({ p: ["slashDots", idx], ld });
                }
                for (; idx < start + items.length; ++idx) {
                    patches.push({ p: ["slashDots", idx], li: items[idx - start] });
                    frozen["slashDots"][idx] = true;
                }
            }
            reference["slashDots"].splice(start, deleteCount, ...items);
            updates["slashDots"] = reference["slashDots"];
            frozen["slashDots"].splice(start, deleteCount, ...items.map(i => true));
            return this;
        };
        this.type = (spec) => {
            updates["type"] = spec;
            delete childBuilders["type;"];
            modifiedKeys["type"] = true;
            return this;
        };
    }
}
function patchSlash(base, builder) { return builder(new SlashBuilder(base)).patch(); }
exports.patchSlash = patchSlash;
function buildSlash(builder) { return builder(new SlashBuilder()).build(); }
exports.buildSlash = buildSlash;
class MeasureStyleBuilder {
    build;
    patch;
    measureRepeat;
    beatRepeat;
    multipleRest;
    slash;
    number;
    fontFamily;
    fontWeight;
    fontStyle;
    fontSize;
    color;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "MeasureStyle";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.measureRepeat = (build) => {
            if (typeof build === 'function') {
                delete updates["measureRepeat"];
                const builder = build(new MeasureRepeatBuilder(original && original["measureRepeat"]));
                if (!original)
                    updates["measureRepeat"] = builder.build();
                else
                    childBuilders["measureRepeat"] = builder;
            }
            else {
                updates.measureRepeat = build;
                delete childBuilders["measureRepeat;"];
            }
            modifiedKeys["measureRepeat"] = true;
            return this;
        };
        this.beatRepeat = (build) => {
            if (typeof build === 'function') {
                delete updates["beatRepeat"];
                const builder = build(new BeatRepeatBuilder(original && original["beatRepeat"]));
                if (!original)
                    updates["beatRepeat"] = builder.build();
                else
                    childBuilders["beatRepeat"] = builder;
            }
            else {
                updates.beatRepeat = build;
                delete childBuilders["beatRepeat;"];
            }
            modifiedKeys["beatRepeat"] = true;
            return this;
        };
        this.multipleRest = (build) => {
            if (typeof build === 'function') {
                delete updates["multipleRest"];
                const builder = build(new MultipleRestBuilder(original && original["multipleRest"]));
                if (!original)
                    updates["multipleRest"] = builder.build();
                else
                    childBuilders["multipleRest"] = builder;
            }
            else {
                updates.multipleRest = build;
                delete childBuilders["multipleRest;"];
            }
            modifiedKeys["multipleRest"] = true;
            return this;
        };
        this.slash = (build) => {
            if (typeof build === 'function') {
                delete updates["slash"];
                const builder = build(new SlashBuilder(original && original["slash"]));
                if (!original)
                    updates["slash"] = builder.build();
                else
                    childBuilders["slash"] = builder;
            }
            else {
                updates.slash = build;
                delete childBuilders["slash;"];
            }
            modifiedKeys["slash"] = true;
            return this;
        };
        this.number = (spec) => {
            updates["number"] = spec;
            delete childBuilders["number;"];
            modifiedKeys["number"] = true;
            return this;
        };
        this.fontFamily = (spec) => {
            updates["fontFamily"] = spec;
            delete childBuilders["fontFamily;"];
            modifiedKeys["fontFamily"] = true;
            return this;
        };
        this.fontWeight = (spec) => {
            updates["fontWeight"] = spec;
            delete childBuilders["fontWeight;"];
            modifiedKeys["fontWeight"] = true;
            return this;
        };
        this.fontStyle = (spec) => {
            updates["fontStyle"] = spec;
            delete childBuilders["fontStyle;"];
            modifiedKeys["fontStyle"] = true;
            return this;
        };
        this.fontSize = (spec) => {
            updates["fontSize"] = spec;
            delete childBuilders["fontSize;"];
            modifiedKeys["fontSize"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
    }
}
function patchMeasureStyle(base, builder) { return builder(new MeasureStyleBuilder(base)).patch(); }
exports.patchMeasureStyle = patchMeasureStyle;
function buildMeasureStyle(builder) { return builder(new MeasureStyleBuilder()).build(); }
exports.buildMeasureStyle = buildMeasureStyle;
class AttributesBuilder {
    build;
    patch;
    divisions;
    partSymbol;
    clefsAt;
    clefsSplice;
    clefs;
    measureStylesAt;
    measureStylesSplice;
    measureStyles;
    timesAt;
    timesSplice;
    times;
    staffDetailsAt;
    staffDetailsSplice;
    staffDetails;
    transposesAt;
    transposesSplice;
    transposes;
    staves;
    instruments;
    keySignaturesAt;
    keySignaturesSplice;
    keySignatures;
    directivesAt;
    directivesSplice;
    directives;
    footnote;
    level;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Attributes";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.divisions = (spec) => {
            updates["divisions"] = spec;
            delete childBuilders["divisions;"];
            modifiedKeys["divisions"] = true;
            return this;
        };
        this.partSymbol = (build) => {
            if (typeof build === 'function') {
                delete updates["partSymbol"];
                const builder = build(new PartSymbolBuilder(original && original["partSymbol"]));
                if (!original)
                    updates["partSymbol"] = builder.build();
                else
                    childBuilders["partSymbol"] = builder;
            }
            else {
                updates.partSymbol = build;
                delete childBuilders["partSymbol;"];
            }
            modifiedKeys["partSymbol"] = true;
            return this;
        };
        this.clefs = (spec) => {
            updates["clefs"] = spec;
            delete childBuilders["clefs;"];
            modifiedKeys["clefs"] = true;
            return this;
        };
        this.clefsAt = (idx, build) => {
            makeReference("clefs");
            if (frozen["clefs"][idx]) {
                throw new Error("Patching clefs." + idx + " twice in a builder is unsupported.");
            }
            if (original && original._snapshot && original._snapshot["clefs"] && original._snapshot["clefs"][idx] && !original["clefs"][idx]) {
                // Clone snapshot.
                patches.push({ p: ["clefs", idx], li: original._snapshot["clefs"] });
            }
            if (typeof build === 'function' && reference["clefs"][idx]) {
                let patch = build(new ClefBuilder(reference["clefs"][idx])).patch();
                patches = patches.concat(patch.map(patch => {
                    // TODO: detach?
                    patch.p = ["clefs", idx].concat(patch.p);
                    return patch;
                }));
                frozen["clefs"][idx] = true;
                return this;
            }
            let update = typeof build === 'function' ? build(new ClefBuilder(reference["clefs"][idx])).build() : build;
            if (original) {
                patches.push({ p: ["clefs", idx], li: update });
            }
            else {
                updates["clefs"] = reference["clefs"]; // TODO: Merge?
            }
            reference["clefs"][idx] = update;
            frozen["clefs"][idx] = true;
            return this;
        };
        this.clefsSplice = (start, deleteCount, ...items) => {
            makeReference("clefs");
            let idx = start;
            if (original) {
                for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
                    if (frozen["clefs"][idx]) {
                        throw new Error("Replacing clefs." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["clefs"][idx];
                    patches.push({ p: ["clefs", idx], ld, li: items[idx - start] });
                    frozen["clefs"][idx] = true;
                }
                for (; idx < start + deleteCount; ++idx) {
                    if (frozen["clefs"][idx]) {
                        throw new Error("Removing clefs." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["clefs"][idx];
                    patches.push({ p: ["clefs", idx], ld });
                }
                for (; idx < start + items.length; ++idx) {
                    patches.push({ p: ["clefs", idx], li: items[idx - start] });
                    frozen["clefs"][idx] = true;
                }
            }
            reference["clefs"].splice(start, deleteCount, ...items);
            updates["clefs"] = reference["clefs"];
            frozen["clefs"].splice(start, deleteCount, ...items.map(i => true));
            return this;
        };
        this.measureStyles = (spec) => {
            updates["measureStyles"] = spec;
            delete childBuilders["measureStyles;"];
            modifiedKeys["measureStyles"] = true;
            return this;
        };
        this.measureStylesAt = (idx, build) => {
            makeReference("measureStyles");
            if (frozen["measureStyles"][idx]) {
                throw new Error("Patching measureStyles." + idx + " twice in a builder is unsupported.");
            }
            if (original && original._snapshot && original._snapshot["measureStyles"] && original._snapshot["measureStyles"][idx] && !original["measureStyles"][idx]) {
                // Clone snapshot.
                patches.push({ p: ["measureStyles", idx], li: original._snapshot["measureStyles"] });
            }
            if (typeof build === 'function' && reference["measureStyles"][idx]) {
                let patch = build(new MeasureStyleBuilder(reference["measureStyles"][idx])).patch();
                patches = patches.concat(patch.map(patch => {
                    // TODO: detach?
                    patch.p = ["measureStyles", idx].concat(patch.p);
                    return patch;
                }));
                frozen["measureStyles"][idx] = true;
                return this;
            }
            let update = typeof build === 'function' ? build(new MeasureStyleBuilder(reference["measureStyles"][idx])).build() : build;
            if (original) {
                patches.push({ p: ["measureStyles", idx], li: update });
            }
            else {
                updates["measureStyles"] = reference["measureStyles"]; // TODO: Merge?
            }
            reference["measureStyles"][idx] = update;
            frozen["measureStyles"][idx] = true;
            return this;
        };
        this.measureStylesSplice = (start, deleteCount, ...items) => {
            makeReference("measureStyles");
            let idx = start;
            if (original) {
                for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
                    if (frozen["measureStyles"][idx]) {
                        throw new Error("Replacing measureStyles." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["measureStyles"][idx];
                    patches.push({ p: ["measureStyles", idx], ld, li: items[idx - start] });
                    frozen["measureStyles"][idx] = true;
                }
                for (; idx < start + deleteCount; ++idx) {
                    if (frozen["measureStyles"][idx]) {
                        throw new Error("Removing measureStyles." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["measureStyles"][idx];
                    patches.push({ p: ["measureStyles", idx], ld });
                }
                for (; idx < start + items.length; ++idx) {
                    patches.push({ p: ["measureStyles", idx], li: items[idx - start] });
                    frozen["measureStyles"][idx] = true;
                }
            }
            reference["measureStyles"].splice(start, deleteCount, ...items);
            updates["measureStyles"] = reference["measureStyles"];
            frozen["measureStyles"].splice(start, deleteCount, ...items.map(i => true));
            return this;
        };
        this.times = (spec) => {
            updates["times"] = spec;
            delete childBuilders["times;"];
            modifiedKeys["times"] = true;
            return this;
        };
        this.timesAt = (idx, build) => {
            makeReference("times");
            if (frozen["times"][idx]) {
                throw new Error("Patching times." + idx + " twice in a builder is unsupported.");
            }
            if (original && original._snapshot && original._snapshot["times"] && original._snapshot["times"][idx] && !original["times"][idx]) {
                // Clone snapshot.
                patches.push({ p: ["times", idx], li: original._snapshot["times"] });
            }
            if (typeof build === 'function' && reference["times"][idx]) {
                let patch = build(new TimeBuilder(reference["times"][idx])).patch();
                patches = patches.concat(patch.map(patch => {
                    // TODO: detach?
                    patch.p = ["times", idx].concat(patch.p);
                    return patch;
                }));
                frozen["times"][idx] = true;
                return this;
            }
            let update = typeof build === 'function' ? build(new TimeBuilder(reference["times"][idx])).build() : build;
            if (original) {
                patches.push({ p: ["times", idx], li: update });
            }
            else {
                updates["times"] = reference["times"]; // TODO: Merge?
            }
            reference["times"][idx] = update;
            frozen["times"][idx] = true;
            return this;
        };
        this.timesSplice = (start, deleteCount, ...items) => {
            makeReference("times");
            let idx = start;
            if (original) {
                for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
                    if (frozen["times"][idx]) {
                        throw new Error("Replacing times." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["times"][idx];
                    patches.push({ p: ["times", idx], ld, li: items[idx - start] });
                    frozen["times"][idx] = true;
                }
                for (; idx < start + deleteCount; ++idx) {
                    if (frozen["times"][idx]) {
                        throw new Error("Removing times." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["times"][idx];
                    patches.push({ p: ["times", idx], ld });
                }
                for (; idx < start + items.length; ++idx) {
                    patches.push({ p: ["times", idx], li: items[idx - start] });
                    frozen["times"][idx] = true;
                }
            }
            reference["times"].splice(start, deleteCount, ...items);
            updates["times"] = reference["times"];
            frozen["times"].splice(start, deleteCount, ...items.map(i => true));
            return this;
        };
        this.staffDetails = (spec) => {
            updates["staffDetails"] = spec;
            delete childBuilders["staffDetails;"];
            modifiedKeys["staffDetails"] = true;
            return this;
        };
        this.staffDetailsAt = (idx, build) => {
            makeReference("staffDetails");
            if (frozen["staffDetails"][idx]) {
                throw new Error("Patching staffDetails." + idx + " twice in a builder is unsupported.");
            }
            if (original && original._snapshot && original._snapshot["staffDetails"] && original._snapshot["staffDetails"][idx] && !original["staffDetails"][idx]) {
                // Clone snapshot.
                patches.push({ p: ["staffDetails", idx], li: original._snapshot["staffDetails"] });
            }
            if (typeof build === 'function' && reference["staffDetails"][idx]) {
                let patch = build(new StaffDetailsBuilder(reference["staffDetails"][idx])).patch();
                patches = patches.concat(patch.map(patch => {
                    // TODO: detach?
                    patch.p = ["staffDetails", idx].concat(patch.p);
                    return patch;
                }));
                frozen["staffDetails"][idx] = true;
                return this;
            }
            let update = typeof build === 'function' ? build(new StaffDetailsBuilder(reference["staffDetails"][idx])).build() : build;
            if (original) {
                patches.push({ p: ["staffDetails", idx], li: update });
            }
            else {
                updates["staffDetails"] = reference["staffDetails"]; // TODO: Merge?
            }
            reference["staffDetails"][idx] = update;
            frozen["staffDetails"][idx] = true;
            return this;
        };
        this.staffDetailsSplice = (start, deleteCount, ...items) => {
            makeReference("staffDetails");
            let idx = start;
            if (original) {
                for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
                    if (frozen["staffDetails"][idx]) {
                        throw new Error("Replacing staffDetails." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["staffDetails"][idx];
                    patches.push({ p: ["staffDetails", idx], ld, li: items[idx - start] });
                    frozen["staffDetails"][idx] = true;
                }
                for (; idx < start + deleteCount; ++idx) {
                    if (frozen["staffDetails"][idx]) {
                        throw new Error("Removing staffDetails." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["staffDetails"][idx];
                    patches.push({ p: ["staffDetails", idx], ld });
                }
                for (; idx < start + items.length; ++idx) {
                    patches.push({ p: ["staffDetails", idx], li: items[idx - start] });
                    frozen["staffDetails"][idx] = true;
                }
            }
            reference["staffDetails"].splice(start, deleteCount, ...items);
            updates["staffDetails"] = reference["staffDetails"];
            frozen["staffDetails"].splice(start, deleteCount, ...items.map(i => true));
            return this;
        };
        this.transposes = (spec) => {
            updates["transposes"] = spec;
            delete childBuilders["transposes;"];
            modifiedKeys["transposes"] = true;
            return this;
        };
        this.transposesAt = (idx, build) => {
            makeReference("transposes");
            if (frozen["transposes"][idx]) {
                throw new Error("Patching transposes." + idx + " twice in a builder is unsupported.");
            }
            if (original && original._snapshot && original._snapshot["transposes"] && original._snapshot["transposes"][idx] && !original["transposes"][idx]) {
                // Clone snapshot.
                patches.push({ p: ["transposes", idx], li: original._snapshot["transposes"] });
            }
            if (typeof build === 'function' && reference["transposes"][idx]) {
                let patch = build(new TransposeBuilder(reference["transposes"][idx])).patch();
                patches = patches.concat(patch.map(patch => {
                    // TODO: detach?
                    patch.p = ["transposes", idx].concat(patch.p);
                    return patch;
                }));
                frozen["transposes"][idx] = true;
                return this;
            }
            let update = typeof build === 'function' ? build(new TransposeBuilder(reference["transposes"][idx])).build() : build;
            if (original) {
                patches.push({ p: ["transposes", idx], li: update });
            }
            else {
                updates["transposes"] = reference["transposes"]; // TODO: Merge?
            }
            reference["transposes"][idx] = update;
            frozen["transposes"][idx] = true;
            return this;
        };
        this.transposesSplice = (start, deleteCount, ...items) => {
            makeReference("transposes");
            let idx = start;
            if (original) {
                for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
                    if (frozen["transposes"][idx]) {
                        throw new Error("Replacing transposes." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["transposes"][idx];
                    patches.push({ p: ["transposes", idx], ld, li: items[idx - start] });
                    frozen["transposes"][idx] = true;
                }
                for (; idx < start + deleteCount; ++idx) {
                    if (frozen["transposes"][idx]) {
                        throw new Error("Removing transposes." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["transposes"][idx];
                    patches.push({ p: ["transposes", idx], ld });
                }
                for (; idx < start + items.length; ++idx) {
                    patches.push({ p: ["transposes", idx], li: items[idx - start] });
                    frozen["transposes"][idx] = true;
                }
            }
            reference["transposes"].splice(start, deleteCount, ...items);
            updates["transposes"] = reference["transposes"];
            frozen["transposes"].splice(start, deleteCount, ...items.map(i => true));
            return this;
        };
        this.staves = (spec) => {
            updates["staves"] = spec;
            delete childBuilders["staves;"];
            modifiedKeys["staves"] = true;
            return this;
        };
        this.instruments = (spec) => {
            updates["instruments"] = spec;
            delete childBuilders["instruments;"];
            modifiedKeys["instruments"] = true;
            return this;
        };
        this.keySignatures = (spec) => {
            updates["keySignatures"] = spec;
            delete childBuilders["keySignatures;"];
            modifiedKeys["keySignatures"] = true;
            return this;
        };
        this.keySignaturesAt = (idx, build) => {
            makeReference("keySignatures");
            if (frozen["keySignatures"][idx]) {
                throw new Error("Patching keySignatures." + idx + " twice in a builder is unsupported.");
            }
            if (original && original._snapshot && original._snapshot["keySignatures"] && original._snapshot["keySignatures"][idx] && !original["keySignatures"][idx]) {
                // Clone snapshot.
                patches.push({ p: ["keySignatures", idx], li: original._snapshot["keySignatures"] });
            }
            if (typeof build === 'function' && reference["keySignatures"][idx]) {
                let patch = build(new KeyBuilder(reference["keySignatures"][idx])).patch();
                patches = patches.concat(patch.map(patch => {
                    // TODO: detach?
                    patch.p = ["keySignatures", idx].concat(patch.p);
                    return patch;
                }));
                frozen["keySignatures"][idx] = true;
                return this;
            }
            let update = typeof build === 'function' ? build(new KeyBuilder(reference["keySignatures"][idx])).build() : build;
            if (original) {
                patches.push({ p: ["keySignatures", idx], li: update });
            }
            else {
                updates["keySignatures"] = reference["keySignatures"]; // TODO: Merge?
            }
            reference["keySignatures"][idx] = update;
            frozen["keySignatures"][idx] = true;
            return this;
        };
        this.keySignaturesSplice = (start, deleteCount, ...items) => {
            makeReference("keySignatures");
            let idx = start;
            if (original) {
                for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
                    if (frozen["keySignatures"][idx]) {
                        throw new Error("Replacing keySignatures." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["keySignatures"][idx];
                    patches.push({ p: ["keySignatures", idx], ld, li: items[idx - start] });
                    frozen["keySignatures"][idx] = true;
                }
                for (; idx < start + deleteCount; ++idx) {
                    if (frozen["keySignatures"][idx]) {
                        throw new Error("Removing keySignatures." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["keySignatures"][idx];
                    patches.push({ p: ["keySignatures", idx], ld });
                }
                for (; idx < start + items.length; ++idx) {
                    patches.push({ p: ["keySignatures", idx], li: items[idx - start] });
                    frozen["keySignatures"][idx] = true;
                }
            }
            reference["keySignatures"].splice(start, deleteCount, ...items);
            updates["keySignatures"] = reference["keySignatures"];
            frozen["keySignatures"].splice(start, deleteCount, ...items.map(i => true));
            return this;
        };
        this.directives = (spec) => {
            updates["directives"] = spec;
            delete childBuilders["directives;"];
            modifiedKeys["directives"] = true;
            return this;
        };
        this.directivesAt = (idx, build) => {
            makeReference("directives");
            if (frozen["directives"][idx]) {
                throw new Error("Patching directives." + idx + " twice in a builder is unsupported.");
            }
            if (original && original._snapshot && original._snapshot["directives"] && original._snapshot["directives"][idx] && !original["directives"][idx]) {
                // Clone snapshot.
                patches.push({ p: ["directives", idx], li: original._snapshot["directives"] });
            }
            if (typeof build === 'function' && reference["directives"][idx]) {
                let patch = build(new DirectiveBuilder(reference["directives"][idx])).patch();
                patches = patches.concat(patch.map(patch => {
                    // TODO: detach?
                    patch.p = ["directives", idx].concat(patch.p);
                    return patch;
                }));
                frozen["directives"][idx] = true;
                return this;
            }
            let update = typeof build === 'function' ? build(new DirectiveBuilder(reference["directives"][idx])).build() : build;
            if (original) {
                patches.push({ p: ["directives", idx], li: update });
            }
            else {
                updates["directives"] = reference["directives"]; // TODO: Merge?
            }
            reference["directives"][idx] = update;
            frozen["directives"][idx] = true;
            return this;
        };
        this.directivesSplice = (start, deleteCount, ...items) => {
            makeReference("directives");
            let idx = start;
            if (original) {
                for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
                    if (frozen["directives"][idx]) {
                        throw new Error("Replacing directives." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["directives"][idx];
                    patches.push({ p: ["directives", idx], ld, li: items[idx - start] });
                    frozen["directives"][idx] = true;
                }
                for (; idx < start + deleteCount; ++idx) {
                    if (frozen["directives"][idx]) {
                        throw new Error("Removing directives." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["directives"][idx];
                    patches.push({ p: ["directives", idx], ld });
                }
                for (; idx < start + items.length; ++idx) {
                    patches.push({ p: ["directives", idx], li: items[idx - start] });
                    frozen["directives"][idx] = true;
                }
            }
            reference["directives"].splice(start, deleteCount, ...items);
            updates["directives"] = reference["directives"];
            frozen["directives"].splice(start, deleteCount, ...items.map(i => true));
            return this;
        };
        this.footnote = (build) => {
            if (typeof build === 'function') {
                delete updates["footnote"];
                const builder = build(new FootnoteBuilder(original && original["footnote"]));
                if (!original)
                    updates["footnote"] = builder.build();
                else
                    childBuilders["footnote"] = builder;
            }
            else {
                updates.footnote = build;
                delete childBuilders["footnote;"];
            }
            modifiedKeys["footnote"] = true;
            return this;
        };
        this.level = (build) => {
            if (typeof build === 'function') {
                delete updates["level"];
                const builder = build(new LevelBuilder(original && original["level"]));
                if (!original)
                    updates["level"] = builder.build();
                else
                    childBuilders["level"] = builder;
            }
            else {
                updates.level = build;
                delete childBuilders["level;"];
            }
            modifiedKeys["level"] = true;
            return this;
        };
    }
}
function patchAttributes(base, builder) { return builder(new AttributesBuilder(base)).patch(); }
exports.patchAttributes = patchAttributes;
function buildAttributes(builder) { return builder(new AttributesBuilder()).build(); }
exports.buildAttributes = buildAttributes;
class CueBuilder {
    build;
    patch;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Cue";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
    }
}
function patchCue(base, builder) { return builder(new CueBuilder(base)).patch(); }
exports.patchCue = patchCue;
function buildCue(builder) { return builder(new CueBuilder()).build(); }
exports.buildCue = buildCue;
class GraceBuilder {
    build;
    patch;
    makeTime;
    stealTimePrevious;
    slash;
    stealTimeFollowing;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Grace";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.makeTime = (spec) => {
            updates["makeTime"] = spec;
            delete childBuilders["makeTime;"];
            modifiedKeys["makeTime"] = true;
            return this;
        };
        this.stealTimePrevious = (spec) => {
            updates["stealTimePrevious"] = spec;
            delete childBuilders["stealTimePrevious;"];
            modifiedKeys["stealTimePrevious"] = true;
            return this;
        };
        this.slash = (spec) => {
            updates["slash"] = spec;
            delete childBuilders["slash;"];
            modifiedKeys["slash"] = true;
            return this;
        };
        this.stealTimeFollowing = (spec) => {
            updates["stealTimeFollowing"] = spec;
            delete childBuilders["stealTimeFollowing;"];
            modifiedKeys["stealTimeFollowing"] = true;
            return this;
        };
    }
}
function patchGrace(base, builder) { return builder(new GraceBuilder(base)).patch(); }
exports.patchGrace = patchGrace;
function buildGrace(builder) { return builder(new GraceBuilder()).build(); }
exports.buildGrace = buildGrace;
class ChordBuilder {
    build;
    patch;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Chord";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
    }
}
function patchChord(base, builder) { return builder(new ChordBuilder(base)).patch(); }
exports.patchChord = patchChord;
function buildChord(builder) { return builder(new ChordBuilder()).build(); }
exports.buildChord = buildChord;
class UnpitchedBuilder {
    build;
    patch;
    displayStep;
    displayOctave;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Unpitched";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.displayStep = (spec) => {
            updates["displayStep"] = spec;
            delete childBuilders["displayStep;"];
            modifiedKeys["displayStep"] = true;
            return this;
        };
        this.displayOctave = (spec) => {
            updates["displayOctave"] = spec;
            delete childBuilders["displayOctave;"];
            modifiedKeys["displayOctave"] = true;
            return this;
        };
    }
}
function patchUnpitched(base, builder) { return builder(new UnpitchedBuilder(base)).patch(); }
exports.patchUnpitched = patchUnpitched;
function buildUnpitched(builder) { return builder(new UnpitchedBuilder()).build(); }
exports.buildUnpitched = buildUnpitched;
class PitchBuilder {
    build;
    patch;
    alter;
    step;
    octave;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["octave"]) ||
                childBuilders["octave"] !== undefined ||
                updates.octave !== undefined, "octave is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Pitch";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.alter = (spec) => {
            updates["alter"] = spec;
            delete childBuilders["alter;"];
            modifiedKeys["alter"] = true;
            return this;
        };
        this.step = (spec) => {
            updates["step"] = spec;
            delete childBuilders["step;"];
            modifiedKeys["step"] = true;
            return this;
        };
        this.octave = (spec) => {
            updates["octave"] = spec;
            delete childBuilders["octave;"];
            modifiedKeys["octave"] = true;
            return this;
        };
    }
}
function patchPitch(base, builder) { return builder(new PitchBuilder(base)).patch(); }
exports.patchPitch = patchPitch;
function buildPitch(builder) { return builder(new PitchBuilder()).build(); }
exports.buildPitch = buildPitch;
class FullNoteBuilder {
    build;
    patch;
    unpitched;
    chord;
    pitch;
    rest;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "FullNote";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.unpitched = (build) => {
            if (typeof build === 'function') {
                delete updates["unpitched"];
                const builder = build(new UnpitchedBuilder(original && original["unpitched"]));
                if (!original)
                    updates["unpitched"] = builder.build();
                else
                    childBuilders["unpitched"] = builder;
            }
            else {
                updates.unpitched = build;
                delete childBuilders["unpitched;"];
            }
            modifiedKeys["unpitched"] = true;
            return this;
        };
        this.chord = (build) => {
            if (typeof build === 'function') {
                delete updates["chord"];
                const builder = build(new ChordBuilder(original && original["chord"]));
                if (!original)
                    updates["chord"] = builder.build();
                else
                    childBuilders["chord"] = builder;
            }
            else {
                updates.chord = build;
                delete childBuilders["chord;"];
            }
            modifiedKeys["chord"] = true;
            return this;
        };
        this.pitch = (build) => {
            if (typeof build === 'function') {
                delete updates["pitch"];
                const builder = build(new PitchBuilder(original && original["pitch"]));
                if (!original)
                    updates["pitch"] = builder.build();
                else
                    childBuilders["pitch"] = builder;
            }
            else {
                updates.pitch = build;
                delete childBuilders["pitch;"];
            }
            modifiedKeys["pitch"] = true;
            return this;
        };
        this.rest = (build) => {
            if (typeof build === 'function') {
                delete updates["rest"];
                const builder = build(new RestBuilder(original && original["rest"]));
                if (!original)
                    updates["rest"] = builder.build();
                else
                    childBuilders["rest"] = builder;
            }
            else {
                updates.rest = build;
                delete childBuilders["rest;"];
            }
            modifiedKeys["rest"] = true;
            return this;
        };
    }
}
function patchFullNote(base, builder) { return builder(new FullNoteBuilder(base)).patch(); }
exports.patchFullNote = patchFullNote;
function buildFullNote(builder) { return builder(new FullNoteBuilder()).build(); }
exports.buildFullNote = buildFullNote;
class RestBuilder {
    build;
    patch;
    measure;
    displayStep;
    displayOctave;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Rest";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.measure = (spec) => {
            updates["measure"] = spec;
            delete childBuilders["measure;"];
            modifiedKeys["measure"] = true;
            return this;
        };
        this.displayStep = (spec) => {
            updates["displayStep"] = spec;
            delete childBuilders["displayStep;"];
            modifiedKeys["displayStep"] = true;
            return this;
        };
        this.displayOctave = (spec) => {
            updates["displayOctave"] = spec;
            delete childBuilders["displayOctave;"];
            modifiedKeys["displayOctave"] = true;
            return this;
        };
    }
}
function patchRest(base, builder) { return builder(new RestBuilder(base)).patch(); }
exports.patchRest = patchRest;
function buildRest(builder) { return builder(new RestBuilder()).build(); }
exports.buildRest = buildRest;
class TieBuilder {
    build;
    patch;
    type;
    timeOnly;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Tie";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.type = (spec) => {
            updates["type"] = spec;
            delete childBuilders["type;"];
            modifiedKeys["type"] = true;
            return this;
        };
        this.timeOnly = (spec) => {
            updates["timeOnly"] = spec;
            delete childBuilders["timeOnly;"];
            modifiedKeys["timeOnly"] = true;
            return this;
        };
    }
}
function patchTie(base, builder) { return builder(new TieBuilder(base)).patch(); }
exports.patchTie = patchTie;
function buildTie(builder) { return builder(new TieBuilder()).build(); }
exports.buildTie = buildTie;
class InstrumentBuilder {
    build;
    patch;
    id;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["id"]) ||
                childBuilders["id"] !== undefined ||
                updates.id !== undefined, "id is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Instrument";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.id = (spec) => {
            updates["id"] = spec;
            delete childBuilders["id;"];
            modifiedKeys["id"] = true;
            return this;
        };
    }
}
function patchInstrument(base, builder) { return builder(new InstrumentBuilder(base)).patch(); }
exports.patchInstrument = patchInstrument;
function buildInstrument(builder) { return builder(new InstrumentBuilder()).build(); }
exports.buildInstrument = buildInstrument;
class NoteBuilder {
    build;
    patch;
    noteheadText;
    timeModification;
    accidental;
    instrument;
    attack;
    endDynamics;
    lyricsAt;
    lyricsSplice;
    lyrics;
    dotsAt;
    dotsSplice;
    dots;
    notationsAt;
    notationsSplice;
    notations;
    stem;
    noteType;
    pizzicato;
    cue;
    duration;
    tiesAt;
    tiesSplice;
    ties;
    dynamics;
    play;
    staff;
    grace;
    notehead;
    release;
    beamsAt;
    beamsSplice;
    beams;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    fontFamily;
    fontWeight;
    fontStyle;
    fontSize;
    color;
    timeOnly;
    voice;
    footnote;
    level;
    printDot;
    printLyric;
    printObject;
    printSpacing;
    unpitched;
    chord;
    pitch;
    rest;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Note";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.noteheadText = (build) => {
            if (typeof build === 'function') {
                delete updates["noteheadText"];
                const builder = build(new NoteheadTextBuilder(original && original["noteheadText"]));
                if (!original)
                    updates["noteheadText"] = builder.build();
                else
                    childBuilders["noteheadText"] = builder;
            }
            else {
                updates.noteheadText = build;
                delete childBuilders["noteheadText;"];
            }
            modifiedKeys["noteheadText"] = true;
            return this;
        };
        this.timeModification = (build) => {
            if (typeof build === 'function') {
                delete updates["timeModification"];
                const builder = build(new TimeModificationBuilder(original && original["timeModification"]));
                if (!original)
                    updates["timeModification"] = builder.build();
                else
                    childBuilders["timeModification"] = builder;
            }
            else {
                updates.timeModification = build;
                delete childBuilders["timeModification;"];
            }
            modifiedKeys["timeModification"] = true;
            return this;
        };
        this.accidental = (build) => {
            if (typeof build === 'function') {
                delete updates["accidental"];
                const builder = build(new AccidentalBuilder(original && original["accidental"]));
                if (!original)
                    updates["accidental"] = builder.build();
                else
                    childBuilders["accidental"] = builder;
            }
            else {
                updates.accidental = build;
                delete childBuilders["accidental;"];
            }
            modifiedKeys["accidental"] = true;
            return this;
        };
        this.instrument = (build) => {
            if (typeof build === 'function') {
                delete updates["instrument"];
                const builder = build(new InstrumentBuilder(original && original["instrument"]));
                if (!original)
                    updates["instrument"] = builder.build();
                else
                    childBuilders["instrument"] = builder;
            }
            else {
                updates.instrument = build;
                delete childBuilders["instrument;"];
            }
            modifiedKeys["instrument"] = true;
            return this;
        };
        this.attack = (spec) => {
            updates["attack"] = spec;
            delete childBuilders["attack;"];
            modifiedKeys["attack"] = true;
            return this;
        };
        this.endDynamics = (spec) => {
            updates["endDynamics"] = spec;
            delete childBuilders["endDynamics;"];
            modifiedKeys["endDynamics"] = true;
            return this;
        };
        this.lyrics = (spec) => {
            updates["lyrics"] = spec;
            delete childBuilders["lyrics;"];
            modifiedKeys["lyrics"] = true;
            return this;
        };
        this.lyricsAt = (idx, build) => {
            makeReference("lyrics");
            if (frozen["lyrics"][idx]) {
                throw new Error("Patching lyrics." + idx + " twice in a builder is unsupported.");
            }
            if (original && original._snapshot && original._snapshot["lyrics"] && original._snapshot["lyrics"][idx] && !original["lyrics"][idx]) {
                // Clone snapshot.
                patches.push({ p: ["lyrics", idx], li: original._snapshot["lyrics"] });
            }
            if (typeof build === 'function' && reference["lyrics"][idx]) {
                let patch = build(new LyricBuilder(reference["lyrics"][idx])).patch();
                patches = patches.concat(patch.map(patch => {
                    // TODO: detach?
                    patch.p = ["lyrics", idx].concat(patch.p);
                    return patch;
                }));
                frozen["lyrics"][idx] = true;
                return this;
            }
            let update = typeof build === 'function' ? build(new LyricBuilder(reference["lyrics"][idx])).build() : build;
            if (original) {
                patches.push({ p: ["lyrics", idx], li: update });
            }
            else {
                updates["lyrics"] = reference["lyrics"]; // TODO: Merge?
            }
            reference["lyrics"][idx] = update;
            frozen["lyrics"][idx] = true;
            return this;
        };
        this.lyricsSplice = (start, deleteCount, ...items) => {
            makeReference("lyrics");
            let idx = start;
            if (original) {
                for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
                    if (frozen["lyrics"][idx]) {
                        throw new Error("Replacing lyrics." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["lyrics"][idx];
                    patches.push({ p: ["lyrics", idx], ld, li: items[idx - start] });
                    frozen["lyrics"][idx] = true;
                }
                for (; idx < start + deleteCount; ++idx) {
                    if (frozen["lyrics"][idx]) {
                        throw new Error("Removing lyrics." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["lyrics"][idx];
                    patches.push({ p: ["lyrics", idx], ld });
                }
                for (; idx < start + items.length; ++idx) {
                    patches.push({ p: ["lyrics", idx], li: items[idx - start] });
                    frozen["lyrics"][idx] = true;
                }
            }
            reference["lyrics"].splice(start, deleteCount, ...items);
            updates["lyrics"] = reference["lyrics"];
            frozen["lyrics"].splice(start, deleteCount, ...items.map(i => true));
            return this;
        };
        this.dots = (spec) => {
            updates["dots"] = spec;
            delete childBuilders["dots;"];
            modifiedKeys["dots"] = true;
            return this;
        };
        this.dotsAt = (idx, build) => {
            makeReference("dots");
            if (frozen["dots"][idx]) {
                throw new Error("Patching dots." + idx + " twice in a builder is unsupported.");
            }
            if (original && original._snapshot && original._snapshot["dots"] && original._snapshot["dots"][idx] && !original["dots"][idx]) {
                // Clone snapshot.
                patches.push({ p: ["dots", idx], li: original._snapshot["dots"] });
            }
            if (typeof build === 'function' && reference["dots"][idx]) {
                let patch = build(new DotBuilder(reference["dots"][idx])).patch();
                patches = patches.concat(patch.map(patch => {
                    // TODO: detach?
                    patch.p = ["dots", idx].concat(patch.p);
                    return patch;
                }));
                frozen["dots"][idx] = true;
                return this;
            }
            let update = typeof build === 'function' ? build(new DotBuilder(reference["dots"][idx])).build() : build;
            if (original) {
                patches.push({ p: ["dots", idx], li: update });
            }
            else {
                updates["dots"] = reference["dots"]; // TODO: Merge?
            }
            reference["dots"][idx] = update;
            frozen["dots"][idx] = true;
            return this;
        };
        this.dotsSplice = (start, deleteCount, ...items) => {
            makeReference("dots");
            let idx = start;
            if (original) {
                for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
                    if (frozen["dots"][idx]) {
                        throw new Error("Replacing dots." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["dots"][idx];
                    patches.push({ p: ["dots", idx], ld, li: items[idx - start] });
                    frozen["dots"][idx] = true;
                }
                for (; idx < start + deleteCount; ++idx) {
                    if (frozen["dots"][idx]) {
                        throw new Error("Removing dots." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["dots"][idx];
                    patches.push({ p: ["dots", idx], ld });
                }
                for (; idx < start + items.length; ++idx) {
                    patches.push({ p: ["dots", idx], li: items[idx - start] });
                    frozen["dots"][idx] = true;
                }
            }
            reference["dots"].splice(start, deleteCount, ...items);
            updates["dots"] = reference["dots"];
            frozen["dots"].splice(start, deleteCount, ...items.map(i => true));
            return this;
        };
        this.notations = (spec) => {
            updates["notations"] = spec;
            delete childBuilders["notations;"];
            modifiedKeys["notations"] = true;
            return this;
        };
        this.notationsAt = (idx, build) => {
            makeReference("notations");
            if (frozen["notations"][idx]) {
                throw new Error("Patching notations." + idx + " twice in a builder is unsupported.");
            }
            if (original && original._snapshot && original._snapshot["notations"] && original._snapshot["notations"][idx] && !original["notations"][idx]) {
                // Clone snapshot.
                patches.push({ p: ["notations", idx], li: original._snapshot["notations"] });
            }
            if (typeof build === 'function' && reference["notations"][idx]) {
                let patch = build(new NotationsBuilder(reference["notations"][idx])).patch();
                patches = patches.concat(patch.map(patch => {
                    // TODO: detach?
                    patch.p = ["notations", idx].concat(patch.p);
                    return patch;
                }));
                frozen["notations"][idx] = true;
                return this;
            }
            let update = typeof build === 'function' ? build(new NotationsBuilder(reference["notations"][idx])).build() : build;
            if (original) {
                patches.push({ p: ["notations", idx], li: update });
            }
            else {
                updates["notations"] = reference["notations"]; // TODO: Merge?
            }
            reference["notations"][idx] = update;
            frozen["notations"][idx] = true;
            return this;
        };
        this.notationsSplice = (start, deleteCount, ...items) => {
            makeReference("notations");
            let idx = start;
            if (original) {
                for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
                    if (frozen["notations"][idx]) {
                        throw new Error("Replacing notations." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["notations"][idx];
                    patches.push({ p: ["notations", idx], ld, li: items[idx - start] });
                    frozen["notations"][idx] = true;
                }
                for (; idx < start + deleteCount; ++idx) {
                    if (frozen["notations"][idx]) {
                        throw new Error("Removing notations." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["notations"][idx];
                    patches.push({ p: ["notations", idx], ld });
                }
                for (; idx < start + items.length; ++idx) {
                    patches.push({ p: ["notations", idx], li: items[idx - start] });
                    frozen["notations"][idx] = true;
                }
            }
            reference["notations"].splice(start, deleteCount, ...items);
            updates["notations"] = reference["notations"];
            frozen["notations"].splice(start, deleteCount, ...items.map(i => true));
            return this;
        };
        this.stem = (build) => {
            if (typeof build === 'function') {
                delete updates["stem"];
                const builder = build(new StemBuilder(original && original["stem"]));
                if (!original)
                    updates["stem"] = builder.build();
                else
                    childBuilders["stem"] = builder;
            }
            else {
                updates.stem = build;
                delete childBuilders["stem;"];
            }
            modifiedKeys["stem"] = true;
            return this;
        };
        this.noteType = (build) => {
            if (typeof build === 'function') {
                delete updates["noteType"];
                const builder = build(new TypeBuilder(original && original["noteType"]));
                if (!original)
                    updates["noteType"] = builder.build();
                else
                    childBuilders["noteType"] = builder;
            }
            else {
                updates.noteType = build;
                delete childBuilders["noteType;"];
            }
            modifiedKeys["noteType"] = true;
            return this;
        };
        this.pizzicato = (spec) => {
            updates["pizzicato"] = spec;
            delete childBuilders["pizzicato;"];
            modifiedKeys["pizzicato"] = true;
            return this;
        };
        this.cue = (build) => {
            if (typeof build === 'function') {
                delete updates["cue"];
                const builder = build(new CueBuilder(original && original["cue"]));
                if (!original)
                    updates["cue"] = builder.build();
                else
                    childBuilders["cue"] = builder;
            }
            else {
                updates.cue = build;
                delete childBuilders["cue;"];
            }
            modifiedKeys["cue"] = true;
            return this;
        };
        this.duration = (spec) => {
            updates["duration"] = spec;
            delete childBuilders["duration;"];
            modifiedKeys["duration"] = true;
            return this;
        };
        this.ties = (spec) => {
            updates["ties"] = spec;
            delete childBuilders["ties;"];
            modifiedKeys["ties"] = true;
            return this;
        };
        this.tiesAt = (idx, build) => {
            makeReference("ties");
            if (frozen["ties"][idx]) {
                throw new Error("Patching ties." + idx + " twice in a builder is unsupported.");
            }
            if (original && original._snapshot && original._snapshot["ties"] && original._snapshot["ties"][idx] && !original["ties"][idx]) {
                // Clone snapshot.
                patches.push({ p: ["ties", idx], li: original._snapshot["ties"] });
            }
            if (typeof build === 'function' && reference["ties"][idx]) {
                let patch = build(new TieBuilder(reference["ties"][idx])).patch();
                patches = patches.concat(patch.map(patch => {
                    // TODO: detach?
                    patch.p = ["ties", idx].concat(patch.p);
                    return patch;
                }));
                frozen["ties"][idx] = true;
                return this;
            }
            let update = typeof build === 'function' ? build(new TieBuilder(reference["ties"][idx])).build() : build;
            if (original) {
                patches.push({ p: ["ties", idx], li: update });
            }
            else {
                updates["ties"] = reference["ties"]; // TODO: Merge?
            }
            reference["ties"][idx] = update;
            frozen["ties"][idx] = true;
            return this;
        };
        this.tiesSplice = (start, deleteCount, ...items) => {
            makeReference("ties");
            let idx = start;
            if (original) {
                for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
                    if (frozen["ties"][idx]) {
                        throw new Error("Replacing ties." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["ties"][idx];
                    patches.push({ p: ["ties", idx], ld, li: items[idx - start] });
                    frozen["ties"][idx] = true;
                }
                for (; idx < start + deleteCount; ++idx) {
                    if (frozen["ties"][idx]) {
                        throw new Error("Removing ties." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["ties"][idx];
                    patches.push({ p: ["ties", idx], ld });
                }
                for (; idx < start + items.length; ++idx) {
                    patches.push({ p: ["ties", idx], li: items[idx - start] });
                    frozen["ties"][idx] = true;
                }
            }
            reference["ties"].splice(start, deleteCount, ...items);
            updates["ties"] = reference["ties"];
            frozen["ties"].splice(start, deleteCount, ...items.map(i => true));
            return this;
        };
        this.dynamics = (spec) => {
            updates["dynamics"] = spec;
            delete childBuilders["dynamics;"];
            modifiedKeys["dynamics"] = true;
            return this;
        };
        this.play = (build) => {
            if (typeof build === 'function') {
                delete updates["play"];
                const builder = build(new PlayBuilder(original && original["play"]));
                if (!original)
                    updates["play"] = builder.build();
                else
                    childBuilders["play"] = builder;
            }
            else {
                updates.play = build;
                delete childBuilders["play;"];
            }
            modifiedKeys["play"] = true;
            return this;
        };
        this.staff = (spec) => {
            updates["staff"] = spec;
            delete childBuilders["staff;"];
            modifiedKeys["staff"] = true;
            return this;
        };
        this.grace = (build) => {
            if (typeof build === 'function') {
                delete updates["grace"];
                const builder = build(new GraceBuilder(original && original["grace"]));
                if (!original)
                    updates["grace"] = builder.build();
                else
                    childBuilders["grace"] = builder;
            }
            else {
                updates.grace = build;
                delete childBuilders["grace;"];
            }
            modifiedKeys["grace"] = true;
            return this;
        };
        this.notehead = (build) => {
            if (typeof build === 'function') {
                delete updates["notehead"];
                const builder = build(new NoteheadBuilder(original && original["notehead"]));
                if (!original)
                    updates["notehead"] = builder.build();
                else
                    childBuilders["notehead"] = builder;
            }
            else {
                updates.notehead = build;
                delete childBuilders["notehead;"];
            }
            modifiedKeys["notehead"] = true;
            return this;
        };
        this.release = (spec) => {
            updates["release"] = spec;
            delete childBuilders["release;"];
            modifiedKeys["release"] = true;
            return this;
        };
        this.beams = (spec) => {
            updates["beams"] = spec;
            delete childBuilders["beams;"];
            modifiedKeys["beams"] = true;
            return this;
        };
        this.beamsAt = (idx, build) => {
            makeReference("beams");
            if (frozen["beams"][idx]) {
                throw new Error("Patching beams." + idx + " twice in a builder is unsupported.");
            }
            if (original && original._snapshot && original._snapshot["beams"] && original._snapshot["beams"][idx] && !original["beams"][idx]) {
                // Clone snapshot.
                patches.push({ p: ["beams", idx], li: original._snapshot["beams"] });
            }
            if (typeof build === 'function' && reference["beams"][idx]) {
                let patch = build(new BeamBuilder(reference["beams"][idx])).patch();
                patches = patches.concat(patch.map(patch => {
                    // TODO: detach?
                    patch.p = ["beams", idx].concat(patch.p);
                    return patch;
                }));
                frozen["beams"][idx] = true;
                return this;
            }
            let update = typeof build === 'function' ? build(new BeamBuilder(reference["beams"][idx])).build() : build;
            if (original) {
                patches.push({ p: ["beams", idx], li: update });
            }
            else {
                updates["beams"] = reference["beams"]; // TODO: Merge?
            }
            reference["beams"][idx] = update;
            frozen["beams"][idx] = true;
            return this;
        };
        this.beamsSplice = (start, deleteCount, ...items) => {
            makeReference("beams");
            let idx = start;
            if (original) {
                for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
                    if (frozen["beams"][idx]) {
                        throw new Error("Replacing beams." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["beams"][idx];
                    patches.push({ p: ["beams", idx], ld, li: items[idx - start] });
                    frozen["beams"][idx] = true;
                }
                for (; idx < start + deleteCount; ++idx) {
                    if (frozen["beams"][idx]) {
                        throw new Error("Removing beams." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["beams"][idx];
                    patches.push({ p: ["beams", idx], ld });
                }
                for (; idx < start + items.length; ++idx) {
                    patches.push({ p: ["beams", idx], li: items[idx - start] });
                    frozen["beams"][idx] = true;
                }
            }
            reference["beams"].splice(start, deleteCount, ...items);
            updates["beams"] = reference["beams"];
            frozen["beams"].splice(start, deleteCount, ...items.map(i => true));
            return this;
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
        this.fontFamily = (spec) => {
            updates["fontFamily"] = spec;
            delete childBuilders["fontFamily;"];
            modifiedKeys["fontFamily"] = true;
            return this;
        };
        this.fontWeight = (spec) => {
            updates["fontWeight"] = spec;
            delete childBuilders["fontWeight;"];
            modifiedKeys["fontWeight"] = true;
            return this;
        };
        this.fontStyle = (spec) => {
            updates["fontStyle"] = spec;
            delete childBuilders["fontStyle;"];
            modifiedKeys["fontStyle"] = true;
            return this;
        };
        this.fontSize = (spec) => {
            updates["fontSize"] = spec;
            delete childBuilders["fontSize;"];
            modifiedKeys["fontSize"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
        this.timeOnly = (spec) => {
            updates["timeOnly"] = spec;
            delete childBuilders["timeOnly;"];
            modifiedKeys["timeOnly"] = true;
            return this;
        };
        this.voice = (spec) => {
            updates["voice"] = spec;
            delete childBuilders["voice;"];
            modifiedKeys["voice"] = true;
            return this;
        };
        this.footnote = (build) => {
            if (typeof build === 'function') {
                delete updates["footnote"];
                const builder = build(new FootnoteBuilder(original && original["footnote"]));
                if (!original)
                    updates["footnote"] = builder.build();
                else
                    childBuilders["footnote"] = builder;
            }
            else {
                updates.footnote = build;
                delete childBuilders["footnote;"];
            }
            modifiedKeys["footnote"] = true;
            return this;
        };
        this.level = (build) => {
            if (typeof build === 'function') {
                delete updates["level"];
                const builder = build(new LevelBuilder(original && original["level"]));
                if (!original)
                    updates["level"] = builder.build();
                else
                    childBuilders["level"] = builder;
            }
            else {
                updates.level = build;
                delete childBuilders["level;"];
            }
            modifiedKeys["level"] = true;
            return this;
        };
        this.printDot = (spec) => {
            updates["printDot"] = spec;
            delete childBuilders["printDot;"];
            modifiedKeys["printDot"] = true;
            return this;
        };
        this.printLyric = (spec) => {
            updates["printLyric"] = spec;
            delete childBuilders["printLyric;"];
            modifiedKeys["printLyric"] = true;
            return this;
        };
        this.printObject = (spec) => {
            updates["printObject"] = spec;
            delete childBuilders["printObject;"];
            modifiedKeys["printObject"] = true;
            return this;
        };
        this.printSpacing = (spec) => {
            updates["printSpacing"] = spec;
            delete childBuilders["printSpacing;"];
            modifiedKeys["printSpacing"] = true;
            return this;
        };
        this.unpitched = (build) => {
            if (typeof build === 'function') {
                delete updates["unpitched"];
                const builder = build(new UnpitchedBuilder(original && original["unpitched"]));
                if (!original)
                    updates["unpitched"] = builder.build();
                else
                    childBuilders["unpitched"] = builder;
            }
            else {
                updates.unpitched = build;
                delete childBuilders["unpitched;"];
            }
            modifiedKeys["unpitched"] = true;
            return this;
        };
        this.chord = (build) => {
            if (typeof build === 'function') {
                delete updates["chord"];
                const builder = build(new ChordBuilder(original && original["chord"]));
                if (!original)
                    updates["chord"] = builder.build();
                else
                    childBuilders["chord"] = builder;
            }
            else {
                updates.chord = build;
                delete childBuilders["chord;"];
            }
            modifiedKeys["chord"] = true;
            return this;
        };
        this.pitch = (build) => {
            if (typeof build === 'function') {
                delete updates["pitch"];
                const builder = build(new PitchBuilder(original && original["pitch"]));
                if (!original)
                    updates["pitch"] = builder.build();
                else
                    childBuilders["pitch"] = builder;
            }
            else {
                updates.pitch = build;
                delete childBuilders["pitch;"];
            }
            modifiedKeys["pitch"] = true;
            return this;
        };
        this.rest = (build) => {
            if (typeof build === 'function') {
                delete updates["rest"];
                const builder = build(new RestBuilder(original && original["rest"]));
                if (!original)
                    updates["rest"] = builder.build();
                else
                    childBuilders["rest"] = builder;
            }
            else {
                updates.rest = build;
                delete childBuilders["rest;"];
            }
            modifiedKeys["rest"] = true;
            return this;
        };
    }
}
function patchNote(base, builder) { return builder(new NoteBuilder(base)).patch(); }
exports.patchNote = patchNote;
function buildNote(builder) { return builder(new NoteBuilder()).build(); }
exports.buildNote = buildNote;
class TypeBuilder {
    build;
    patch;
    duration;
    size;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["duration"]) ||
                childBuilders["duration"] !== undefined ||
                updates.duration !== undefined, "duration is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Type";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.duration = (spec) => {
            updates["duration"] = spec;
            delete childBuilders["duration;"];
            modifiedKeys["duration"] = true;
            return this;
        };
        this.size = (spec) => {
            updates["size"] = spec;
            delete childBuilders["size;"];
            modifiedKeys["size"] = true;
            return this;
        };
    }
}
function patchType(base, builder) { return builder(new TypeBuilder(base)).patch(); }
exports.patchType = patchType;
function buildType(builder) { return builder(new TypeBuilder()).build(); }
exports.buildType = buildType;
class DotBuilder {
    build;
    patch;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    fontFamily;
    fontWeight;
    fontStyle;
    fontSize;
    color;
    placement;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Dot";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
        this.fontFamily = (spec) => {
            updates["fontFamily"] = spec;
            delete childBuilders["fontFamily;"];
            modifiedKeys["fontFamily"] = true;
            return this;
        };
        this.fontWeight = (spec) => {
            updates["fontWeight"] = spec;
            delete childBuilders["fontWeight;"];
            modifiedKeys["fontWeight"] = true;
            return this;
        };
        this.fontStyle = (spec) => {
            updates["fontStyle"] = spec;
            delete childBuilders["fontStyle;"];
            modifiedKeys["fontStyle"] = true;
            return this;
        };
        this.fontSize = (spec) => {
            updates["fontSize"] = spec;
            delete childBuilders["fontSize;"];
            modifiedKeys["fontSize"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
        this.placement = (spec) => {
            updates["placement"] = spec;
            delete childBuilders["placement;"];
            modifiedKeys["placement"] = true;
            return this;
        };
    }
}
function patchDot(base, builder) { return builder(new DotBuilder(base)).patch(); }
exports.patchDot = patchDot;
function buildDot(builder) { return builder(new DotBuilder()).build(); }
exports.buildDot = buildDot;
class AccidentalBuilder {
    build;
    patch;
    cautionary;
    accidental;
    editorial;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    fontFamily;
    fontWeight;
    fontStyle;
    fontSize;
    color;
    bracket;
    size;
    parentheses;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["accidental"]) ||
                childBuilders["accidental"] !== undefined ||
                updates.accidental !== undefined, "accidental is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Accidental";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.cautionary = (spec) => {
            updates["cautionary"] = spec;
            delete childBuilders["cautionary;"];
            modifiedKeys["cautionary"] = true;
            return this;
        };
        this.accidental = (spec) => {
            updates["accidental"] = spec;
            delete childBuilders["accidental;"];
            modifiedKeys["accidental"] = true;
            return this;
        };
        this.editorial = (spec) => {
            updates["editorial"] = spec;
            delete childBuilders["editorial;"];
            modifiedKeys["editorial"] = true;
            return this;
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
        this.fontFamily = (spec) => {
            updates["fontFamily"] = spec;
            delete childBuilders["fontFamily;"];
            modifiedKeys["fontFamily"] = true;
            return this;
        };
        this.fontWeight = (spec) => {
            updates["fontWeight"] = spec;
            delete childBuilders["fontWeight;"];
            modifiedKeys["fontWeight"] = true;
            return this;
        };
        this.fontStyle = (spec) => {
            updates["fontStyle"] = spec;
            delete childBuilders["fontStyle;"];
            modifiedKeys["fontStyle"] = true;
            return this;
        };
        this.fontSize = (spec) => {
            updates["fontSize"] = spec;
            delete childBuilders["fontSize;"];
            modifiedKeys["fontSize"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
        this.bracket = (spec) => {
            updates["bracket"] = spec;
            delete childBuilders["bracket;"];
            modifiedKeys["bracket"] = true;
            return this;
        };
        this.size = (spec) => {
            updates["size"] = spec;
            delete childBuilders["size;"];
            modifiedKeys["size"] = true;
            return this;
        };
        this.parentheses = (spec) => {
            updates["parentheses"] = spec;
            delete childBuilders["parentheses;"];
            modifiedKeys["parentheses"] = true;
            return this;
        };
    }
}
function patchAccidental(base, builder) { return builder(new AccidentalBuilder(base)).patch(); }
exports.patchAccidental = patchAccidental;
function buildAccidental(builder) { return builder(new AccidentalBuilder()).build(); }
exports.buildAccidental = buildAccidental;
class TimeModificationBuilder {
    build;
    patch;
    actualNotes;
    normalType;
    normalNotes;
    normalDotsAt;
    normalDotsSplice;
    normalDots;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["actualNotes"]) ||
                childBuilders["actualNotes"] !== undefined ||
                updates.actualNotes !== undefined, "actualNotes is a required field");
            console.assert((original && !modifiedKeys["normalNotes"]) ||
                childBuilders["normalNotes"] !== undefined ||
                updates.normalNotes !== undefined, "normalNotes is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "TimeModification";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.actualNotes = (spec) => {
            updates["actualNotes"] = spec;
            delete childBuilders["actualNotes;"];
            modifiedKeys["actualNotes"] = true;
            return this;
        };
        this.normalType = (spec) => {
            updates["normalType"] = spec;
            delete childBuilders["normalType;"];
            modifiedKeys["normalType"] = true;
            return this;
        };
        this.normalNotes = (spec) => {
            updates["normalNotes"] = spec;
            delete childBuilders["normalNotes;"];
            modifiedKeys["normalNotes"] = true;
            return this;
        };
        this.normalDots = (spec) => {
            updates["normalDots"] = spec;
            delete childBuilders["normalDots;"];
            modifiedKeys["normalDots"] = true;
            return this;
        };
        this.normalDotsAt = (idx, build) => {
            makeReference("normalDots");
            if (frozen["normalDots"][idx]) {
                throw new Error("Patching normalDots." + idx + " twice in a builder is unsupported.");
            }
            if (original && original._snapshot && original._snapshot["normalDots"] && original._snapshot["normalDots"][idx] && !original["normalDots"][idx]) {
                // Clone snapshot.
                patches.push({ p: ["normalDots", idx], li: original._snapshot["normalDots"] });
            }
            if (typeof build === 'function' && reference["normalDots"][idx]) {
                let patch = build(new NormalDotBuilder(reference["normalDots"][idx])).patch();
                patches = patches.concat(patch.map(patch => {
                    // TODO: detach?
                    patch.p = ["normalDots", idx].concat(patch.p);
                    return patch;
                }));
                frozen["normalDots"][idx] = true;
                return this;
            }
            let update = typeof build === 'function' ? build(new NormalDotBuilder(reference["normalDots"][idx])).build() : build;
            if (original) {
                patches.push({ p: ["normalDots", idx], li: update });
            }
            else {
                updates["normalDots"] = reference["normalDots"]; // TODO: Merge?
            }
            reference["normalDots"][idx] = update;
            frozen["normalDots"][idx] = true;
            return this;
        };
        this.normalDotsSplice = (start, deleteCount, ...items) => {
            makeReference("normalDots");
            let idx = start;
            if (original) {
                for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
                    if (frozen["normalDots"][idx]) {
                        throw new Error("Replacing normalDots." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["normalDots"][idx];
                    patches.push({ p: ["normalDots", idx], ld, li: items[idx - start] });
                    frozen["normalDots"][idx] = true;
                }
                for (; idx < start + deleteCount; ++idx) {
                    if (frozen["normalDots"][idx]) {
                        throw new Error("Removing normalDots." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["normalDots"][idx];
                    patches.push({ p: ["normalDots", idx], ld });
                }
                for (; idx < start + items.length; ++idx) {
                    patches.push({ p: ["normalDots", idx], li: items[idx - start] });
                    frozen["normalDots"][idx] = true;
                }
            }
            reference["normalDots"].splice(start, deleteCount, ...items);
            updates["normalDots"] = reference["normalDots"];
            frozen["normalDots"].splice(start, deleteCount, ...items.map(i => true));
            return this;
        };
    }
}
function patchTimeModification(base, builder) { return builder(new TimeModificationBuilder(base)).patch(); }
exports.patchTimeModification = patchTimeModification;
function buildTimeModification(builder) { return builder(new TimeModificationBuilder()).build(); }
exports.buildTimeModification = buildTimeModification;
class StemBuilder {
    build;
    patch;
    type;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    color;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["type"]) ||
                childBuilders["type"] !== undefined ||
                updates.type !== undefined, "type is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Stem";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.type = (spec) => {
            updates["type"] = spec;
            delete childBuilders["type;"];
            modifiedKeys["type"] = true;
            return this;
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
    }
}
function patchStem(base, builder) { return builder(new StemBuilder(base)).patch(); }
exports.patchStem = patchStem;
function buildStem(builder) { return builder(new StemBuilder()).build(); }
exports.buildStem = buildStem;
class NoteheadBuilder {
    build;
    patch;
    type;
    filled;
    parentheses;
    fontFamily;
    fontWeight;
    fontStyle;
    fontSize;
    color;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["type"]) ||
                childBuilders["type"] !== undefined ||
                updates.type !== undefined, "type is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Notehead";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.type = (spec) => {
            updates["type"] = spec;
            delete childBuilders["type;"];
            modifiedKeys["type"] = true;
            return this;
        };
        this.filled = (spec) => {
            updates["filled"] = spec;
            delete childBuilders["filled;"];
            modifiedKeys["filled"] = true;
            return this;
        };
        this.parentheses = (spec) => {
            updates["parentheses"] = spec;
            delete childBuilders["parentheses;"];
            modifiedKeys["parentheses"] = true;
            return this;
        };
        this.fontFamily = (spec) => {
            updates["fontFamily"] = spec;
            delete childBuilders["fontFamily;"];
            modifiedKeys["fontFamily"] = true;
            return this;
        };
        this.fontWeight = (spec) => {
            updates["fontWeight"] = spec;
            delete childBuilders["fontWeight;"];
            modifiedKeys["fontWeight"] = true;
            return this;
        };
        this.fontStyle = (spec) => {
            updates["fontStyle"] = spec;
            delete childBuilders["fontStyle;"];
            modifiedKeys["fontStyle"] = true;
            return this;
        };
        this.fontSize = (spec) => {
            updates["fontSize"] = spec;
            delete childBuilders["fontSize;"];
            modifiedKeys["fontSize"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
    }
}
function patchNotehead(base, builder) { return builder(new NoteheadBuilder(base)).patch(); }
exports.patchNotehead = patchNotehead;
function buildNotehead(builder) { return builder(new NoteheadBuilder()).build(); }
exports.buildNotehead = buildNotehead;
class NoteheadTextBuilder {
    build;
    patch;
    textAt;
    textSplice;
    text;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["text"]) ||
                childBuilders["text"] !== undefined ||
                updates.text !== undefined, "text is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "NoteheadText";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.text = (spec) => {
            updates["text"] = spec;
            delete childBuilders["text;"];
            modifiedKeys["text"] = true;
            return this;
        };
        this.textAt = (idx, build) => {
            makeReference("text");
            if (frozen["text"][idx]) {
                throw new Error("Patching text." + idx + " twice in a builder is unsupported.");
            }
            if (original && original._snapshot && original._snapshot["text"] && original._snapshot["text"][idx] && !original["text"][idx]) {
                // Clone snapshot.
                patches.push({ p: ["text", idx], li: original._snapshot["text"] });
            }
            if (typeof build === 'function' && reference["text"][idx]) {
                let patch = build(new TextSegmentBuilder(reference["text"][idx])).patch();
                patches = patches.concat(patch.map(patch => {
                    // TODO: detach?
                    patch.p = ["text", idx].concat(patch.p);
                    return patch;
                }));
                frozen["text"][idx] = true;
                return this;
            }
            let update = typeof build === 'function' ? build(new TextSegmentBuilder(reference["text"][idx])).build() : build;
            if (original) {
                patches.push({ p: ["text", idx], li: update });
            }
            else {
                updates["text"] = reference["text"]; // TODO: Merge?
            }
            reference["text"][idx] = update;
            frozen["text"][idx] = true;
            return this;
        };
        this.textSplice = (start, deleteCount, ...items) => {
            makeReference("text");
            let idx = start;
            if (original) {
                for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
                    if (frozen["text"][idx]) {
                        throw new Error("Replacing text." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["text"][idx];
                    patches.push({ p: ["text", idx], ld, li: items[idx - start] });
                    frozen["text"][idx] = true;
                }
                for (; idx < start + deleteCount; ++idx) {
                    if (frozen["text"][idx]) {
                        throw new Error("Removing text." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["text"][idx];
                    patches.push({ p: ["text", idx], ld });
                }
                for (; idx < start + items.length; ++idx) {
                    patches.push({ p: ["text", idx], li: items[idx - start] });
                    frozen["text"][idx] = true;
                }
            }
            reference["text"].splice(start, deleteCount, ...items);
            updates["text"] = reference["text"];
            frozen["text"].splice(start, deleteCount, ...items.map(i => true));
            return this;
        };
    }
}
function patchNoteheadText(base, builder) { return builder(new NoteheadTextBuilder(base)).patch(); }
exports.patchNoteheadText = patchNoteheadText;
function buildNoteheadText(builder) { return builder(new NoteheadTextBuilder()).build(); }
exports.buildNoteheadText = buildNoteheadText;
class BeamBuilder {
    build;
    patch;
    repeater;
    number;
    type;
    fan;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["number"]) ||
                childBuilders["number"] !== undefined ||
                updates.number !== undefined, "number is a required field");
            console.assert((original && !modifiedKeys["type"]) ||
                childBuilders["type"] !== undefined ||
                updates.type !== undefined, "type is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Beam";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.repeater = (spec) => {
            updates["repeater"] = spec;
            delete childBuilders["repeater;"];
            modifiedKeys["repeater"] = true;
            return this;
        };
        this.number = (spec) => {
            updates["number"] = spec;
            delete childBuilders["number;"];
            modifiedKeys["number"] = true;
            return this;
        };
        this.type = (spec) => {
            updates["type"] = spec;
            delete childBuilders["type;"];
            modifiedKeys["type"] = true;
            return this;
        };
        this.fan = (spec) => {
            updates["fan"] = spec;
            delete childBuilders["fan;"];
            modifiedKeys["fan"] = true;
            return this;
        };
    }
}
function patchBeam(base, builder) { return builder(new BeamBuilder(base)).patch(); }
exports.patchBeam = patchBeam;
function buildBeam(builder) { return builder(new BeamBuilder()).build(); }
exports.buildBeam = buildBeam;
class NotationsBuilder {
    build;
    patch;
    slursAt;
    slursSplice;
    slurs;
    articulationsAt;
    articulationsSplice;
    articulations;
    slidesAt;
    slidesSplice;
    slides;
    technicalsAt;
    technicalsSplice;
    technicals;
    tiedsAt;
    tiedsSplice;
    tieds;
    tupletsAt;
    tupletsSplice;
    tuplets;
    glissandosAt;
    glissandosSplice;
    glissandos;
    dynamicsAt;
    dynamicsSplice;
    dynamics;
    fermatasAt;
    fermatasSplice;
    fermatas;
    accidentalMarksAt;
    accidentalMarksSplice;
    accidentalMarks;
    ornamentsAt;
    ornamentsSplice;
    ornaments;
    arpeggiatesAt;
    arpeggiatesSplice;
    arpeggiates;
    nonArpeggiatesAt;
    nonArpeggiatesSplice;
    nonArpeggiates;
    otherNotationsAt;
    otherNotationsSplice;
    otherNotations;
    printObject;
    footnote;
    level;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Notations";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.slurs = (spec) => {
            updates["slurs"] = spec;
            delete childBuilders["slurs;"];
            modifiedKeys["slurs"] = true;
            return this;
        };
        this.slursAt = (idx, build) => {
            makeReference("slurs");
            if (frozen["slurs"][idx]) {
                throw new Error("Patching slurs." + idx + " twice in a builder is unsupported.");
            }
            if (original && original._snapshot && original._snapshot["slurs"] && original._snapshot["slurs"][idx] && !original["slurs"][idx]) {
                // Clone snapshot.
                patches.push({ p: ["slurs", idx], li: original._snapshot["slurs"] });
            }
            if (typeof build === 'function' && reference["slurs"][idx]) {
                let patch = build(new SlurBuilder(reference["slurs"][idx])).patch();
                patches = patches.concat(patch.map(patch => {
                    // TODO: detach?
                    patch.p = ["slurs", idx].concat(patch.p);
                    return patch;
                }));
                frozen["slurs"][idx] = true;
                return this;
            }
            let update = typeof build === 'function' ? build(new SlurBuilder(reference["slurs"][idx])).build() : build;
            if (original) {
                patches.push({ p: ["slurs", idx], li: update });
            }
            else {
                updates["slurs"] = reference["slurs"]; // TODO: Merge?
            }
            reference["slurs"][idx] = update;
            frozen["slurs"][idx] = true;
            return this;
        };
        this.slursSplice = (start, deleteCount, ...items) => {
            makeReference("slurs");
            let idx = start;
            if (original) {
                for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
                    if (frozen["slurs"][idx]) {
                        throw new Error("Replacing slurs." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["slurs"][idx];
                    patches.push({ p: ["slurs", idx], ld, li: items[idx - start] });
                    frozen["slurs"][idx] = true;
                }
                for (; idx < start + deleteCount; ++idx) {
                    if (frozen["slurs"][idx]) {
                        throw new Error("Removing slurs." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["slurs"][idx];
                    patches.push({ p: ["slurs", idx], ld });
                }
                for (; idx < start + items.length; ++idx) {
                    patches.push({ p: ["slurs", idx], li: items[idx - start] });
                    frozen["slurs"][idx] = true;
                }
            }
            reference["slurs"].splice(start, deleteCount, ...items);
            updates["slurs"] = reference["slurs"];
            frozen["slurs"].splice(start, deleteCount, ...items.map(i => true));
            return this;
        };
        this.articulations = (spec) => {
            updates["articulations"] = spec;
            delete childBuilders["articulations;"];
            modifiedKeys["articulations"] = true;
            return this;
        };
        this.articulationsAt = (idx, build) => {
            makeReference("articulations");
            if (frozen["articulations"][idx]) {
                throw new Error("Patching articulations." + idx + " twice in a builder is unsupported.");
            }
            if (original && original._snapshot && original._snapshot["articulations"] && original._snapshot["articulations"][idx] && !original["articulations"][idx]) {
                // Clone snapshot.
                patches.push({ p: ["articulations", idx], li: original._snapshot["articulations"] });
            }
            if (typeof build === 'function' && reference["articulations"][idx]) {
                let patch = build(new ArticulationsBuilder(reference["articulations"][idx])).patch();
                patches = patches.concat(patch.map(patch => {
                    // TODO: detach?
                    patch.p = ["articulations", idx].concat(patch.p);
                    return patch;
                }));
                frozen["articulations"][idx] = true;
                return this;
            }
            let update = typeof build === 'function' ? build(new ArticulationsBuilder(reference["articulations"][idx])).build() : build;
            if (original) {
                patches.push({ p: ["articulations", idx], li: update });
            }
            else {
                updates["articulations"] = reference["articulations"]; // TODO: Merge?
            }
            reference["articulations"][idx] = update;
            frozen["articulations"][idx] = true;
            return this;
        };
        this.articulationsSplice = (start, deleteCount, ...items) => {
            makeReference("articulations");
            let idx = start;
            if (original) {
                for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
                    if (frozen["articulations"][idx]) {
                        throw new Error("Replacing articulations." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["articulations"][idx];
                    patches.push({ p: ["articulations", idx], ld, li: items[idx - start] });
                    frozen["articulations"][idx] = true;
                }
                for (; idx < start + deleteCount; ++idx) {
                    if (frozen["articulations"][idx]) {
                        throw new Error("Removing articulations." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["articulations"][idx];
                    patches.push({ p: ["articulations", idx], ld });
                }
                for (; idx < start + items.length; ++idx) {
                    patches.push({ p: ["articulations", idx], li: items[idx - start] });
                    frozen["articulations"][idx] = true;
                }
            }
            reference["articulations"].splice(start, deleteCount, ...items);
            updates["articulations"] = reference["articulations"];
            frozen["articulations"].splice(start, deleteCount, ...items.map(i => true));
            return this;
        };
        this.slides = (spec) => {
            updates["slides"] = spec;
            delete childBuilders["slides;"];
            modifiedKeys["slides"] = true;
            return this;
        };
        this.slidesAt = (idx, build) => {
            makeReference("slides");
            if (frozen["slides"][idx]) {
                throw new Error("Patching slides." + idx + " twice in a builder is unsupported.");
            }
            if (original && original._snapshot && original._snapshot["slides"] && original._snapshot["slides"][idx] && !original["slides"][idx]) {
                // Clone snapshot.
                patches.push({ p: ["slides", idx], li: original._snapshot["slides"] });
            }
            if (typeof build === 'function' && reference["slides"][idx]) {
                let patch = build(new SlideBuilder(reference["slides"][idx])).patch();
                patches = patches.concat(patch.map(patch => {
                    // TODO: detach?
                    patch.p = ["slides", idx].concat(patch.p);
                    return patch;
                }));
                frozen["slides"][idx] = true;
                return this;
            }
            let update = typeof build === 'function' ? build(new SlideBuilder(reference["slides"][idx])).build() : build;
            if (original) {
                patches.push({ p: ["slides", idx], li: update });
            }
            else {
                updates["slides"] = reference["slides"]; // TODO: Merge?
            }
            reference["slides"][idx] = update;
            frozen["slides"][idx] = true;
            return this;
        };
        this.slidesSplice = (start, deleteCount, ...items) => {
            makeReference("slides");
            let idx = start;
            if (original) {
                for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
                    if (frozen["slides"][idx]) {
                        throw new Error("Replacing slides." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["slides"][idx];
                    patches.push({ p: ["slides", idx], ld, li: items[idx - start] });
                    frozen["slides"][idx] = true;
                }
                for (; idx < start + deleteCount; ++idx) {
                    if (frozen["slides"][idx]) {
                        throw new Error("Removing slides." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["slides"][idx];
                    patches.push({ p: ["slides", idx], ld });
                }
                for (; idx < start + items.length; ++idx) {
                    patches.push({ p: ["slides", idx], li: items[idx - start] });
                    frozen["slides"][idx] = true;
                }
            }
            reference["slides"].splice(start, deleteCount, ...items);
            updates["slides"] = reference["slides"];
            frozen["slides"].splice(start, deleteCount, ...items.map(i => true));
            return this;
        };
        this.technicals = (spec) => {
            updates["technicals"] = spec;
            delete childBuilders["technicals;"];
            modifiedKeys["technicals"] = true;
            return this;
        };
        this.technicalsAt = (idx, build) => {
            makeReference("technicals");
            if (frozen["technicals"][idx]) {
                throw new Error("Patching technicals." + idx + " twice in a builder is unsupported.");
            }
            if (original && original._snapshot && original._snapshot["technicals"] && original._snapshot["technicals"][idx] && !original["technicals"][idx]) {
                // Clone snapshot.
                patches.push({ p: ["technicals", idx], li: original._snapshot["technicals"] });
            }
            if (typeof build === 'function' && reference["technicals"][idx]) {
                let patch = build(new TechnicalBuilder(reference["technicals"][idx])).patch();
                patches = patches.concat(patch.map(patch => {
                    // TODO: detach?
                    patch.p = ["technicals", idx].concat(patch.p);
                    return patch;
                }));
                frozen["technicals"][idx] = true;
                return this;
            }
            let update = typeof build === 'function' ? build(new TechnicalBuilder(reference["technicals"][idx])).build() : build;
            if (original) {
                patches.push({ p: ["technicals", idx], li: update });
            }
            else {
                updates["technicals"] = reference["technicals"]; // TODO: Merge?
            }
            reference["technicals"][idx] = update;
            frozen["technicals"][idx] = true;
            return this;
        };
        this.technicalsSplice = (start, deleteCount, ...items) => {
            makeReference("technicals");
            let idx = start;
            if (original) {
                for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
                    if (frozen["technicals"][idx]) {
                        throw new Error("Replacing technicals." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["technicals"][idx];
                    patches.push({ p: ["technicals", idx], ld, li: items[idx - start] });
                    frozen["technicals"][idx] = true;
                }
                for (; idx < start + deleteCount; ++idx) {
                    if (frozen["technicals"][idx]) {
                        throw new Error("Removing technicals." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["technicals"][idx];
                    patches.push({ p: ["technicals", idx], ld });
                }
                for (; idx < start + items.length; ++idx) {
                    patches.push({ p: ["technicals", idx], li: items[idx - start] });
                    frozen["technicals"][idx] = true;
                }
            }
            reference["technicals"].splice(start, deleteCount, ...items);
            updates["technicals"] = reference["technicals"];
            frozen["technicals"].splice(start, deleteCount, ...items.map(i => true));
            return this;
        };
        this.tieds = (spec) => {
            updates["tieds"] = spec;
            delete childBuilders["tieds;"];
            modifiedKeys["tieds"] = true;
            return this;
        };
        this.tiedsAt = (idx, build) => {
            makeReference("tieds");
            if (frozen["tieds"][idx]) {
                throw new Error("Patching tieds." + idx + " twice in a builder is unsupported.");
            }
            if (original && original._snapshot && original._snapshot["tieds"] && original._snapshot["tieds"][idx] && !original["tieds"][idx]) {
                // Clone snapshot.
                patches.push({ p: ["tieds", idx], li: original._snapshot["tieds"] });
            }
            if (typeof build === 'function' && reference["tieds"][idx]) {
                let patch = build(new TiedBuilder(reference["tieds"][idx])).patch();
                patches = patches.concat(patch.map(patch => {
                    // TODO: detach?
                    patch.p = ["tieds", idx].concat(patch.p);
                    return patch;
                }));
                frozen["tieds"][idx] = true;
                return this;
            }
            let update = typeof build === 'function' ? build(new TiedBuilder(reference["tieds"][idx])).build() : build;
            if (original) {
                patches.push({ p: ["tieds", idx], li: update });
            }
            else {
                updates["tieds"] = reference["tieds"]; // TODO: Merge?
            }
            reference["tieds"][idx] = update;
            frozen["tieds"][idx] = true;
            return this;
        };
        this.tiedsSplice = (start, deleteCount, ...items) => {
            makeReference("tieds");
            let idx = start;
            if (original) {
                for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
                    if (frozen["tieds"][idx]) {
                        throw new Error("Replacing tieds." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["tieds"][idx];
                    patches.push({ p: ["tieds", idx], ld, li: items[idx - start] });
                    frozen["tieds"][idx] = true;
                }
                for (; idx < start + deleteCount; ++idx) {
                    if (frozen["tieds"][idx]) {
                        throw new Error("Removing tieds." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["tieds"][idx];
                    patches.push({ p: ["tieds", idx], ld });
                }
                for (; idx < start + items.length; ++idx) {
                    patches.push({ p: ["tieds", idx], li: items[idx - start] });
                    frozen["tieds"][idx] = true;
                }
            }
            reference["tieds"].splice(start, deleteCount, ...items);
            updates["tieds"] = reference["tieds"];
            frozen["tieds"].splice(start, deleteCount, ...items.map(i => true));
            return this;
        };
        this.tuplets = (spec) => {
            updates["tuplets"] = spec;
            delete childBuilders["tuplets;"];
            modifiedKeys["tuplets"] = true;
            return this;
        };
        this.tupletsAt = (idx, build) => {
            makeReference("tuplets");
            if (frozen["tuplets"][idx]) {
                throw new Error("Patching tuplets." + idx + " twice in a builder is unsupported.");
            }
            if (original && original._snapshot && original._snapshot["tuplets"] && original._snapshot["tuplets"][idx] && !original["tuplets"][idx]) {
                // Clone snapshot.
                patches.push({ p: ["tuplets", idx], li: original._snapshot["tuplets"] });
            }
            if (typeof build === 'function' && reference["tuplets"][idx]) {
                let patch = build(new TupletBuilder(reference["tuplets"][idx])).patch();
                patches = patches.concat(patch.map(patch => {
                    // TODO: detach?
                    patch.p = ["tuplets", idx].concat(patch.p);
                    return patch;
                }));
                frozen["tuplets"][idx] = true;
                return this;
            }
            let update = typeof build === 'function' ? build(new TupletBuilder(reference["tuplets"][idx])).build() : build;
            if (original) {
                patches.push({ p: ["tuplets", idx], li: update });
            }
            else {
                updates["tuplets"] = reference["tuplets"]; // TODO: Merge?
            }
            reference["tuplets"][idx] = update;
            frozen["tuplets"][idx] = true;
            return this;
        };
        this.tupletsSplice = (start, deleteCount, ...items) => {
            makeReference("tuplets");
            let idx = start;
            if (original) {
                for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
                    if (frozen["tuplets"][idx]) {
                        throw new Error("Replacing tuplets." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["tuplets"][idx];
                    patches.push({ p: ["tuplets", idx], ld, li: items[idx - start] });
                    frozen["tuplets"][idx] = true;
                }
                for (; idx < start + deleteCount; ++idx) {
                    if (frozen["tuplets"][idx]) {
                        throw new Error("Removing tuplets." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["tuplets"][idx];
                    patches.push({ p: ["tuplets", idx], ld });
                }
                for (; idx < start + items.length; ++idx) {
                    patches.push({ p: ["tuplets", idx], li: items[idx - start] });
                    frozen["tuplets"][idx] = true;
                }
            }
            reference["tuplets"].splice(start, deleteCount, ...items);
            updates["tuplets"] = reference["tuplets"];
            frozen["tuplets"].splice(start, deleteCount, ...items.map(i => true));
            return this;
        };
        this.glissandos = (spec) => {
            updates["glissandos"] = spec;
            delete childBuilders["glissandos;"];
            modifiedKeys["glissandos"] = true;
            return this;
        };
        this.glissandosAt = (idx, build) => {
            makeReference("glissandos");
            if (frozen["glissandos"][idx]) {
                throw new Error("Patching glissandos." + idx + " twice in a builder is unsupported.");
            }
            if (original && original._snapshot && original._snapshot["glissandos"] && original._snapshot["glissandos"][idx] && !original["glissandos"][idx]) {
                // Clone snapshot.
                patches.push({ p: ["glissandos", idx], li: original._snapshot["glissandos"] });
            }
            if (typeof build === 'function' && reference["glissandos"][idx]) {
                let patch = build(new GlissandoBuilder(reference["glissandos"][idx])).patch();
                patches = patches.concat(patch.map(patch => {
                    // TODO: detach?
                    patch.p = ["glissandos", idx].concat(patch.p);
                    return patch;
                }));
                frozen["glissandos"][idx] = true;
                return this;
            }
            let update = typeof build === 'function' ? build(new GlissandoBuilder(reference["glissandos"][idx])).build() : build;
            if (original) {
                patches.push({ p: ["glissandos", idx], li: update });
            }
            else {
                updates["glissandos"] = reference["glissandos"]; // TODO: Merge?
            }
            reference["glissandos"][idx] = update;
            frozen["glissandos"][idx] = true;
            return this;
        };
        this.glissandosSplice = (start, deleteCount, ...items) => {
            makeReference("glissandos");
            let idx = start;
            if (original) {
                for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
                    if (frozen["glissandos"][idx]) {
                        throw new Error("Replacing glissandos." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["glissandos"][idx];
                    patches.push({ p: ["glissandos", idx], ld, li: items[idx - start] });
                    frozen["glissandos"][idx] = true;
                }
                for (; idx < start + deleteCount; ++idx) {
                    if (frozen["glissandos"][idx]) {
                        throw new Error("Removing glissandos." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["glissandos"][idx];
                    patches.push({ p: ["glissandos", idx], ld });
                }
                for (; idx < start + items.length; ++idx) {
                    patches.push({ p: ["glissandos", idx], li: items[idx - start] });
                    frozen["glissandos"][idx] = true;
                }
            }
            reference["glissandos"].splice(start, deleteCount, ...items);
            updates["glissandos"] = reference["glissandos"];
            frozen["glissandos"].splice(start, deleteCount, ...items.map(i => true));
            return this;
        };
        this.dynamics = (spec) => {
            updates["dynamics"] = spec;
            delete childBuilders["dynamics;"];
            modifiedKeys["dynamics"] = true;
            return this;
        };
        this.dynamicsAt = (idx, build) => {
            makeReference("dynamics");
            if (frozen["dynamics"][idx]) {
                throw new Error("Patching dynamics." + idx + " twice in a builder is unsupported.");
            }
            if (original && original._snapshot && original._snapshot["dynamics"] && original._snapshot["dynamics"][idx] && !original["dynamics"][idx]) {
                // Clone snapshot.
                patches.push({ p: ["dynamics", idx], li: original._snapshot["dynamics"] });
            }
            if (typeof build === 'function' && reference["dynamics"][idx]) {
                let patch = build(new DynamicsBuilder(reference["dynamics"][idx])).patch();
                patches = patches.concat(patch.map(patch => {
                    // TODO: detach?
                    patch.p = ["dynamics", idx].concat(patch.p);
                    return patch;
                }));
                frozen["dynamics"][idx] = true;
                return this;
            }
            let update = typeof build === 'function' ? build(new DynamicsBuilder(reference["dynamics"][idx])).build() : build;
            if (original) {
                patches.push({ p: ["dynamics", idx], li: update });
            }
            else {
                updates["dynamics"] = reference["dynamics"]; // TODO: Merge?
            }
            reference["dynamics"][idx] = update;
            frozen["dynamics"][idx] = true;
            return this;
        };
        this.dynamicsSplice = (start, deleteCount, ...items) => {
            makeReference("dynamics");
            let idx = start;
            if (original) {
                for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
                    if (frozen["dynamics"][idx]) {
                        throw new Error("Replacing dynamics." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["dynamics"][idx];
                    patches.push({ p: ["dynamics", idx], ld, li: items[idx - start] });
                    frozen["dynamics"][idx] = true;
                }
                for (; idx < start + deleteCount; ++idx) {
                    if (frozen["dynamics"][idx]) {
                        throw new Error("Removing dynamics." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["dynamics"][idx];
                    patches.push({ p: ["dynamics", idx], ld });
                }
                for (; idx < start + items.length; ++idx) {
                    patches.push({ p: ["dynamics", idx], li: items[idx - start] });
                    frozen["dynamics"][idx] = true;
                }
            }
            reference["dynamics"].splice(start, deleteCount, ...items);
            updates["dynamics"] = reference["dynamics"];
            frozen["dynamics"].splice(start, deleteCount, ...items.map(i => true));
            return this;
        };
        this.fermatas = (spec) => {
            updates["fermatas"] = spec;
            delete childBuilders["fermatas;"];
            modifiedKeys["fermatas"] = true;
            return this;
        };
        this.fermatasAt = (idx, build) => {
            makeReference("fermatas");
            if (frozen["fermatas"][idx]) {
                throw new Error("Patching fermatas." + idx + " twice in a builder is unsupported.");
            }
            if (original && original._snapshot && original._snapshot["fermatas"] && original._snapshot["fermatas"][idx] && !original["fermatas"][idx]) {
                // Clone snapshot.
                patches.push({ p: ["fermatas", idx], li: original._snapshot["fermatas"] });
            }
            if (typeof build === 'function' && reference["fermatas"][idx]) {
                let patch = build(new FermataBuilder(reference["fermatas"][idx])).patch();
                patches = patches.concat(patch.map(patch => {
                    // TODO: detach?
                    patch.p = ["fermatas", idx].concat(patch.p);
                    return patch;
                }));
                frozen["fermatas"][idx] = true;
                return this;
            }
            let update = typeof build === 'function' ? build(new FermataBuilder(reference["fermatas"][idx])).build() : build;
            if (original) {
                patches.push({ p: ["fermatas", idx], li: update });
            }
            else {
                updates["fermatas"] = reference["fermatas"]; // TODO: Merge?
            }
            reference["fermatas"][idx] = update;
            frozen["fermatas"][idx] = true;
            return this;
        };
        this.fermatasSplice = (start, deleteCount, ...items) => {
            makeReference("fermatas");
            let idx = start;
            if (original) {
                for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
                    if (frozen["fermatas"][idx]) {
                        throw new Error("Replacing fermatas." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["fermatas"][idx];
                    patches.push({ p: ["fermatas", idx], ld, li: items[idx - start] });
                    frozen["fermatas"][idx] = true;
                }
                for (; idx < start + deleteCount; ++idx) {
                    if (frozen["fermatas"][idx]) {
                        throw new Error("Removing fermatas." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["fermatas"][idx];
                    patches.push({ p: ["fermatas", idx], ld });
                }
                for (; idx < start + items.length; ++idx) {
                    patches.push({ p: ["fermatas", idx], li: items[idx - start] });
                    frozen["fermatas"][idx] = true;
                }
            }
            reference["fermatas"].splice(start, deleteCount, ...items);
            updates["fermatas"] = reference["fermatas"];
            frozen["fermatas"].splice(start, deleteCount, ...items.map(i => true));
            return this;
        };
        this.accidentalMarks = (spec) => {
            updates["accidentalMarks"] = spec;
            delete childBuilders["accidentalMarks;"];
            modifiedKeys["accidentalMarks"] = true;
            return this;
        };
        this.accidentalMarksAt = (idx, build) => {
            makeReference("accidentalMarks");
            if (frozen["accidentalMarks"][idx]) {
                throw new Error("Patching accidentalMarks." + idx + " twice in a builder is unsupported.");
            }
            if (original && original._snapshot && original._snapshot["accidentalMarks"] && original._snapshot["accidentalMarks"][idx] && !original["accidentalMarks"][idx]) {
                // Clone snapshot.
                patches.push({ p: ["accidentalMarks", idx], li: original._snapshot["accidentalMarks"] });
            }
            if (typeof build === 'function' && reference["accidentalMarks"][idx]) {
                let patch = build(new AccidentalMarkBuilder(reference["accidentalMarks"][idx])).patch();
                patches = patches.concat(patch.map(patch => {
                    // TODO: detach?
                    patch.p = ["accidentalMarks", idx].concat(patch.p);
                    return patch;
                }));
                frozen["accidentalMarks"][idx] = true;
                return this;
            }
            let update = typeof build === 'function' ? build(new AccidentalMarkBuilder(reference["accidentalMarks"][idx])).build() : build;
            if (original) {
                patches.push({ p: ["accidentalMarks", idx], li: update });
            }
            else {
                updates["accidentalMarks"] = reference["accidentalMarks"]; // TODO: Merge?
            }
            reference["accidentalMarks"][idx] = update;
            frozen["accidentalMarks"][idx] = true;
            return this;
        };
        this.accidentalMarksSplice = (start, deleteCount, ...items) => {
            makeReference("accidentalMarks");
            let idx = start;
            if (original) {
                for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
                    if (frozen["accidentalMarks"][idx]) {
                        throw new Error("Replacing accidentalMarks." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["accidentalMarks"][idx];
                    patches.push({ p: ["accidentalMarks", idx], ld, li: items[idx - start] });
                    frozen["accidentalMarks"][idx] = true;
                }
                for (; idx < start + deleteCount; ++idx) {
                    if (frozen["accidentalMarks"][idx]) {
                        throw new Error("Removing accidentalMarks." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["accidentalMarks"][idx];
                    patches.push({ p: ["accidentalMarks", idx], ld });
                }
                for (; idx < start + items.length; ++idx) {
                    patches.push({ p: ["accidentalMarks", idx], li: items[idx - start] });
                    frozen["accidentalMarks"][idx] = true;
                }
            }
            reference["accidentalMarks"].splice(start, deleteCount, ...items);
            updates["accidentalMarks"] = reference["accidentalMarks"];
            frozen["accidentalMarks"].splice(start, deleteCount, ...items.map(i => true));
            return this;
        };
        this.ornaments = (spec) => {
            updates["ornaments"] = spec;
            delete childBuilders["ornaments;"];
            modifiedKeys["ornaments"] = true;
            return this;
        };
        this.ornamentsAt = (idx, build) => {
            makeReference("ornaments");
            if (frozen["ornaments"][idx]) {
                throw new Error("Patching ornaments." + idx + " twice in a builder is unsupported.");
            }
            if (original && original._snapshot && original._snapshot["ornaments"] && original._snapshot["ornaments"][idx] && !original["ornaments"][idx]) {
                // Clone snapshot.
                patches.push({ p: ["ornaments", idx], li: original._snapshot["ornaments"] });
            }
            if (typeof build === 'function' && reference["ornaments"][idx]) {
                let patch = build(new OrnamentsBuilder(reference["ornaments"][idx])).patch();
                patches = patches.concat(patch.map(patch => {
                    // TODO: detach?
                    patch.p = ["ornaments", idx].concat(patch.p);
                    return patch;
                }));
                frozen["ornaments"][idx] = true;
                return this;
            }
            let update = typeof build === 'function' ? build(new OrnamentsBuilder(reference["ornaments"][idx])).build() : build;
            if (original) {
                patches.push({ p: ["ornaments", idx], li: update });
            }
            else {
                updates["ornaments"] = reference["ornaments"]; // TODO: Merge?
            }
            reference["ornaments"][idx] = update;
            frozen["ornaments"][idx] = true;
            return this;
        };
        this.ornamentsSplice = (start, deleteCount, ...items) => {
            makeReference("ornaments");
            let idx = start;
            if (original) {
                for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
                    if (frozen["ornaments"][idx]) {
                        throw new Error("Replacing ornaments." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["ornaments"][idx];
                    patches.push({ p: ["ornaments", idx], ld, li: items[idx - start] });
                    frozen["ornaments"][idx] = true;
                }
                for (; idx < start + deleteCount; ++idx) {
                    if (frozen["ornaments"][idx]) {
                        throw new Error("Removing ornaments." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["ornaments"][idx];
                    patches.push({ p: ["ornaments", idx], ld });
                }
                for (; idx < start + items.length; ++idx) {
                    patches.push({ p: ["ornaments", idx], li: items[idx - start] });
                    frozen["ornaments"][idx] = true;
                }
            }
            reference["ornaments"].splice(start, deleteCount, ...items);
            updates["ornaments"] = reference["ornaments"];
            frozen["ornaments"].splice(start, deleteCount, ...items.map(i => true));
            return this;
        };
        this.arpeggiates = (spec) => {
            updates["arpeggiates"] = spec;
            delete childBuilders["arpeggiates;"];
            modifiedKeys["arpeggiates"] = true;
            return this;
        };
        this.arpeggiatesAt = (idx, build) => {
            makeReference("arpeggiates");
            if (frozen["arpeggiates"][idx]) {
                throw new Error("Patching arpeggiates." + idx + " twice in a builder is unsupported.");
            }
            if (original && original._snapshot && original._snapshot["arpeggiates"] && original._snapshot["arpeggiates"][idx] && !original["arpeggiates"][idx]) {
                // Clone snapshot.
                patches.push({ p: ["arpeggiates", idx], li: original._snapshot["arpeggiates"] });
            }
            if (typeof build === 'function' && reference["arpeggiates"][idx]) {
                let patch = build(new ArpeggiateBuilder(reference["arpeggiates"][idx])).patch();
                patches = patches.concat(patch.map(patch => {
                    // TODO: detach?
                    patch.p = ["arpeggiates", idx].concat(patch.p);
                    return patch;
                }));
                frozen["arpeggiates"][idx] = true;
                return this;
            }
            let update = typeof build === 'function' ? build(new ArpeggiateBuilder(reference["arpeggiates"][idx])).build() : build;
            if (original) {
                patches.push({ p: ["arpeggiates", idx], li: update });
            }
            else {
                updates["arpeggiates"] = reference["arpeggiates"]; // TODO: Merge?
            }
            reference["arpeggiates"][idx] = update;
            frozen["arpeggiates"][idx] = true;
            return this;
        };
        this.arpeggiatesSplice = (start, deleteCount, ...items) => {
            makeReference("arpeggiates");
            let idx = start;
            if (original) {
                for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
                    if (frozen["arpeggiates"][idx]) {
                        throw new Error("Replacing arpeggiates." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["arpeggiates"][idx];
                    patches.push({ p: ["arpeggiates", idx], ld, li: items[idx - start] });
                    frozen["arpeggiates"][idx] = true;
                }
                for (; idx < start + deleteCount; ++idx) {
                    if (frozen["arpeggiates"][idx]) {
                        throw new Error("Removing arpeggiates." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["arpeggiates"][idx];
                    patches.push({ p: ["arpeggiates", idx], ld });
                }
                for (; idx < start + items.length; ++idx) {
                    patches.push({ p: ["arpeggiates", idx], li: items[idx - start] });
                    frozen["arpeggiates"][idx] = true;
                }
            }
            reference["arpeggiates"].splice(start, deleteCount, ...items);
            updates["arpeggiates"] = reference["arpeggiates"];
            frozen["arpeggiates"].splice(start, deleteCount, ...items.map(i => true));
            return this;
        };
        this.nonArpeggiates = (spec) => {
            updates["nonArpeggiates"] = spec;
            delete childBuilders["nonArpeggiates;"];
            modifiedKeys["nonArpeggiates"] = true;
            return this;
        };
        this.nonArpeggiatesAt = (idx, build) => {
            makeReference("nonArpeggiates");
            if (frozen["nonArpeggiates"][idx]) {
                throw new Error("Patching nonArpeggiates." + idx + " twice in a builder is unsupported.");
            }
            if (original && original._snapshot && original._snapshot["nonArpeggiates"] && original._snapshot["nonArpeggiates"][idx] && !original["nonArpeggiates"][idx]) {
                // Clone snapshot.
                patches.push({ p: ["nonArpeggiates", idx], li: original._snapshot["nonArpeggiates"] });
            }
            if (typeof build === 'function' && reference["nonArpeggiates"][idx]) {
                let patch = build(new NonArpeggiateBuilder(reference["nonArpeggiates"][idx])).patch();
                patches = patches.concat(patch.map(patch => {
                    // TODO: detach?
                    patch.p = ["nonArpeggiates", idx].concat(patch.p);
                    return patch;
                }));
                frozen["nonArpeggiates"][idx] = true;
                return this;
            }
            let update = typeof build === 'function' ? build(new NonArpeggiateBuilder(reference["nonArpeggiates"][idx])).build() : build;
            if (original) {
                patches.push({ p: ["nonArpeggiates", idx], li: update });
            }
            else {
                updates["nonArpeggiates"] = reference["nonArpeggiates"]; // TODO: Merge?
            }
            reference["nonArpeggiates"][idx] = update;
            frozen["nonArpeggiates"][idx] = true;
            return this;
        };
        this.nonArpeggiatesSplice = (start, deleteCount, ...items) => {
            makeReference("nonArpeggiates");
            let idx = start;
            if (original) {
                for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
                    if (frozen["nonArpeggiates"][idx]) {
                        throw new Error("Replacing nonArpeggiates." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["nonArpeggiates"][idx];
                    patches.push({ p: ["nonArpeggiates", idx], ld, li: items[idx - start] });
                    frozen["nonArpeggiates"][idx] = true;
                }
                for (; idx < start + deleteCount; ++idx) {
                    if (frozen["nonArpeggiates"][idx]) {
                        throw new Error("Removing nonArpeggiates." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["nonArpeggiates"][idx];
                    patches.push({ p: ["nonArpeggiates", idx], ld });
                }
                for (; idx < start + items.length; ++idx) {
                    patches.push({ p: ["nonArpeggiates", idx], li: items[idx - start] });
                    frozen["nonArpeggiates"][idx] = true;
                }
            }
            reference["nonArpeggiates"].splice(start, deleteCount, ...items);
            updates["nonArpeggiates"] = reference["nonArpeggiates"];
            frozen["nonArpeggiates"].splice(start, deleteCount, ...items.map(i => true));
            return this;
        };
        this.otherNotations = (spec) => {
            updates["otherNotations"] = spec;
            delete childBuilders["otherNotations;"];
            modifiedKeys["otherNotations"] = true;
            return this;
        };
        this.otherNotationsAt = (idx, build) => {
            makeReference("otherNotations");
            if (frozen["otherNotations"][idx]) {
                throw new Error("Patching otherNotations." + idx + " twice in a builder is unsupported.");
            }
            if (original && original._snapshot && original._snapshot["otherNotations"] && original._snapshot["otherNotations"][idx] && !original["otherNotations"][idx]) {
                // Clone snapshot.
                patches.push({ p: ["otherNotations", idx], li: original._snapshot["otherNotations"] });
            }
            if (typeof build === 'function' && reference["otherNotations"][idx]) {
                let patch = build(new OtherNotationBuilder(reference["otherNotations"][idx])).patch();
                patches = patches.concat(patch.map(patch => {
                    // TODO: detach?
                    patch.p = ["otherNotations", idx].concat(patch.p);
                    return patch;
                }));
                frozen["otherNotations"][idx] = true;
                return this;
            }
            let update = typeof build === 'function' ? build(new OtherNotationBuilder(reference["otherNotations"][idx])).build() : build;
            if (original) {
                patches.push({ p: ["otherNotations", idx], li: update });
            }
            else {
                updates["otherNotations"] = reference["otherNotations"]; // TODO: Merge?
            }
            reference["otherNotations"][idx] = update;
            frozen["otherNotations"][idx] = true;
            return this;
        };
        this.otherNotationsSplice = (start, deleteCount, ...items) => {
            makeReference("otherNotations");
            let idx = start;
            if (original) {
                for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
                    if (frozen["otherNotations"][idx]) {
                        throw new Error("Replacing otherNotations." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["otherNotations"][idx];
                    patches.push({ p: ["otherNotations", idx], ld, li: items[idx - start] });
                    frozen["otherNotations"][idx] = true;
                }
                for (; idx < start + deleteCount; ++idx) {
                    if (frozen["otherNotations"][idx]) {
                        throw new Error("Removing otherNotations." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["otherNotations"][idx];
                    patches.push({ p: ["otherNotations", idx], ld });
                }
                for (; idx < start + items.length; ++idx) {
                    patches.push({ p: ["otherNotations", idx], li: items[idx - start] });
                    frozen["otherNotations"][idx] = true;
                }
            }
            reference["otherNotations"].splice(start, deleteCount, ...items);
            updates["otherNotations"] = reference["otherNotations"];
            frozen["otherNotations"].splice(start, deleteCount, ...items.map(i => true));
            return this;
        };
        this.printObject = (spec) => {
            updates["printObject"] = spec;
            delete childBuilders["printObject;"];
            modifiedKeys["printObject"] = true;
            return this;
        };
        this.footnote = (build) => {
            if (typeof build === 'function') {
                delete updates["footnote"];
                const builder = build(new FootnoteBuilder(original && original["footnote"]));
                if (!original)
                    updates["footnote"] = builder.build();
                else
                    childBuilders["footnote"] = builder;
            }
            else {
                updates.footnote = build;
                delete childBuilders["footnote;"];
            }
            modifiedKeys["footnote"] = true;
            return this;
        };
        this.level = (build) => {
            if (typeof build === 'function') {
                delete updates["level"];
                const builder = build(new LevelBuilder(original && original["level"]));
                if (!original)
                    updates["level"] = builder.build();
                else
                    childBuilders["level"] = builder;
            }
            else {
                updates.level = build;
                delete childBuilders["level;"];
            }
            modifiedKeys["level"] = true;
            return this;
        };
    }
}
function patchNotations(base, builder) { return builder(new NotationsBuilder(base)).patch(); }
exports.patchNotations = patchNotations;
function buildNotations(builder) { return builder(new NotationsBuilder()).build(); }
exports.buildNotations = buildNotations;
class TiedBuilder {
    build;
    patch;
    number;
    type;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    color;
    placement;
    lineType;
    dashLength;
    spaceLength;
    orientation;
    bezierX2;
    bezierOffset;
    bezierOffset2;
    bezierX;
    bezierY;
    bezierY2;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["type"]) ||
                childBuilders["type"] !== undefined ||
                updates.type !== undefined, "type is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Tied";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.number = (spec) => {
            updates["number"] = spec;
            delete childBuilders["number;"];
            modifiedKeys["number"] = true;
            return this;
        };
        this.type = (spec) => {
            updates["type"] = spec;
            delete childBuilders["type;"];
            modifiedKeys["type"] = true;
            return this;
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
        this.placement = (spec) => {
            updates["placement"] = spec;
            delete childBuilders["placement;"];
            modifiedKeys["placement"] = true;
            return this;
        };
        this.lineType = (spec) => {
            updates["lineType"] = spec;
            delete childBuilders["lineType;"];
            modifiedKeys["lineType"] = true;
            return this;
        };
        this.dashLength = (spec) => {
            updates["dashLength"] = spec;
            delete childBuilders["dashLength;"];
            modifiedKeys["dashLength"] = true;
            return this;
        };
        this.spaceLength = (spec) => {
            updates["spaceLength"] = spec;
            delete childBuilders["spaceLength;"];
            modifiedKeys["spaceLength"] = true;
            return this;
        };
        this.orientation = (spec) => {
            updates["orientation"] = spec;
            delete childBuilders["orientation;"];
            modifiedKeys["orientation"] = true;
            return this;
        };
        this.bezierX2 = (spec) => {
            updates["bezierX2"] = spec;
            delete childBuilders["bezierX2;"];
            modifiedKeys["bezierX2"] = true;
            return this;
        };
        this.bezierOffset = (spec) => {
            updates["bezierOffset"] = spec;
            delete childBuilders["bezierOffset;"];
            modifiedKeys["bezierOffset"] = true;
            return this;
        };
        this.bezierOffset2 = (spec) => {
            updates["bezierOffset2"] = spec;
            delete childBuilders["bezierOffset2;"];
            modifiedKeys["bezierOffset2"] = true;
            return this;
        };
        this.bezierX = (spec) => {
            updates["bezierX"] = spec;
            delete childBuilders["bezierX;"];
            modifiedKeys["bezierX"] = true;
            return this;
        };
        this.bezierY = (spec) => {
            updates["bezierY"] = spec;
            delete childBuilders["bezierY;"];
            modifiedKeys["bezierY"] = true;
            return this;
        };
        this.bezierY2 = (spec) => {
            updates["bezierY2"] = spec;
            delete childBuilders["bezierY2;"];
            modifiedKeys["bezierY2"] = true;
            return this;
        };
    }
}
function patchTied(base, builder) { return builder(new TiedBuilder(base)).patch(); }
exports.patchTied = patchTied;
function buildTied(builder) { return builder(new TiedBuilder()).build(); }
exports.buildTied = buildTied;
class SlurBuilder {
    build;
    patch;
    number;
    type;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    color;
    placement;
    lineType;
    dashLength;
    spaceLength;
    orientation;
    bezierX2;
    bezierOffset;
    bezierOffset2;
    bezierX;
    bezierY;
    bezierY2;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["type"]) ||
                childBuilders["type"] !== undefined ||
                updates.type !== undefined, "type is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Slur";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.number = (spec) => {
            updates["number"] = spec;
            delete childBuilders["number;"];
            modifiedKeys["number"] = true;
            return this;
        };
        this.type = (spec) => {
            updates["type"] = spec;
            delete childBuilders["type;"];
            modifiedKeys["type"] = true;
            return this;
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
        this.placement = (spec) => {
            updates["placement"] = spec;
            delete childBuilders["placement;"];
            modifiedKeys["placement"] = true;
            return this;
        };
        this.lineType = (spec) => {
            updates["lineType"] = spec;
            delete childBuilders["lineType;"];
            modifiedKeys["lineType"] = true;
            return this;
        };
        this.dashLength = (spec) => {
            updates["dashLength"] = spec;
            delete childBuilders["dashLength;"];
            modifiedKeys["dashLength"] = true;
            return this;
        };
        this.spaceLength = (spec) => {
            updates["spaceLength"] = spec;
            delete childBuilders["spaceLength;"];
            modifiedKeys["spaceLength"] = true;
            return this;
        };
        this.orientation = (spec) => {
            updates["orientation"] = spec;
            delete childBuilders["orientation;"];
            modifiedKeys["orientation"] = true;
            return this;
        };
        this.bezierX2 = (spec) => {
            updates["bezierX2"] = spec;
            delete childBuilders["bezierX2;"];
            modifiedKeys["bezierX2"] = true;
            return this;
        };
        this.bezierOffset = (spec) => {
            updates["bezierOffset"] = spec;
            delete childBuilders["bezierOffset;"];
            modifiedKeys["bezierOffset"] = true;
            return this;
        };
        this.bezierOffset2 = (spec) => {
            updates["bezierOffset2"] = spec;
            delete childBuilders["bezierOffset2;"];
            modifiedKeys["bezierOffset2"] = true;
            return this;
        };
        this.bezierX = (spec) => {
            updates["bezierX"] = spec;
            delete childBuilders["bezierX;"];
            modifiedKeys["bezierX"] = true;
            return this;
        };
        this.bezierY = (spec) => {
            updates["bezierY"] = spec;
            delete childBuilders["bezierY;"];
            modifiedKeys["bezierY"] = true;
            return this;
        };
        this.bezierY2 = (spec) => {
            updates["bezierY2"] = spec;
            delete childBuilders["bezierY2;"];
            modifiedKeys["bezierY2"] = true;
            return this;
        };
    }
}
function patchSlur(base, builder) { return builder(new SlurBuilder(base)).patch(); }
exports.patchSlur = patchSlur;
function buildSlur(builder) { return builder(new SlurBuilder()).build(); }
exports.buildSlur = buildSlur;
class TupletBuilder {
    build;
    patch;
    bracket;
    number;
    showNumber;
    tupletNormal;
    type;
    showType;
    tupletActual;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    placement;
    lineShape;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["number"]) ||
                childBuilders["number"] !== undefined ||
                updates.number !== undefined, "number is a required field");
            console.assert((original && !modifiedKeys["type"]) ||
                childBuilders["type"] !== undefined ||
                updates.type !== undefined, "type is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Tuplet";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.bracket = (spec) => {
            updates["bracket"] = spec;
            delete childBuilders["bracket;"];
            modifiedKeys["bracket"] = true;
            return this;
        };
        this.number = (spec) => {
            updates["number"] = spec;
            delete childBuilders["number;"];
            modifiedKeys["number"] = true;
            return this;
        };
        this.showNumber = (spec) => {
            updates["showNumber"] = spec;
            delete childBuilders["showNumber;"];
            modifiedKeys["showNumber"] = true;
            return this;
        };
        this.tupletNormal = (build) => {
            if (typeof build === 'function') {
                delete updates["tupletNormal"];
                const builder = build(new TupletNormalBuilder(original && original["tupletNormal"]));
                if (!original)
                    updates["tupletNormal"] = builder.build();
                else
                    childBuilders["tupletNormal"] = builder;
            }
            else {
                updates.tupletNormal = build;
                delete childBuilders["tupletNormal;"];
            }
            modifiedKeys["tupletNormal"] = true;
            return this;
        };
        this.type = (spec) => {
            updates["type"] = spec;
            delete childBuilders["type;"];
            modifiedKeys["type"] = true;
            return this;
        };
        this.showType = (spec) => {
            updates["showType"] = spec;
            delete childBuilders["showType;"];
            modifiedKeys["showType"] = true;
            return this;
        };
        this.tupletActual = (build) => {
            if (typeof build === 'function') {
                delete updates["tupletActual"];
                const builder = build(new TupletActualBuilder(original && original["tupletActual"]));
                if (!original)
                    updates["tupletActual"] = builder.build();
                else
                    childBuilders["tupletActual"] = builder;
            }
            else {
                updates.tupletActual = build;
                delete childBuilders["tupletActual;"];
            }
            modifiedKeys["tupletActual"] = true;
            return this;
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
        this.placement = (spec) => {
            updates["placement"] = spec;
            delete childBuilders["placement;"];
            modifiedKeys["placement"] = true;
            return this;
        };
        this.lineShape = (spec) => {
            updates["lineShape"] = spec;
            delete childBuilders["lineShape;"];
            modifiedKeys["lineShape"] = true;
            return this;
        };
    }
}
function patchTuplet(base, builder) { return builder(new TupletBuilder(base)).patch(); }
exports.patchTuplet = patchTuplet;
function buildTuplet(builder) { return builder(new TupletBuilder()).build(); }
exports.buildTuplet = buildTuplet;
class TupletActualBuilder {
    build;
    patch;
    tupletNumber;
    tupletDotsAt;
    tupletDotsSplice;
    tupletDots;
    tupletType;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "TupletActual";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.tupletNumber = (build) => {
            if (typeof build === 'function') {
                delete updates["tupletNumber"];
                const builder = build(new TupletNumberBuilder(original && original["tupletNumber"]));
                if (!original)
                    updates["tupletNumber"] = builder.build();
                else
                    childBuilders["tupletNumber"] = builder;
            }
            else {
                updates.tupletNumber = build;
                delete childBuilders["tupletNumber;"];
            }
            modifiedKeys["tupletNumber"] = true;
            return this;
        };
        this.tupletDots = (spec) => {
            updates["tupletDots"] = spec;
            delete childBuilders["tupletDots;"];
            modifiedKeys["tupletDots"] = true;
            return this;
        };
        this.tupletDotsAt = (idx, build) => {
            makeReference("tupletDots");
            if (frozen["tupletDots"][idx]) {
                throw new Error("Patching tupletDots." + idx + " twice in a builder is unsupported.");
            }
            if (original && original._snapshot && original._snapshot["tupletDots"] && original._snapshot["tupletDots"][idx] && !original["tupletDots"][idx]) {
                // Clone snapshot.
                patches.push({ p: ["tupletDots", idx], li: original._snapshot["tupletDots"] });
            }
            if (typeof build === 'function' && reference["tupletDots"][idx]) {
                let patch = build(new TupletDotBuilder(reference["tupletDots"][idx])).patch();
                patches = patches.concat(patch.map(patch => {
                    // TODO: detach?
                    patch.p = ["tupletDots", idx].concat(patch.p);
                    return patch;
                }));
                frozen["tupletDots"][idx] = true;
                return this;
            }
            let update = typeof build === 'function' ? build(new TupletDotBuilder(reference["tupletDots"][idx])).build() : build;
            if (original) {
                patches.push({ p: ["tupletDots", idx], li: update });
            }
            else {
                updates["tupletDots"] = reference["tupletDots"]; // TODO: Merge?
            }
            reference["tupletDots"][idx] = update;
            frozen["tupletDots"][idx] = true;
            return this;
        };
        this.tupletDotsSplice = (start, deleteCount, ...items) => {
            makeReference("tupletDots");
            let idx = start;
            if (original) {
                for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
                    if (frozen["tupletDots"][idx]) {
                        throw new Error("Replacing tupletDots." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["tupletDots"][idx];
                    patches.push({ p: ["tupletDots", idx], ld, li: items[idx - start] });
                    frozen["tupletDots"][idx] = true;
                }
                for (; idx < start + deleteCount; ++idx) {
                    if (frozen["tupletDots"][idx]) {
                        throw new Error("Removing tupletDots." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["tupletDots"][idx];
                    patches.push({ p: ["tupletDots", idx], ld });
                }
                for (; idx < start + items.length; ++idx) {
                    patches.push({ p: ["tupletDots", idx], li: items[idx - start] });
                    frozen["tupletDots"][idx] = true;
                }
            }
            reference["tupletDots"].splice(start, deleteCount, ...items);
            updates["tupletDots"] = reference["tupletDots"];
            frozen["tupletDots"].splice(start, deleteCount, ...items.map(i => true));
            return this;
        };
        this.tupletType = (build) => {
            if (typeof build === 'function') {
                delete updates["tupletType"];
                const builder = build(new TupletTypeBuilder(original && original["tupletType"]));
                if (!original)
                    updates["tupletType"] = builder.build();
                else
                    childBuilders["tupletType"] = builder;
            }
            else {
                updates.tupletType = build;
                delete childBuilders["tupletType;"];
            }
            modifiedKeys["tupletType"] = true;
            return this;
        };
    }
}
function patchTupletActual(base, builder) { return builder(new TupletActualBuilder(base)).patch(); }
exports.patchTupletActual = patchTupletActual;
function buildTupletActual(builder) { return builder(new TupletActualBuilder()).build(); }
exports.buildTupletActual = buildTupletActual;
class TupletNormalBuilder {
    build;
    patch;
    tupletNumber;
    tupletDotsAt;
    tupletDotsSplice;
    tupletDots;
    tupletType;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "TupletNormal";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.tupletNumber = (build) => {
            if (typeof build === 'function') {
                delete updates["tupletNumber"];
                const builder = build(new TupletNumberBuilder(original && original["tupletNumber"]));
                if (!original)
                    updates["tupletNumber"] = builder.build();
                else
                    childBuilders["tupletNumber"] = builder;
            }
            else {
                updates.tupletNumber = build;
                delete childBuilders["tupletNumber;"];
            }
            modifiedKeys["tupletNumber"] = true;
            return this;
        };
        this.tupletDots = (spec) => {
            updates["tupletDots"] = spec;
            delete childBuilders["tupletDots;"];
            modifiedKeys["tupletDots"] = true;
            return this;
        };
        this.tupletDotsAt = (idx, build) => {
            makeReference("tupletDots");
            if (frozen["tupletDots"][idx]) {
                throw new Error("Patching tupletDots." + idx + " twice in a builder is unsupported.");
            }
            if (original && original._snapshot && original._snapshot["tupletDots"] && original._snapshot["tupletDots"][idx] && !original["tupletDots"][idx]) {
                // Clone snapshot.
                patches.push({ p: ["tupletDots", idx], li: original._snapshot["tupletDots"] });
            }
            if (typeof build === 'function' && reference["tupletDots"][idx]) {
                let patch = build(new TupletDotBuilder(reference["tupletDots"][idx])).patch();
                patches = patches.concat(patch.map(patch => {
                    // TODO: detach?
                    patch.p = ["tupletDots", idx].concat(patch.p);
                    return patch;
                }));
                frozen["tupletDots"][idx] = true;
                return this;
            }
            let update = typeof build === 'function' ? build(new TupletDotBuilder(reference["tupletDots"][idx])).build() : build;
            if (original) {
                patches.push({ p: ["tupletDots", idx], li: update });
            }
            else {
                updates["tupletDots"] = reference["tupletDots"]; // TODO: Merge?
            }
            reference["tupletDots"][idx] = update;
            frozen["tupletDots"][idx] = true;
            return this;
        };
        this.tupletDotsSplice = (start, deleteCount, ...items) => {
            makeReference("tupletDots");
            let idx = start;
            if (original) {
                for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
                    if (frozen["tupletDots"][idx]) {
                        throw new Error("Replacing tupletDots." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["tupletDots"][idx];
                    patches.push({ p: ["tupletDots", idx], ld, li: items[idx - start] });
                    frozen["tupletDots"][idx] = true;
                }
                for (; idx < start + deleteCount; ++idx) {
                    if (frozen["tupletDots"][idx]) {
                        throw new Error("Removing tupletDots." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["tupletDots"][idx];
                    patches.push({ p: ["tupletDots", idx], ld });
                }
                for (; idx < start + items.length; ++idx) {
                    patches.push({ p: ["tupletDots", idx], li: items[idx - start] });
                    frozen["tupletDots"][idx] = true;
                }
            }
            reference["tupletDots"].splice(start, deleteCount, ...items);
            updates["tupletDots"] = reference["tupletDots"];
            frozen["tupletDots"].splice(start, deleteCount, ...items.map(i => true));
            return this;
        };
        this.tupletType = (build) => {
            if (typeof build === 'function') {
                delete updates["tupletType"];
                const builder = build(new TupletTypeBuilder(original && original["tupletType"]));
                if (!original)
                    updates["tupletType"] = builder.build();
                else
                    childBuilders["tupletType"] = builder;
            }
            else {
                updates.tupletType = build;
                delete childBuilders["tupletType;"];
            }
            modifiedKeys["tupletType"] = true;
            return this;
        };
    }
}
function patchTupletNormal(base, builder) { return builder(new TupletNormalBuilder(base)).patch(); }
exports.patchTupletNormal = patchTupletNormal;
function buildTupletNormal(builder) { return builder(new TupletNormalBuilder()).build(); }
exports.buildTupletNormal = buildTupletNormal;
class TupletNumberBuilder {
    build;
    patch;
    text;
    fontFamily;
    fontWeight;
    fontStyle;
    fontSize;
    color;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["text"]) ||
                childBuilders["text"] !== undefined ||
                updates.text !== undefined, "text is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "TupletNumber";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.text = (spec) => {
            updates["text"] = spec;
            delete childBuilders["text;"];
            modifiedKeys["text"] = true;
            return this;
        };
        this.fontFamily = (spec) => {
            updates["fontFamily"] = spec;
            delete childBuilders["fontFamily;"];
            modifiedKeys["fontFamily"] = true;
            return this;
        };
        this.fontWeight = (spec) => {
            updates["fontWeight"] = spec;
            delete childBuilders["fontWeight;"];
            modifiedKeys["fontWeight"] = true;
            return this;
        };
        this.fontStyle = (spec) => {
            updates["fontStyle"] = spec;
            delete childBuilders["fontStyle;"];
            modifiedKeys["fontStyle"] = true;
            return this;
        };
        this.fontSize = (spec) => {
            updates["fontSize"] = spec;
            delete childBuilders["fontSize;"];
            modifiedKeys["fontSize"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
    }
}
function patchTupletNumber(base, builder) { return builder(new TupletNumberBuilder(base)).patch(); }
exports.patchTupletNumber = patchTupletNumber;
function buildTupletNumber(builder) { return builder(new TupletNumberBuilder()).build(); }
exports.buildTupletNumber = buildTupletNumber;
class TupletTypeBuilder {
    build;
    patch;
    text;
    fontFamily;
    fontWeight;
    fontStyle;
    fontSize;
    color;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["text"]) ||
                childBuilders["text"] !== undefined ||
                updates.text !== undefined, "text is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "TupletType";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.text = (spec) => {
            updates["text"] = spec;
            delete childBuilders["text;"];
            modifiedKeys["text"] = true;
            return this;
        };
        this.fontFamily = (spec) => {
            updates["fontFamily"] = spec;
            delete childBuilders["fontFamily;"];
            modifiedKeys["fontFamily"] = true;
            return this;
        };
        this.fontWeight = (spec) => {
            updates["fontWeight"] = spec;
            delete childBuilders["fontWeight;"];
            modifiedKeys["fontWeight"] = true;
            return this;
        };
        this.fontStyle = (spec) => {
            updates["fontStyle"] = spec;
            delete childBuilders["fontStyle;"];
            modifiedKeys["fontStyle"] = true;
            return this;
        };
        this.fontSize = (spec) => {
            updates["fontSize"] = spec;
            delete childBuilders["fontSize;"];
            modifiedKeys["fontSize"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
    }
}
function patchTupletType(base, builder) { return builder(new TupletTypeBuilder(base)).patch(); }
exports.patchTupletType = patchTupletType;
function buildTupletType(builder) { return builder(new TupletTypeBuilder()).build(); }
exports.buildTupletType = buildTupletType;
class TupletDotBuilder {
    build;
    patch;
    fontFamily;
    fontWeight;
    fontStyle;
    fontSize;
    color;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "TupletDot";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.fontFamily = (spec) => {
            updates["fontFamily"] = spec;
            delete childBuilders["fontFamily;"];
            modifiedKeys["fontFamily"] = true;
            return this;
        };
        this.fontWeight = (spec) => {
            updates["fontWeight"] = spec;
            delete childBuilders["fontWeight;"];
            modifiedKeys["fontWeight"] = true;
            return this;
        };
        this.fontStyle = (spec) => {
            updates["fontStyle"] = spec;
            delete childBuilders["fontStyle;"];
            modifiedKeys["fontStyle"] = true;
            return this;
        };
        this.fontSize = (spec) => {
            updates["fontSize"] = spec;
            delete childBuilders["fontSize;"];
            modifiedKeys["fontSize"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
    }
}
function patchTupletDot(base, builder) { return builder(new TupletDotBuilder(base)).patch(); }
exports.patchTupletDot = patchTupletDot;
function buildTupletDot(builder) { return builder(new TupletDotBuilder()).build(); }
exports.buildTupletDot = buildTupletDot;
class GlissandoBuilder {
    build;
    patch;
    text;
    type;
    number;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    fontFamily;
    fontWeight;
    fontStyle;
    fontSize;
    color;
    lineType;
    dashLength;
    spaceLength;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["type"]) ||
                childBuilders["type"] !== undefined ||
                updates.type !== undefined, "type is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Glissando";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.text = (spec) => {
            updates["text"] = spec;
            delete childBuilders["text;"];
            modifiedKeys["text"] = true;
            return this;
        };
        this.type = (spec) => {
            updates["type"] = spec;
            delete childBuilders["type;"];
            modifiedKeys["type"] = true;
            return this;
        };
        this.number = (spec) => {
            updates["number"] = spec;
            delete childBuilders["number;"];
            modifiedKeys["number"] = true;
            return this;
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
        this.fontFamily = (spec) => {
            updates["fontFamily"] = spec;
            delete childBuilders["fontFamily;"];
            modifiedKeys["fontFamily"] = true;
            return this;
        };
        this.fontWeight = (spec) => {
            updates["fontWeight"] = spec;
            delete childBuilders["fontWeight;"];
            modifiedKeys["fontWeight"] = true;
            return this;
        };
        this.fontStyle = (spec) => {
            updates["fontStyle"] = spec;
            delete childBuilders["fontStyle;"];
            modifiedKeys["fontStyle"] = true;
            return this;
        };
        this.fontSize = (spec) => {
            updates["fontSize"] = spec;
            delete childBuilders["fontSize;"];
            modifiedKeys["fontSize"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
        this.lineType = (spec) => {
            updates["lineType"] = spec;
            delete childBuilders["lineType;"];
            modifiedKeys["lineType"] = true;
            return this;
        };
        this.dashLength = (spec) => {
            updates["dashLength"] = spec;
            delete childBuilders["dashLength;"];
            modifiedKeys["dashLength"] = true;
            return this;
        };
        this.spaceLength = (spec) => {
            updates["spaceLength"] = spec;
            delete childBuilders["spaceLength;"];
            modifiedKeys["spaceLength"] = true;
            return this;
        };
    }
}
function patchGlissando(base, builder) { return builder(new GlissandoBuilder(base)).patch(); }
exports.patchGlissando = patchGlissando;
function buildGlissando(builder) { return builder(new GlissandoBuilder()).build(); }
exports.buildGlissando = buildGlissando;
class SlideBuilder {
    build;
    patch;
    text;
    type;
    number;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    fontFamily;
    fontWeight;
    fontStyle;
    fontSize;
    color;
    lineType;
    dashLength;
    spaceLength;
    accelerate;
    beats;
    firstBeat;
    lastBeat;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["type"]) ||
                childBuilders["type"] !== undefined ||
                updates.type !== undefined, "type is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Slide";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.text = (spec) => {
            updates["text"] = spec;
            delete childBuilders["text;"];
            modifiedKeys["text"] = true;
            return this;
        };
        this.type = (spec) => {
            updates["type"] = spec;
            delete childBuilders["type;"];
            modifiedKeys["type"] = true;
            return this;
        };
        this.number = (spec) => {
            updates["number"] = spec;
            delete childBuilders["number;"];
            modifiedKeys["number"] = true;
            return this;
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
        this.fontFamily = (spec) => {
            updates["fontFamily"] = spec;
            delete childBuilders["fontFamily;"];
            modifiedKeys["fontFamily"] = true;
            return this;
        };
        this.fontWeight = (spec) => {
            updates["fontWeight"] = spec;
            delete childBuilders["fontWeight;"];
            modifiedKeys["fontWeight"] = true;
            return this;
        };
        this.fontStyle = (spec) => {
            updates["fontStyle"] = spec;
            delete childBuilders["fontStyle;"];
            modifiedKeys["fontStyle"] = true;
            return this;
        };
        this.fontSize = (spec) => {
            updates["fontSize"] = spec;
            delete childBuilders["fontSize;"];
            modifiedKeys["fontSize"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
        this.lineType = (spec) => {
            updates["lineType"] = spec;
            delete childBuilders["lineType;"];
            modifiedKeys["lineType"] = true;
            return this;
        };
        this.dashLength = (spec) => {
            updates["dashLength"] = spec;
            delete childBuilders["dashLength;"];
            modifiedKeys["dashLength"] = true;
            return this;
        };
        this.spaceLength = (spec) => {
            updates["spaceLength"] = spec;
            delete childBuilders["spaceLength;"];
            modifiedKeys["spaceLength"] = true;
            return this;
        };
        this.accelerate = (spec) => {
            updates["accelerate"] = spec;
            delete childBuilders["accelerate;"];
            modifiedKeys["accelerate"] = true;
            return this;
        };
        this.beats = (spec) => {
            updates["beats"] = spec;
            delete childBuilders["beats;"];
            modifiedKeys["beats"] = true;
            return this;
        };
        this.firstBeat = (spec) => {
            updates["firstBeat"] = spec;
            delete childBuilders["firstBeat;"];
            modifiedKeys["firstBeat"] = true;
            return this;
        };
        this.lastBeat = (spec) => {
            updates["lastBeat"] = spec;
            delete childBuilders["lastBeat;"];
            modifiedKeys["lastBeat"] = true;
            return this;
        };
    }
}
function patchSlide(base, builder) { return builder(new SlideBuilder(base)).patch(); }
exports.patchSlide = patchSlide;
function buildSlide(builder) { return builder(new SlideBuilder()).build(); }
exports.buildSlide = buildSlide;
class OtherNotationBuilder {
    build;
    patch;
    type;
    data;
    number;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    fontFamily;
    fontWeight;
    fontStyle;
    fontSize;
    color;
    printObject;
    placement;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["type"]) ||
                childBuilders["type"] !== undefined ||
                updates.type !== undefined, "type is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "OtherNotation";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.type = (spec) => {
            updates["type"] = spec;
            delete childBuilders["type;"];
            modifiedKeys["type"] = true;
            return this;
        };
        this.data = (spec) => {
            updates["data"] = spec;
            delete childBuilders["data;"];
            modifiedKeys["data"] = true;
            return this;
        };
        this.number = (spec) => {
            updates["number"] = spec;
            delete childBuilders["number;"];
            modifiedKeys["number"] = true;
            return this;
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
        this.fontFamily = (spec) => {
            updates["fontFamily"] = spec;
            delete childBuilders["fontFamily;"];
            modifiedKeys["fontFamily"] = true;
            return this;
        };
        this.fontWeight = (spec) => {
            updates["fontWeight"] = spec;
            delete childBuilders["fontWeight;"];
            modifiedKeys["fontWeight"] = true;
            return this;
        };
        this.fontStyle = (spec) => {
            updates["fontStyle"] = spec;
            delete childBuilders["fontStyle;"];
            modifiedKeys["fontStyle"] = true;
            return this;
        };
        this.fontSize = (spec) => {
            updates["fontSize"] = spec;
            delete childBuilders["fontSize;"];
            modifiedKeys["fontSize"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
        this.printObject = (spec) => {
            updates["printObject"] = spec;
            delete childBuilders["printObject;"];
            modifiedKeys["printObject"] = true;
            return this;
        };
        this.placement = (spec) => {
            updates["placement"] = spec;
            delete childBuilders["placement;"];
            modifiedKeys["placement"] = true;
            return this;
        };
    }
}
function patchOtherNotation(base, builder) { return builder(new OtherNotationBuilder(base)).patch(); }
exports.patchOtherNotation = patchOtherNotation;
function buildOtherNotation(builder) { return builder(new OtherNotationBuilder()).build(); }
exports.buildOtherNotation = buildOtherNotation;
class OtherDirectionBuilder {
    build;
    patch;
    data;
    printObject;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    fontFamily;
    fontWeight;
    fontStyle;
    fontSize;
    color;
    halign;
    valign;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["data"]) ||
                childBuilders["data"] !== undefined ||
                updates.data !== undefined, "data is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "OtherDirection";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.data = (spec) => {
            updates["data"] = spec;
            delete childBuilders["data;"];
            modifiedKeys["data"] = true;
            return this;
        };
        this.printObject = (spec) => {
            updates["printObject"] = spec;
            delete childBuilders["printObject;"];
            modifiedKeys["printObject"] = true;
            return this;
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
        this.fontFamily = (spec) => {
            updates["fontFamily"] = spec;
            delete childBuilders["fontFamily;"];
            modifiedKeys["fontFamily"] = true;
            return this;
        };
        this.fontWeight = (spec) => {
            updates["fontWeight"] = spec;
            delete childBuilders["fontWeight;"];
            modifiedKeys["fontWeight"] = true;
            return this;
        };
        this.fontStyle = (spec) => {
            updates["fontStyle"] = spec;
            delete childBuilders["fontStyle;"];
            modifiedKeys["fontStyle"] = true;
            return this;
        };
        this.fontSize = (spec) => {
            updates["fontSize"] = spec;
            delete childBuilders["fontSize;"];
            modifiedKeys["fontSize"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
        this.halign = (spec) => {
            updates["halign"] = spec;
            delete childBuilders["halign;"];
            modifiedKeys["halign"] = true;
            return this;
        };
        this.valign = (spec) => {
            updates["valign"] = spec;
            delete childBuilders["valign;"];
            modifiedKeys["valign"] = true;
            return this;
        };
    }
}
function patchOtherDirection(base, builder) { return builder(new OtherDirectionBuilder(base)).patch(); }
exports.patchOtherDirection = patchOtherDirection;
function buildOtherDirection(builder) { return builder(new OtherDirectionBuilder()).build(); }
exports.buildOtherDirection = buildOtherDirection;
class OrnamentsBuilder {
    build;
    patch;
    delayedInvertedTurn;
    shake;
    turn;
    invertedTurn;
    otherOrnament;
    delayedTurn;
    verticalTurn;
    wavyLine;
    tremolo;
    accidentalMarksAt;
    accidentalMarksSplice;
    accidentalMarks;
    trillMark;
    mordent;
    invertedMordent;
    schleifer;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    fontFamily;
    fontWeight;
    fontStyle;
    fontSize;
    color;
    placement;
    startNote;
    accelerate;
    beats;
    lastBeat;
    trillStep;
    twoNoteTurn;
    secondBeat;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Ornaments";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.delayedInvertedTurn = (build) => {
            if (typeof build === 'function') {
                delete updates["delayedInvertedTurn"];
                const builder = build(new DelayedInvertedTurnBuilder(original && original["delayedInvertedTurn"]));
                if (!original)
                    updates["delayedInvertedTurn"] = builder.build();
                else
                    childBuilders["delayedInvertedTurn"] = builder;
            }
            else {
                updates.delayedInvertedTurn = build;
                delete childBuilders["delayedInvertedTurn;"];
            }
            modifiedKeys["delayedInvertedTurn"] = true;
            return this;
        };
        this.shake = (build) => {
            if (typeof build === 'function') {
                delete updates["shake"];
                const builder = build(new ShakeBuilder(original && original["shake"]));
                if (!original)
                    updates["shake"] = builder.build();
                else
                    childBuilders["shake"] = builder;
            }
            else {
                updates.shake = build;
                delete childBuilders["shake;"];
            }
            modifiedKeys["shake"] = true;
            return this;
        };
        this.turn = (build) => {
            if (typeof build === 'function') {
                delete updates["turn"];
                const builder = build(new TurnBuilder(original && original["turn"]));
                if (!original)
                    updates["turn"] = builder.build();
                else
                    childBuilders["turn"] = builder;
            }
            else {
                updates.turn = build;
                delete childBuilders["turn;"];
            }
            modifiedKeys["turn"] = true;
            return this;
        };
        this.invertedTurn = (build) => {
            if (typeof build === 'function') {
                delete updates["invertedTurn"];
                const builder = build(new InvertedTurnBuilder(original && original["invertedTurn"]));
                if (!original)
                    updates["invertedTurn"] = builder.build();
                else
                    childBuilders["invertedTurn"] = builder;
            }
            else {
                updates.invertedTurn = build;
                delete childBuilders["invertedTurn;"];
            }
            modifiedKeys["invertedTurn"] = true;
            return this;
        };
        this.otherOrnament = (build) => {
            if (typeof build === 'function') {
                delete updates["otherOrnament"];
                const builder = build(new OtherOrnamentBuilder(original && original["otherOrnament"]));
                if (!original)
                    updates["otherOrnament"] = builder.build();
                else
                    childBuilders["otherOrnament"] = builder;
            }
            else {
                updates.otherOrnament = build;
                delete childBuilders["otherOrnament;"];
            }
            modifiedKeys["otherOrnament"] = true;
            return this;
        };
        this.delayedTurn = (build) => {
            if (typeof build === 'function') {
                delete updates["delayedTurn"];
                const builder = build(new DelayedTurnBuilder(original && original["delayedTurn"]));
                if (!original)
                    updates["delayedTurn"] = builder.build();
                else
                    childBuilders["delayedTurn"] = builder;
            }
            else {
                updates.delayedTurn = build;
                delete childBuilders["delayedTurn;"];
            }
            modifiedKeys["delayedTurn"] = true;
            return this;
        };
        this.verticalTurn = (build) => {
            if (typeof build === 'function') {
                delete updates["verticalTurn"];
                const builder = build(new VerticalTurnBuilder(original && original["verticalTurn"]));
                if (!original)
                    updates["verticalTurn"] = builder.build();
                else
                    childBuilders["verticalTurn"] = builder;
            }
            else {
                updates.verticalTurn = build;
                delete childBuilders["verticalTurn;"];
            }
            modifiedKeys["verticalTurn"] = true;
            return this;
        };
        this.wavyLine = (build) => {
            if (typeof build === 'function') {
                delete updates["wavyLine"];
                const builder = build(new WavyLineBuilder(original && original["wavyLine"]));
                if (!original)
                    updates["wavyLine"] = builder.build();
                else
                    childBuilders["wavyLine"] = builder;
            }
            else {
                updates.wavyLine = build;
                delete childBuilders["wavyLine;"];
            }
            modifiedKeys["wavyLine"] = true;
            return this;
        };
        this.tremolo = (build) => {
            if (typeof build === 'function') {
                delete updates["tremolo"];
                const builder = build(new TremoloBuilder(original && original["tremolo"]));
                if (!original)
                    updates["tremolo"] = builder.build();
                else
                    childBuilders["tremolo"] = builder;
            }
            else {
                updates.tremolo = build;
                delete childBuilders["tremolo;"];
            }
            modifiedKeys["tremolo"] = true;
            return this;
        };
        this.accidentalMarks = (spec) => {
            updates["accidentalMarks"] = spec;
            delete childBuilders["accidentalMarks;"];
            modifiedKeys["accidentalMarks"] = true;
            return this;
        };
        this.accidentalMarksAt = (idx, build) => {
            makeReference("accidentalMarks");
            if (frozen["accidentalMarks"][idx]) {
                throw new Error("Patching accidentalMarks." + idx + " twice in a builder is unsupported.");
            }
            if (original && original._snapshot && original._snapshot["accidentalMarks"] && original._snapshot["accidentalMarks"][idx] && !original["accidentalMarks"][idx]) {
                // Clone snapshot.
                patches.push({ p: ["accidentalMarks", idx], li: original._snapshot["accidentalMarks"] });
            }
            if (typeof build === 'function' && reference["accidentalMarks"][idx]) {
                let patch = build(new AccidentalMarkBuilder(reference["accidentalMarks"][idx])).patch();
                patches = patches.concat(patch.map(patch => {
                    // TODO: detach?
                    patch.p = ["accidentalMarks", idx].concat(patch.p);
                    return patch;
                }));
                frozen["accidentalMarks"][idx] = true;
                return this;
            }
            let update = typeof build === 'function' ? build(new AccidentalMarkBuilder(reference["accidentalMarks"][idx])).build() : build;
            if (original) {
                patches.push({ p: ["accidentalMarks", idx], li: update });
            }
            else {
                updates["accidentalMarks"] = reference["accidentalMarks"]; // TODO: Merge?
            }
            reference["accidentalMarks"][idx] = update;
            frozen["accidentalMarks"][idx] = true;
            return this;
        };
        this.accidentalMarksSplice = (start, deleteCount, ...items) => {
            makeReference("accidentalMarks");
            let idx = start;
            if (original) {
                for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
                    if (frozen["accidentalMarks"][idx]) {
                        throw new Error("Replacing accidentalMarks." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["accidentalMarks"][idx];
                    patches.push({ p: ["accidentalMarks", idx], ld, li: items[idx - start] });
                    frozen["accidentalMarks"][idx] = true;
                }
                for (; idx < start + deleteCount; ++idx) {
                    if (frozen["accidentalMarks"][idx]) {
                        throw new Error("Removing accidentalMarks." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["accidentalMarks"][idx];
                    patches.push({ p: ["accidentalMarks", idx], ld });
                }
                for (; idx < start + items.length; ++idx) {
                    patches.push({ p: ["accidentalMarks", idx], li: items[idx - start] });
                    frozen["accidentalMarks"][idx] = true;
                }
            }
            reference["accidentalMarks"].splice(start, deleteCount, ...items);
            updates["accidentalMarks"] = reference["accidentalMarks"];
            frozen["accidentalMarks"].splice(start, deleteCount, ...items.map(i => true));
            return this;
        };
        this.trillMark = (build) => {
            if (typeof build === 'function') {
                delete updates["trillMark"];
                const builder = build(new TrillMarkBuilder(original && original["trillMark"]));
                if (!original)
                    updates["trillMark"] = builder.build();
                else
                    childBuilders["trillMark"] = builder;
            }
            else {
                updates.trillMark = build;
                delete childBuilders["trillMark;"];
            }
            modifiedKeys["trillMark"] = true;
            return this;
        };
        this.mordent = (build) => {
            if (typeof build === 'function') {
                delete updates["mordent"];
                const builder = build(new MordentBuilder(original && original["mordent"]));
                if (!original)
                    updates["mordent"] = builder.build();
                else
                    childBuilders["mordent"] = builder;
            }
            else {
                updates.mordent = build;
                delete childBuilders["mordent;"];
            }
            modifiedKeys["mordent"] = true;
            return this;
        };
        this.invertedMordent = (build) => {
            if (typeof build === 'function') {
                delete updates["invertedMordent"];
                const builder = build(new InvertedMordentBuilder(original && original["invertedMordent"]));
                if (!original)
                    updates["invertedMordent"] = builder.build();
                else
                    childBuilders["invertedMordent"] = builder;
            }
            else {
                updates.invertedMordent = build;
                delete childBuilders["invertedMordent;"];
            }
            modifiedKeys["invertedMordent"] = true;
            return this;
        };
        this.schleifer = (build) => {
            if (typeof build === 'function') {
                delete updates["schleifer"];
                const builder = build(new SchleiferBuilder(original && original["schleifer"]));
                if (!original)
                    updates["schleifer"] = builder.build();
                else
                    childBuilders["schleifer"] = builder;
            }
            else {
                updates.schleifer = build;
                delete childBuilders["schleifer;"];
            }
            modifiedKeys["schleifer"] = true;
            return this;
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
        this.fontFamily = (spec) => {
            updates["fontFamily"] = spec;
            delete childBuilders["fontFamily;"];
            modifiedKeys["fontFamily"] = true;
            return this;
        };
        this.fontWeight = (spec) => {
            updates["fontWeight"] = spec;
            delete childBuilders["fontWeight;"];
            modifiedKeys["fontWeight"] = true;
            return this;
        };
        this.fontStyle = (spec) => {
            updates["fontStyle"] = spec;
            delete childBuilders["fontStyle;"];
            modifiedKeys["fontStyle"] = true;
            return this;
        };
        this.fontSize = (spec) => {
            updates["fontSize"] = spec;
            delete childBuilders["fontSize;"];
            modifiedKeys["fontSize"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
        this.placement = (spec) => {
            updates["placement"] = spec;
            delete childBuilders["placement;"];
            modifiedKeys["placement"] = true;
            return this;
        };
        this.startNote = (spec) => {
            updates["startNote"] = spec;
            delete childBuilders["startNote;"];
            modifiedKeys["startNote"] = true;
            return this;
        };
        this.accelerate = (spec) => {
            updates["accelerate"] = spec;
            delete childBuilders["accelerate;"];
            modifiedKeys["accelerate"] = true;
            return this;
        };
        this.beats = (spec) => {
            updates["beats"] = spec;
            delete childBuilders["beats;"];
            modifiedKeys["beats"] = true;
            return this;
        };
        this.lastBeat = (spec) => {
            updates["lastBeat"] = spec;
            delete childBuilders["lastBeat;"];
            modifiedKeys["lastBeat"] = true;
            return this;
        };
        this.trillStep = (spec) => {
            updates["trillStep"] = spec;
            delete childBuilders["trillStep;"];
            modifiedKeys["trillStep"] = true;
            return this;
        };
        this.twoNoteTurn = (spec) => {
            updates["twoNoteTurn"] = spec;
            delete childBuilders["twoNoteTurn;"];
            modifiedKeys["twoNoteTurn"] = true;
            return this;
        };
        this.secondBeat = (spec) => {
            updates["secondBeat"] = spec;
            delete childBuilders["secondBeat;"];
            modifiedKeys["secondBeat"] = true;
            return this;
        };
    }
}
function patchOrnaments(base, builder) { return builder(new OrnamentsBuilder(base)).patch(); }
exports.patchOrnaments = patchOrnaments;
function buildOrnaments(builder) { return builder(new OrnamentsBuilder()).build(); }
exports.buildOrnaments = buildOrnaments;
class TrillMarkBuilder {
    build;
    patch;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    fontFamily;
    fontWeight;
    fontStyle;
    fontSize;
    color;
    placement;
    startNote;
    accelerate;
    beats;
    lastBeat;
    trillStep;
    twoNoteTurn;
    secondBeat;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "TrillMark";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
        this.fontFamily = (spec) => {
            updates["fontFamily"] = spec;
            delete childBuilders["fontFamily;"];
            modifiedKeys["fontFamily"] = true;
            return this;
        };
        this.fontWeight = (spec) => {
            updates["fontWeight"] = spec;
            delete childBuilders["fontWeight;"];
            modifiedKeys["fontWeight"] = true;
            return this;
        };
        this.fontStyle = (spec) => {
            updates["fontStyle"] = spec;
            delete childBuilders["fontStyle;"];
            modifiedKeys["fontStyle"] = true;
            return this;
        };
        this.fontSize = (spec) => {
            updates["fontSize"] = spec;
            delete childBuilders["fontSize;"];
            modifiedKeys["fontSize"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
        this.placement = (spec) => {
            updates["placement"] = spec;
            delete childBuilders["placement;"];
            modifiedKeys["placement"] = true;
            return this;
        };
        this.startNote = (spec) => {
            updates["startNote"] = spec;
            delete childBuilders["startNote;"];
            modifiedKeys["startNote"] = true;
            return this;
        };
        this.accelerate = (spec) => {
            updates["accelerate"] = spec;
            delete childBuilders["accelerate;"];
            modifiedKeys["accelerate"] = true;
            return this;
        };
        this.beats = (spec) => {
            updates["beats"] = spec;
            delete childBuilders["beats;"];
            modifiedKeys["beats"] = true;
            return this;
        };
        this.lastBeat = (spec) => {
            updates["lastBeat"] = spec;
            delete childBuilders["lastBeat;"];
            modifiedKeys["lastBeat"] = true;
            return this;
        };
        this.trillStep = (spec) => {
            updates["trillStep"] = spec;
            delete childBuilders["trillStep;"];
            modifiedKeys["trillStep"] = true;
            return this;
        };
        this.twoNoteTurn = (spec) => {
            updates["twoNoteTurn"] = spec;
            delete childBuilders["twoNoteTurn;"];
            modifiedKeys["twoNoteTurn"] = true;
            return this;
        };
        this.secondBeat = (spec) => {
            updates["secondBeat"] = spec;
            delete childBuilders["secondBeat;"];
            modifiedKeys["secondBeat"] = true;
            return this;
        };
    }
}
function patchTrillMark(base, builder) { return builder(new TrillMarkBuilder(base)).patch(); }
exports.patchTrillMark = patchTrillMark;
function buildTrillMark(builder) { return builder(new TrillMarkBuilder()).build(); }
exports.buildTrillMark = buildTrillMark;
class TurnBuilder {
    build;
    patch;
    slash;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    fontFamily;
    fontWeight;
    fontStyle;
    fontSize;
    color;
    placement;
    startNote;
    accelerate;
    beats;
    lastBeat;
    trillStep;
    twoNoteTurn;
    secondBeat;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Turn";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.slash = (spec) => {
            updates["slash"] = spec;
            delete childBuilders["slash;"];
            modifiedKeys["slash"] = true;
            return this;
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
        this.fontFamily = (spec) => {
            updates["fontFamily"] = spec;
            delete childBuilders["fontFamily;"];
            modifiedKeys["fontFamily"] = true;
            return this;
        };
        this.fontWeight = (spec) => {
            updates["fontWeight"] = spec;
            delete childBuilders["fontWeight;"];
            modifiedKeys["fontWeight"] = true;
            return this;
        };
        this.fontStyle = (spec) => {
            updates["fontStyle"] = spec;
            delete childBuilders["fontStyle;"];
            modifiedKeys["fontStyle"] = true;
            return this;
        };
        this.fontSize = (spec) => {
            updates["fontSize"] = spec;
            delete childBuilders["fontSize;"];
            modifiedKeys["fontSize"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
        this.placement = (spec) => {
            updates["placement"] = spec;
            delete childBuilders["placement;"];
            modifiedKeys["placement"] = true;
            return this;
        };
        this.startNote = (spec) => {
            updates["startNote"] = spec;
            delete childBuilders["startNote;"];
            modifiedKeys["startNote"] = true;
            return this;
        };
        this.accelerate = (spec) => {
            updates["accelerate"] = spec;
            delete childBuilders["accelerate;"];
            modifiedKeys["accelerate"] = true;
            return this;
        };
        this.beats = (spec) => {
            updates["beats"] = spec;
            delete childBuilders["beats;"];
            modifiedKeys["beats"] = true;
            return this;
        };
        this.lastBeat = (spec) => {
            updates["lastBeat"] = spec;
            delete childBuilders["lastBeat;"];
            modifiedKeys["lastBeat"] = true;
            return this;
        };
        this.trillStep = (spec) => {
            updates["trillStep"] = spec;
            delete childBuilders["trillStep;"];
            modifiedKeys["trillStep"] = true;
            return this;
        };
        this.twoNoteTurn = (spec) => {
            updates["twoNoteTurn"] = spec;
            delete childBuilders["twoNoteTurn;"];
            modifiedKeys["twoNoteTurn"] = true;
            return this;
        };
        this.secondBeat = (spec) => {
            updates["secondBeat"] = spec;
            delete childBuilders["secondBeat;"];
            modifiedKeys["secondBeat"] = true;
            return this;
        };
    }
}
function patchTurn(base, builder) { return builder(new TurnBuilder(base)).patch(); }
exports.patchTurn = patchTurn;
function buildTurn(builder) { return builder(new TurnBuilder()).build(); }
exports.buildTurn = buildTurn;
class DelayedTurnBuilder {
    build;
    patch;
    slash;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    fontFamily;
    fontWeight;
    fontStyle;
    fontSize;
    color;
    placement;
    startNote;
    accelerate;
    beats;
    lastBeat;
    trillStep;
    twoNoteTurn;
    secondBeat;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "DelayedTurn";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.slash = (spec) => {
            updates["slash"] = spec;
            delete childBuilders["slash;"];
            modifiedKeys["slash"] = true;
            return this;
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
        this.fontFamily = (spec) => {
            updates["fontFamily"] = spec;
            delete childBuilders["fontFamily;"];
            modifiedKeys["fontFamily"] = true;
            return this;
        };
        this.fontWeight = (spec) => {
            updates["fontWeight"] = spec;
            delete childBuilders["fontWeight;"];
            modifiedKeys["fontWeight"] = true;
            return this;
        };
        this.fontStyle = (spec) => {
            updates["fontStyle"] = spec;
            delete childBuilders["fontStyle;"];
            modifiedKeys["fontStyle"] = true;
            return this;
        };
        this.fontSize = (spec) => {
            updates["fontSize"] = spec;
            delete childBuilders["fontSize;"];
            modifiedKeys["fontSize"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
        this.placement = (spec) => {
            updates["placement"] = spec;
            delete childBuilders["placement;"];
            modifiedKeys["placement"] = true;
            return this;
        };
        this.startNote = (spec) => {
            updates["startNote"] = spec;
            delete childBuilders["startNote;"];
            modifiedKeys["startNote"] = true;
            return this;
        };
        this.accelerate = (spec) => {
            updates["accelerate"] = spec;
            delete childBuilders["accelerate;"];
            modifiedKeys["accelerate"] = true;
            return this;
        };
        this.beats = (spec) => {
            updates["beats"] = spec;
            delete childBuilders["beats;"];
            modifiedKeys["beats"] = true;
            return this;
        };
        this.lastBeat = (spec) => {
            updates["lastBeat"] = spec;
            delete childBuilders["lastBeat;"];
            modifiedKeys["lastBeat"] = true;
            return this;
        };
        this.trillStep = (spec) => {
            updates["trillStep"] = spec;
            delete childBuilders["trillStep;"];
            modifiedKeys["trillStep"] = true;
            return this;
        };
        this.twoNoteTurn = (spec) => {
            updates["twoNoteTurn"] = spec;
            delete childBuilders["twoNoteTurn;"];
            modifiedKeys["twoNoteTurn"] = true;
            return this;
        };
        this.secondBeat = (spec) => {
            updates["secondBeat"] = spec;
            delete childBuilders["secondBeat;"];
            modifiedKeys["secondBeat"] = true;
            return this;
        };
    }
}
function patchDelayedTurn(base, builder) { return builder(new DelayedTurnBuilder(base)).patch(); }
exports.patchDelayedTurn = patchDelayedTurn;
function buildDelayedTurn(builder) { return builder(new DelayedTurnBuilder()).build(); }
exports.buildDelayedTurn = buildDelayedTurn;
class InvertedTurnBuilder {
    build;
    patch;
    slash;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    fontFamily;
    fontWeight;
    fontStyle;
    fontSize;
    color;
    placement;
    startNote;
    accelerate;
    beats;
    lastBeat;
    trillStep;
    twoNoteTurn;
    secondBeat;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "InvertedTurn";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.slash = (spec) => {
            updates["slash"] = spec;
            delete childBuilders["slash;"];
            modifiedKeys["slash"] = true;
            return this;
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
        this.fontFamily = (spec) => {
            updates["fontFamily"] = spec;
            delete childBuilders["fontFamily;"];
            modifiedKeys["fontFamily"] = true;
            return this;
        };
        this.fontWeight = (spec) => {
            updates["fontWeight"] = spec;
            delete childBuilders["fontWeight;"];
            modifiedKeys["fontWeight"] = true;
            return this;
        };
        this.fontStyle = (spec) => {
            updates["fontStyle"] = spec;
            delete childBuilders["fontStyle;"];
            modifiedKeys["fontStyle"] = true;
            return this;
        };
        this.fontSize = (spec) => {
            updates["fontSize"] = spec;
            delete childBuilders["fontSize;"];
            modifiedKeys["fontSize"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
        this.placement = (spec) => {
            updates["placement"] = spec;
            delete childBuilders["placement;"];
            modifiedKeys["placement"] = true;
            return this;
        };
        this.startNote = (spec) => {
            updates["startNote"] = spec;
            delete childBuilders["startNote;"];
            modifiedKeys["startNote"] = true;
            return this;
        };
        this.accelerate = (spec) => {
            updates["accelerate"] = spec;
            delete childBuilders["accelerate;"];
            modifiedKeys["accelerate"] = true;
            return this;
        };
        this.beats = (spec) => {
            updates["beats"] = spec;
            delete childBuilders["beats;"];
            modifiedKeys["beats"] = true;
            return this;
        };
        this.lastBeat = (spec) => {
            updates["lastBeat"] = spec;
            delete childBuilders["lastBeat;"];
            modifiedKeys["lastBeat"] = true;
            return this;
        };
        this.trillStep = (spec) => {
            updates["trillStep"] = spec;
            delete childBuilders["trillStep;"];
            modifiedKeys["trillStep"] = true;
            return this;
        };
        this.twoNoteTurn = (spec) => {
            updates["twoNoteTurn"] = spec;
            delete childBuilders["twoNoteTurn;"];
            modifiedKeys["twoNoteTurn"] = true;
            return this;
        };
        this.secondBeat = (spec) => {
            updates["secondBeat"] = spec;
            delete childBuilders["secondBeat;"];
            modifiedKeys["secondBeat"] = true;
            return this;
        };
    }
}
function patchInvertedTurn(base, builder) { return builder(new InvertedTurnBuilder(base)).patch(); }
exports.patchInvertedTurn = patchInvertedTurn;
function buildInvertedTurn(builder) { return builder(new InvertedTurnBuilder()).build(); }
exports.buildInvertedTurn = buildInvertedTurn;
class DelayedInvertedTurnBuilder {
    build;
    patch;
    slash;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    fontFamily;
    fontWeight;
    fontStyle;
    fontSize;
    color;
    placement;
    startNote;
    accelerate;
    beats;
    lastBeat;
    trillStep;
    twoNoteTurn;
    secondBeat;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "DelayedInvertedTurn";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.slash = (spec) => {
            updates["slash"] = spec;
            delete childBuilders["slash;"];
            modifiedKeys["slash"] = true;
            return this;
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
        this.fontFamily = (spec) => {
            updates["fontFamily"] = spec;
            delete childBuilders["fontFamily;"];
            modifiedKeys["fontFamily"] = true;
            return this;
        };
        this.fontWeight = (spec) => {
            updates["fontWeight"] = spec;
            delete childBuilders["fontWeight;"];
            modifiedKeys["fontWeight"] = true;
            return this;
        };
        this.fontStyle = (spec) => {
            updates["fontStyle"] = spec;
            delete childBuilders["fontStyle;"];
            modifiedKeys["fontStyle"] = true;
            return this;
        };
        this.fontSize = (spec) => {
            updates["fontSize"] = spec;
            delete childBuilders["fontSize;"];
            modifiedKeys["fontSize"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
        this.placement = (spec) => {
            updates["placement"] = spec;
            delete childBuilders["placement;"];
            modifiedKeys["placement"] = true;
            return this;
        };
        this.startNote = (spec) => {
            updates["startNote"] = spec;
            delete childBuilders["startNote;"];
            modifiedKeys["startNote"] = true;
            return this;
        };
        this.accelerate = (spec) => {
            updates["accelerate"] = spec;
            delete childBuilders["accelerate;"];
            modifiedKeys["accelerate"] = true;
            return this;
        };
        this.beats = (spec) => {
            updates["beats"] = spec;
            delete childBuilders["beats;"];
            modifiedKeys["beats"] = true;
            return this;
        };
        this.lastBeat = (spec) => {
            updates["lastBeat"] = spec;
            delete childBuilders["lastBeat;"];
            modifiedKeys["lastBeat"] = true;
            return this;
        };
        this.trillStep = (spec) => {
            updates["trillStep"] = spec;
            delete childBuilders["trillStep;"];
            modifiedKeys["trillStep"] = true;
            return this;
        };
        this.twoNoteTurn = (spec) => {
            updates["twoNoteTurn"] = spec;
            delete childBuilders["twoNoteTurn;"];
            modifiedKeys["twoNoteTurn"] = true;
            return this;
        };
        this.secondBeat = (spec) => {
            updates["secondBeat"] = spec;
            delete childBuilders["secondBeat;"];
            modifiedKeys["secondBeat"] = true;
            return this;
        };
    }
}
function patchDelayedInvertedTurn(base, builder) { return builder(new DelayedInvertedTurnBuilder(base)).patch(); }
exports.patchDelayedInvertedTurn = patchDelayedInvertedTurn;
function buildDelayedInvertedTurn(builder) { return builder(new DelayedInvertedTurnBuilder()).build(); }
exports.buildDelayedInvertedTurn = buildDelayedInvertedTurn;
class VerticalTurnBuilder {
    build;
    patch;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    fontFamily;
    fontWeight;
    fontStyle;
    fontSize;
    color;
    placement;
    startNote;
    accelerate;
    beats;
    lastBeat;
    trillStep;
    twoNoteTurn;
    secondBeat;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "VerticalTurn";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
        this.fontFamily = (spec) => {
            updates["fontFamily"] = spec;
            delete childBuilders["fontFamily;"];
            modifiedKeys["fontFamily"] = true;
            return this;
        };
        this.fontWeight = (spec) => {
            updates["fontWeight"] = spec;
            delete childBuilders["fontWeight;"];
            modifiedKeys["fontWeight"] = true;
            return this;
        };
        this.fontStyle = (spec) => {
            updates["fontStyle"] = spec;
            delete childBuilders["fontStyle;"];
            modifiedKeys["fontStyle"] = true;
            return this;
        };
        this.fontSize = (spec) => {
            updates["fontSize"] = spec;
            delete childBuilders["fontSize;"];
            modifiedKeys["fontSize"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
        this.placement = (spec) => {
            updates["placement"] = spec;
            delete childBuilders["placement;"];
            modifiedKeys["placement"] = true;
            return this;
        };
        this.startNote = (spec) => {
            updates["startNote"] = spec;
            delete childBuilders["startNote;"];
            modifiedKeys["startNote"] = true;
            return this;
        };
        this.accelerate = (spec) => {
            updates["accelerate"] = spec;
            delete childBuilders["accelerate;"];
            modifiedKeys["accelerate"] = true;
            return this;
        };
        this.beats = (spec) => {
            updates["beats"] = spec;
            delete childBuilders["beats;"];
            modifiedKeys["beats"] = true;
            return this;
        };
        this.lastBeat = (spec) => {
            updates["lastBeat"] = spec;
            delete childBuilders["lastBeat;"];
            modifiedKeys["lastBeat"] = true;
            return this;
        };
        this.trillStep = (spec) => {
            updates["trillStep"] = spec;
            delete childBuilders["trillStep;"];
            modifiedKeys["trillStep"] = true;
            return this;
        };
        this.twoNoteTurn = (spec) => {
            updates["twoNoteTurn"] = spec;
            delete childBuilders["twoNoteTurn;"];
            modifiedKeys["twoNoteTurn"] = true;
            return this;
        };
        this.secondBeat = (spec) => {
            updates["secondBeat"] = spec;
            delete childBuilders["secondBeat;"];
            modifiedKeys["secondBeat"] = true;
            return this;
        };
    }
}
function patchVerticalTurn(base, builder) { return builder(new VerticalTurnBuilder(base)).patch(); }
exports.patchVerticalTurn = patchVerticalTurn;
function buildVerticalTurn(builder) { return builder(new VerticalTurnBuilder()).build(); }
exports.buildVerticalTurn = buildVerticalTurn;
class ShakeBuilder {
    build;
    patch;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    fontFamily;
    fontWeight;
    fontStyle;
    fontSize;
    color;
    placement;
    startNote;
    accelerate;
    beats;
    lastBeat;
    trillStep;
    twoNoteTurn;
    secondBeat;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Shake";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
        this.fontFamily = (spec) => {
            updates["fontFamily"] = spec;
            delete childBuilders["fontFamily;"];
            modifiedKeys["fontFamily"] = true;
            return this;
        };
        this.fontWeight = (spec) => {
            updates["fontWeight"] = spec;
            delete childBuilders["fontWeight;"];
            modifiedKeys["fontWeight"] = true;
            return this;
        };
        this.fontStyle = (spec) => {
            updates["fontStyle"] = spec;
            delete childBuilders["fontStyle;"];
            modifiedKeys["fontStyle"] = true;
            return this;
        };
        this.fontSize = (spec) => {
            updates["fontSize"] = spec;
            delete childBuilders["fontSize;"];
            modifiedKeys["fontSize"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
        this.placement = (spec) => {
            updates["placement"] = spec;
            delete childBuilders["placement;"];
            modifiedKeys["placement"] = true;
            return this;
        };
        this.startNote = (spec) => {
            updates["startNote"] = spec;
            delete childBuilders["startNote;"];
            modifiedKeys["startNote"] = true;
            return this;
        };
        this.accelerate = (spec) => {
            updates["accelerate"] = spec;
            delete childBuilders["accelerate;"];
            modifiedKeys["accelerate"] = true;
            return this;
        };
        this.beats = (spec) => {
            updates["beats"] = spec;
            delete childBuilders["beats;"];
            modifiedKeys["beats"] = true;
            return this;
        };
        this.lastBeat = (spec) => {
            updates["lastBeat"] = spec;
            delete childBuilders["lastBeat;"];
            modifiedKeys["lastBeat"] = true;
            return this;
        };
        this.trillStep = (spec) => {
            updates["trillStep"] = spec;
            delete childBuilders["trillStep;"];
            modifiedKeys["trillStep"] = true;
            return this;
        };
        this.twoNoteTurn = (spec) => {
            updates["twoNoteTurn"] = spec;
            delete childBuilders["twoNoteTurn;"];
            modifiedKeys["twoNoteTurn"] = true;
            return this;
        };
        this.secondBeat = (spec) => {
            updates["secondBeat"] = spec;
            delete childBuilders["secondBeat;"];
            modifiedKeys["secondBeat"] = true;
            return this;
        };
    }
}
function patchShake(base, builder) { return builder(new ShakeBuilder(base)).patch(); }
exports.patchShake = patchShake;
function buildShake(builder) { return builder(new ShakeBuilder()).build(); }
exports.buildShake = buildShake;
class MordentBuilder {
    build;
    patch;
    long;
    approach;
    departure;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    fontFamily;
    fontWeight;
    fontStyle;
    fontSize;
    color;
    placement;
    startNote;
    accelerate;
    beats;
    lastBeat;
    trillStep;
    twoNoteTurn;
    secondBeat;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Mordent";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.long = (spec) => {
            updates["long"] = spec;
            delete childBuilders["long;"];
            modifiedKeys["long"] = true;
            return this;
        };
        this.approach = (spec) => {
            updates["approach"] = spec;
            delete childBuilders["approach;"];
            modifiedKeys["approach"] = true;
            return this;
        };
        this.departure = (spec) => {
            updates["departure"] = spec;
            delete childBuilders["departure;"];
            modifiedKeys["departure"] = true;
            return this;
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
        this.fontFamily = (spec) => {
            updates["fontFamily"] = spec;
            delete childBuilders["fontFamily;"];
            modifiedKeys["fontFamily"] = true;
            return this;
        };
        this.fontWeight = (spec) => {
            updates["fontWeight"] = spec;
            delete childBuilders["fontWeight;"];
            modifiedKeys["fontWeight"] = true;
            return this;
        };
        this.fontStyle = (spec) => {
            updates["fontStyle"] = spec;
            delete childBuilders["fontStyle;"];
            modifiedKeys["fontStyle"] = true;
            return this;
        };
        this.fontSize = (spec) => {
            updates["fontSize"] = spec;
            delete childBuilders["fontSize;"];
            modifiedKeys["fontSize"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
        this.placement = (spec) => {
            updates["placement"] = spec;
            delete childBuilders["placement;"];
            modifiedKeys["placement"] = true;
            return this;
        };
        this.startNote = (spec) => {
            updates["startNote"] = spec;
            delete childBuilders["startNote;"];
            modifiedKeys["startNote"] = true;
            return this;
        };
        this.accelerate = (spec) => {
            updates["accelerate"] = spec;
            delete childBuilders["accelerate;"];
            modifiedKeys["accelerate"] = true;
            return this;
        };
        this.beats = (spec) => {
            updates["beats"] = spec;
            delete childBuilders["beats;"];
            modifiedKeys["beats"] = true;
            return this;
        };
        this.lastBeat = (spec) => {
            updates["lastBeat"] = spec;
            delete childBuilders["lastBeat;"];
            modifiedKeys["lastBeat"] = true;
            return this;
        };
        this.trillStep = (spec) => {
            updates["trillStep"] = spec;
            delete childBuilders["trillStep;"];
            modifiedKeys["trillStep"] = true;
            return this;
        };
        this.twoNoteTurn = (spec) => {
            updates["twoNoteTurn"] = spec;
            delete childBuilders["twoNoteTurn;"];
            modifiedKeys["twoNoteTurn"] = true;
            return this;
        };
        this.secondBeat = (spec) => {
            updates["secondBeat"] = spec;
            delete childBuilders["secondBeat;"];
            modifiedKeys["secondBeat"] = true;
            return this;
        };
    }
}
function patchMordent(base, builder) { return builder(new MordentBuilder(base)).patch(); }
exports.patchMordent = patchMordent;
function buildMordent(builder) { return builder(new MordentBuilder()).build(); }
exports.buildMordent = buildMordent;
class InvertedMordentBuilder {
    build;
    patch;
    long;
    approach;
    departure;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    fontFamily;
    fontWeight;
    fontStyle;
    fontSize;
    color;
    placement;
    startNote;
    accelerate;
    beats;
    lastBeat;
    trillStep;
    twoNoteTurn;
    secondBeat;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "InvertedMordent";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.long = (spec) => {
            updates["long"] = spec;
            delete childBuilders["long;"];
            modifiedKeys["long"] = true;
            return this;
        };
        this.approach = (spec) => {
            updates["approach"] = spec;
            delete childBuilders["approach;"];
            modifiedKeys["approach"] = true;
            return this;
        };
        this.departure = (spec) => {
            updates["departure"] = spec;
            delete childBuilders["departure;"];
            modifiedKeys["departure"] = true;
            return this;
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
        this.fontFamily = (spec) => {
            updates["fontFamily"] = spec;
            delete childBuilders["fontFamily;"];
            modifiedKeys["fontFamily"] = true;
            return this;
        };
        this.fontWeight = (spec) => {
            updates["fontWeight"] = spec;
            delete childBuilders["fontWeight;"];
            modifiedKeys["fontWeight"] = true;
            return this;
        };
        this.fontStyle = (spec) => {
            updates["fontStyle"] = spec;
            delete childBuilders["fontStyle;"];
            modifiedKeys["fontStyle"] = true;
            return this;
        };
        this.fontSize = (spec) => {
            updates["fontSize"] = spec;
            delete childBuilders["fontSize;"];
            modifiedKeys["fontSize"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
        this.placement = (spec) => {
            updates["placement"] = spec;
            delete childBuilders["placement;"];
            modifiedKeys["placement"] = true;
            return this;
        };
        this.startNote = (spec) => {
            updates["startNote"] = spec;
            delete childBuilders["startNote;"];
            modifiedKeys["startNote"] = true;
            return this;
        };
        this.accelerate = (spec) => {
            updates["accelerate"] = spec;
            delete childBuilders["accelerate;"];
            modifiedKeys["accelerate"] = true;
            return this;
        };
        this.beats = (spec) => {
            updates["beats"] = spec;
            delete childBuilders["beats;"];
            modifiedKeys["beats"] = true;
            return this;
        };
        this.lastBeat = (spec) => {
            updates["lastBeat"] = spec;
            delete childBuilders["lastBeat;"];
            modifiedKeys["lastBeat"] = true;
            return this;
        };
        this.trillStep = (spec) => {
            updates["trillStep"] = spec;
            delete childBuilders["trillStep;"];
            modifiedKeys["trillStep"] = true;
            return this;
        };
        this.twoNoteTurn = (spec) => {
            updates["twoNoteTurn"] = spec;
            delete childBuilders["twoNoteTurn;"];
            modifiedKeys["twoNoteTurn"] = true;
            return this;
        };
        this.secondBeat = (spec) => {
            updates["secondBeat"] = spec;
            delete childBuilders["secondBeat;"];
            modifiedKeys["secondBeat"] = true;
            return this;
        };
    }
}
function patchInvertedMordent(base, builder) { return builder(new InvertedMordentBuilder(base)).patch(); }
exports.patchInvertedMordent = patchInvertedMordent;
function buildInvertedMordent(builder) { return builder(new InvertedMordentBuilder()).build(); }
exports.buildInvertedMordent = buildInvertedMordent;
class SchleiferBuilder {
    build;
    patch;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    fontFamily;
    fontWeight;
    fontStyle;
    fontSize;
    color;
    placement;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Schleifer";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
        this.fontFamily = (spec) => {
            updates["fontFamily"] = spec;
            delete childBuilders["fontFamily;"];
            modifiedKeys["fontFamily"] = true;
            return this;
        };
        this.fontWeight = (spec) => {
            updates["fontWeight"] = spec;
            delete childBuilders["fontWeight;"];
            modifiedKeys["fontWeight"] = true;
            return this;
        };
        this.fontStyle = (spec) => {
            updates["fontStyle"] = spec;
            delete childBuilders["fontStyle;"];
            modifiedKeys["fontStyle"] = true;
            return this;
        };
        this.fontSize = (spec) => {
            updates["fontSize"] = spec;
            delete childBuilders["fontSize;"];
            modifiedKeys["fontSize"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
        this.placement = (spec) => {
            updates["placement"] = spec;
            delete childBuilders["placement;"];
            modifiedKeys["placement"] = true;
            return this;
        };
    }
}
function patchSchleifer(base, builder) { return builder(new SchleiferBuilder(base)).patch(); }
exports.patchSchleifer = patchSchleifer;
function buildSchleifer(builder) { return builder(new SchleiferBuilder()).build(); }
exports.buildSchleifer = buildSchleifer;
class TremoloBuilder {
    build;
    patch;
    data;
    type;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    fontFamily;
    fontWeight;
    fontStyle;
    fontSize;
    color;
    placement;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["type"]) ||
                childBuilders["type"] !== undefined ||
                updates.type !== undefined, "type is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Tremolo";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.data = (spec) => {
            updates["data"] = spec;
            delete childBuilders["data;"];
            modifiedKeys["data"] = true;
            return this;
        };
        this.type = (spec) => {
            updates["type"] = spec;
            delete childBuilders["type;"];
            modifiedKeys["type"] = true;
            return this;
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
        this.fontFamily = (spec) => {
            updates["fontFamily"] = spec;
            delete childBuilders["fontFamily;"];
            modifiedKeys["fontFamily"] = true;
            return this;
        };
        this.fontWeight = (spec) => {
            updates["fontWeight"] = spec;
            delete childBuilders["fontWeight;"];
            modifiedKeys["fontWeight"] = true;
            return this;
        };
        this.fontStyle = (spec) => {
            updates["fontStyle"] = spec;
            delete childBuilders["fontStyle;"];
            modifiedKeys["fontStyle"] = true;
            return this;
        };
        this.fontSize = (spec) => {
            updates["fontSize"] = spec;
            delete childBuilders["fontSize;"];
            modifiedKeys["fontSize"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
        this.placement = (spec) => {
            updates["placement"] = spec;
            delete childBuilders["placement;"];
            modifiedKeys["placement"] = true;
            return this;
        };
    }
}
function patchTremolo(base, builder) { return builder(new TremoloBuilder(base)).patch(); }
exports.patchTremolo = patchTremolo;
function buildTremolo(builder) { return builder(new TremoloBuilder()).build(); }
exports.buildTremolo = buildTremolo;
class OtherOrnamentBuilder {
    build;
    patch;
    type;
    data;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    fontFamily;
    fontWeight;
    fontStyle;
    fontSize;
    color;
    placement;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["type"]) ||
                childBuilders["type"] !== undefined ||
                updates.type !== undefined, "type is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "OtherOrnament";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.type = (spec) => {
            updates["type"] = spec;
            delete childBuilders["type;"];
            modifiedKeys["type"] = true;
            return this;
        };
        this.data = (spec) => {
            updates["data"] = spec;
            delete childBuilders["data;"];
            modifiedKeys["data"] = true;
            return this;
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
        this.fontFamily = (spec) => {
            updates["fontFamily"] = spec;
            delete childBuilders["fontFamily;"];
            modifiedKeys["fontFamily"] = true;
            return this;
        };
        this.fontWeight = (spec) => {
            updates["fontWeight"] = spec;
            delete childBuilders["fontWeight;"];
            modifiedKeys["fontWeight"] = true;
            return this;
        };
        this.fontStyle = (spec) => {
            updates["fontStyle"] = spec;
            delete childBuilders["fontStyle;"];
            modifiedKeys["fontStyle"] = true;
            return this;
        };
        this.fontSize = (spec) => {
            updates["fontSize"] = spec;
            delete childBuilders["fontSize;"];
            modifiedKeys["fontSize"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
        this.placement = (spec) => {
            updates["placement"] = spec;
            delete childBuilders["placement;"];
            modifiedKeys["placement"] = true;
            return this;
        };
    }
}
function patchOtherOrnament(base, builder) { return builder(new OtherOrnamentBuilder(base)).patch(); }
exports.patchOtherOrnament = patchOtherOrnament;
function buildOtherOrnament(builder) { return builder(new OtherOrnamentBuilder()).build(); }
exports.buildOtherOrnament = buildOtherOrnament;
class AccidentalMarkBuilder {
    build;
    patch;
    mark;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    fontFamily;
    fontWeight;
    fontStyle;
    fontSize;
    color;
    placement;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["mark"]) ||
                childBuilders["mark"] !== undefined ||
                updates.mark !== undefined, "mark is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "AccidentalMark";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.mark = (spec) => {
            updates["mark"] = spec;
            delete childBuilders["mark;"];
            modifiedKeys["mark"] = true;
            return this;
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
        this.fontFamily = (spec) => {
            updates["fontFamily"] = spec;
            delete childBuilders["fontFamily;"];
            modifiedKeys["fontFamily"] = true;
            return this;
        };
        this.fontWeight = (spec) => {
            updates["fontWeight"] = spec;
            delete childBuilders["fontWeight;"];
            modifiedKeys["fontWeight"] = true;
            return this;
        };
        this.fontStyle = (spec) => {
            updates["fontStyle"] = spec;
            delete childBuilders["fontStyle;"];
            modifiedKeys["fontStyle"] = true;
            return this;
        };
        this.fontSize = (spec) => {
            updates["fontSize"] = spec;
            delete childBuilders["fontSize;"];
            modifiedKeys["fontSize"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
        this.placement = (spec) => {
            updates["placement"] = spec;
            delete childBuilders["placement;"];
            modifiedKeys["placement"] = true;
            return this;
        };
    }
}
function patchAccidentalMark(base, builder) { return builder(new AccidentalMarkBuilder(base)).patch(); }
exports.patchAccidentalMark = patchAccidentalMark;
function buildAccidentalMark(builder) { return builder(new AccidentalMarkBuilder()).build(); }
exports.buildAccidentalMark = buildAccidentalMark;
class TechnicalBuilder {
    build;
    patch;
    tripleTongue;
    toe;
    hole;
    hammerOn;
    upBow;
    downBow;
    fret;
    tap;
    pullOff;
    handbell;
    bend;
    thumbPosition;
    stopped;
    pluck;
    doubleTongue;
    string;
    openString;
    fingernails;
    arrow;
    harmonic;
    heel;
    otherTechnical;
    snapPizzicato;
    fingering;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Technical";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.tripleTongue = (build) => {
            if (typeof build === 'function') {
                delete updates["tripleTongue"];
                const builder = build(new TripleTongueBuilder(original && original["tripleTongue"]));
                if (!original)
                    updates["tripleTongue"] = builder.build();
                else
                    childBuilders["tripleTongue"] = builder;
            }
            else {
                updates.tripleTongue = build;
                delete childBuilders["tripleTongue;"];
            }
            modifiedKeys["tripleTongue"] = true;
            return this;
        };
        this.toe = (build) => {
            if (typeof build === 'function') {
                delete updates["toe"];
                const builder = build(new ToeBuilder(original && original["toe"]));
                if (!original)
                    updates["toe"] = builder.build();
                else
                    childBuilders["toe"] = builder;
            }
            else {
                updates.toe = build;
                delete childBuilders["toe;"];
            }
            modifiedKeys["toe"] = true;
            return this;
        };
        this.hole = (build) => {
            if (typeof build === 'function') {
                delete updates["hole"];
                const builder = build(new HoleBuilder(original && original["hole"]));
                if (!original)
                    updates["hole"] = builder.build();
                else
                    childBuilders["hole"] = builder;
            }
            else {
                updates.hole = build;
                delete childBuilders["hole;"];
            }
            modifiedKeys["hole"] = true;
            return this;
        };
        this.hammerOn = (build) => {
            if (typeof build === 'function') {
                delete updates["hammerOn"];
                const builder = build(new HammerOnBuilder(original && original["hammerOn"]));
                if (!original)
                    updates["hammerOn"] = builder.build();
                else
                    childBuilders["hammerOn"] = builder;
            }
            else {
                updates.hammerOn = build;
                delete childBuilders["hammerOn;"];
            }
            modifiedKeys["hammerOn"] = true;
            return this;
        };
        this.upBow = (build) => {
            if (typeof build === 'function') {
                delete updates["upBow"];
                const builder = build(new UpBowBuilder(original && original["upBow"]));
                if (!original)
                    updates["upBow"] = builder.build();
                else
                    childBuilders["upBow"] = builder;
            }
            else {
                updates.upBow = build;
                delete childBuilders["upBow;"];
            }
            modifiedKeys["upBow"] = true;
            return this;
        };
        this.downBow = (build) => {
            if (typeof build === 'function') {
                delete updates["downBow"];
                const builder = build(new DownBowBuilder(original && original["downBow"]));
                if (!original)
                    updates["downBow"] = builder.build();
                else
                    childBuilders["downBow"] = builder;
            }
            else {
                updates.downBow = build;
                delete childBuilders["downBow;"];
            }
            modifiedKeys["downBow"] = true;
            return this;
        };
        this.fret = (build) => {
            if (typeof build === 'function') {
                delete updates["fret"];
                const builder = build(new FretBuilder(original && original["fret"]));
                if (!original)
                    updates["fret"] = builder.build();
                else
                    childBuilders["fret"] = builder;
            }
            else {
                updates.fret = build;
                delete childBuilders["fret;"];
            }
            modifiedKeys["fret"] = true;
            return this;
        };
        this.tap = (build) => {
            if (typeof build === 'function') {
                delete updates["tap"];
                const builder = build(new TapBuilder(original && original["tap"]));
                if (!original)
                    updates["tap"] = builder.build();
                else
                    childBuilders["tap"] = builder;
            }
            else {
                updates.tap = build;
                delete childBuilders["tap;"];
            }
            modifiedKeys["tap"] = true;
            return this;
        };
        this.pullOff = (build) => {
            if (typeof build === 'function') {
                delete updates["pullOff"];
                const builder = build(new PullOffBuilder(original && original["pullOff"]));
                if (!original)
                    updates["pullOff"] = builder.build();
                else
                    childBuilders["pullOff"] = builder;
            }
            else {
                updates.pullOff = build;
                delete childBuilders["pullOff;"];
            }
            modifiedKeys["pullOff"] = true;
            return this;
        };
        this.handbell = (build) => {
            if (typeof build === 'function') {
                delete updates["handbell"];
                const builder = build(new HandbellBuilder(original && original["handbell"]));
                if (!original)
                    updates["handbell"] = builder.build();
                else
                    childBuilders["handbell"] = builder;
            }
            else {
                updates.handbell = build;
                delete childBuilders["handbell;"];
            }
            modifiedKeys["handbell"] = true;
            return this;
        };
        this.bend = (build) => {
            if (typeof build === 'function') {
                delete updates["bend"];
                const builder = build(new BendBuilder(original && original["bend"]));
                if (!original)
                    updates["bend"] = builder.build();
                else
                    childBuilders["bend"] = builder;
            }
            else {
                updates.bend = build;
                delete childBuilders["bend;"];
            }
            modifiedKeys["bend"] = true;
            return this;
        };
        this.thumbPosition = (build) => {
            if (typeof build === 'function') {
                delete updates["thumbPosition"];
                const builder = build(new ThumbPositionBuilder(original && original["thumbPosition"]));
                if (!original)
                    updates["thumbPosition"] = builder.build();
                else
                    childBuilders["thumbPosition"] = builder;
            }
            else {
                updates.thumbPosition = build;
                delete childBuilders["thumbPosition;"];
            }
            modifiedKeys["thumbPosition"] = true;
            return this;
        };
        this.stopped = (build) => {
            if (typeof build === 'function') {
                delete updates["stopped"];
                const builder = build(new StoppedBuilder(original && original["stopped"]));
                if (!original)
                    updates["stopped"] = builder.build();
                else
                    childBuilders["stopped"] = builder;
            }
            else {
                updates.stopped = build;
                delete childBuilders["stopped;"];
            }
            modifiedKeys["stopped"] = true;
            return this;
        };
        this.pluck = (build) => {
            if (typeof build === 'function') {
                delete updates["pluck"];
                const builder = build(new PluckBuilder(original && original["pluck"]));
                if (!original)
                    updates["pluck"] = builder.build();
                else
                    childBuilders["pluck"] = builder;
            }
            else {
                updates.pluck = build;
                delete childBuilders["pluck;"];
            }
            modifiedKeys["pluck"] = true;
            return this;
        };
        this.doubleTongue = (build) => {
            if (typeof build === 'function') {
                delete updates["doubleTongue"];
                const builder = build(new DoubleTongueBuilder(original && original["doubleTongue"]));
                if (!original)
                    updates["doubleTongue"] = builder.build();
                else
                    childBuilders["doubleTongue"] = builder;
            }
            else {
                updates.doubleTongue = build;
                delete childBuilders["doubleTongue;"];
            }
            modifiedKeys["doubleTongue"] = true;
            return this;
        };
        this.string = (build) => {
            if (typeof build === 'function') {
                delete updates["string"];
                const builder = build(new StringBuilder(original && original["string"]));
                if (!original)
                    updates["string"] = builder.build();
                else
                    childBuilders["string"] = builder;
            }
            else {
                updates.string = build;
                delete childBuilders["string;"];
            }
            modifiedKeys["string"] = true;
            return this;
        };
        this.openString = (build) => {
            if (typeof build === 'function') {
                delete updates["openString"];
                const builder = build(new OpenStringBuilder(original && original["openString"]));
                if (!original)
                    updates["openString"] = builder.build();
                else
                    childBuilders["openString"] = builder;
            }
            else {
                updates.openString = build;
                delete childBuilders["openString;"];
            }
            modifiedKeys["openString"] = true;
            return this;
        };
        this.fingernails = (build) => {
            if (typeof build === 'function') {
                delete updates["fingernails"];
                const builder = build(new FingernailsBuilder(original && original["fingernails"]));
                if (!original)
                    updates["fingernails"] = builder.build();
                else
                    childBuilders["fingernails"] = builder;
            }
            else {
                updates.fingernails = build;
                delete childBuilders["fingernails;"];
            }
            modifiedKeys["fingernails"] = true;
            return this;
        };
        this.arrow = (build) => {
            if (typeof build === 'function') {
                delete updates["arrow"];
                const builder = build(new ArrowBuilder(original && original["arrow"]));
                if (!original)
                    updates["arrow"] = builder.build();
                else
                    childBuilders["arrow"] = builder;
            }
            else {
                updates.arrow = build;
                delete childBuilders["arrow;"];
            }
            modifiedKeys["arrow"] = true;
            return this;
        };
        this.harmonic = (build) => {
            if (typeof build === 'function') {
                delete updates["harmonic"];
                const builder = build(new HarmonicBuilder(original && original["harmonic"]));
                if (!original)
                    updates["harmonic"] = builder.build();
                else
                    childBuilders["harmonic"] = builder;
            }
            else {
                updates.harmonic = build;
                delete childBuilders["harmonic;"];
            }
            modifiedKeys["harmonic"] = true;
            return this;
        };
        this.heel = (build) => {
            if (typeof build === 'function') {
                delete updates["heel"];
                const builder = build(new HeelBuilder(original && original["heel"]));
                if (!original)
                    updates["heel"] = builder.build();
                else
                    childBuilders["heel"] = builder;
            }
            else {
                updates.heel = build;
                delete childBuilders["heel;"];
            }
            modifiedKeys["heel"] = true;
            return this;
        };
        this.otherTechnical = (build) => {
            if (typeof build === 'function') {
                delete updates["otherTechnical"];
                const builder = build(new OtherTechnicalBuilder(original && original["otherTechnical"]));
                if (!original)
                    updates["otherTechnical"] = builder.build();
                else
                    childBuilders["otherTechnical"] = builder;
            }
            else {
                updates.otherTechnical = build;
                delete childBuilders["otherTechnical;"];
            }
            modifiedKeys["otherTechnical"] = true;
            return this;
        };
        this.snapPizzicato = (build) => {
            if (typeof build === 'function') {
                delete updates["snapPizzicato"];
                const builder = build(new SnapPizzicatoBuilder(original && original["snapPizzicato"]));
                if (!original)
                    updates["snapPizzicato"] = builder.build();
                else
                    childBuilders["snapPizzicato"] = builder;
            }
            else {
                updates.snapPizzicato = build;
                delete childBuilders["snapPizzicato;"];
            }
            modifiedKeys["snapPizzicato"] = true;
            return this;
        };
        this.fingering = (build) => {
            if (typeof build === 'function') {
                delete updates["fingering"];
                const builder = build(new FingeringBuilder(original && original["fingering"]));
                if (!original)
                    updates["fingering"] = builder.build();
                else
                    childBuilders["fingering"] = builder;
            }
            else {
                updates.fingering = build;
                delete childBuilders["fingering;"];
            }
            modifiedKeys["fingering"] = true;
            return this;
        };
    }
}
function patchTechnical(base, builder) { return builder(new TechnicalBuilder(base)).patch(); }
exports.patchTechnical = patchTechnical;
function buildTechnical(builder) { return builder(new TechnicalBuilder()).build(); }
exports.buildTechnical = buildTechnical;
class UpBowBuilder {
    build;
    patch;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    fontFamily;
    fontWeight;
    fontStyle;
    fontSize;
    color;
    placement;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "UpBow";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
        this.fontFamily = (spec) => {
            updates["fontFamily"] = spec;
            delete childBuilders["fontFamily;"];
            modifiedKeys["fontFamily"] = true;
            return this;
        };
        this.fontWeight = (spec) => {
            updates["fontWeight"] = spec;
            delete childBuilders["fontWeight;"];
            modifiedKeys["fontWeight"] = true;
            return this;
        };
        this.fontStyle = (spec) => {
            updates["fontStyle"] = spec;
            delete childBuilders["fontStyle;"];
            modifiedKeys["fontStyle"] = true;
            return this;
        };
        this.fontSize = (spec) => {
            updates["fontSize"] = spec;
            delete childBuilders["fontSize;"];
            modifiedKeys["fontSize"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
        this.placement = (spec) => {
            updates["placement"] = spec;
            delete childBuilders["placement;"];
            modifiedKeys["placement"] = true;
            return this;
        };
    }
}
function patchUpBow(base, builder) { return builder(new UpBowBuilder(base)).patch(); }
exports.patchUpBow = patchUpBow;
function buildUpBow(builder) { return builder(new UpBowBuilder()).build(); }
exports.buildUpBow = buildUpBow;
class DownBowBuilder {
    build;
    patch;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    fontFamily;
    fontWeight;
    fontStyle;
    fontSize;
    color;
    placement;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "DownBow";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
        this.fontFamily = (spec) => {
            updates["fontFamily"] = spec;
            delete childBuilders["fontFamily;"];
            modifiedKeys["fontFamily"] = true;
            return this;
        };
        this.fontWeight = (spec) => {
            updates["fontWeight"] = spec;
            delete childBuilders["fontWeight;"];
            modifiedKeys["fontWeight"] = true;
            return this;
        };
        this.fontStyle = (spec) => {
            updates["fontStyle"] = spec;
            delete childBuilders["fontStyle;"];
            modifiedKeys["fontStyle"] = true;
            return this;
        };
        this.fontSize = (spec) => {
            updates["fontSize"] = spec;
            delete childBuilders["fontSize;"];
            modifiedKeys["fontSize"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
        this.placement = (spec) => {
            updates["placement"] = spec;
            delete childBuilders["placement;"];
            modifiedKeys["placement"] = true;
            return this;
        };
    }
}
function patchDownBow(base, builder) { return builder(new DownBowBuilder(base)).patch(); }
exports.patchDownBow = patchDownBow;
function buildDownBow(builder) { return builder(new DownBowBuilder()).build(); }
exports.buildDownBow = buildDownBow;
class HarmonicBuilder {
    build;
    patch;
    artificial;
    touchingPitch;
    soundingPitch;
    natural;
    basePitch;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    fontFamily;
    fontWeight;
    fontStyle;
    fontSize;
    color;
    printObject;
    placement;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["artificial"]) ||
                childBuilders["artificial"] !== undefined ||
                updates.artificial !== undefined, "artificial is a required field");
            console.assert((original && !modifiedKeys["touchingPitch"]) ||
                childBuilders["touchingPitch"] !== undefined ||
                updates.touchingPitch !== undefined, "touchingPitch is a required field");
            console.assert((original && !modifiedKeys["soundingPitch"]) ||
                childBuilders["soundingPitch"] !== undefined ||
                updates.soundingPitch !== undefined, "soundingPitch is a required field");
            console.assert((original && !modifiedKeys["natural"]) ||
                childBuilders["natural"] !== undefined ||
                updates.natural !== undefined, "natural is a required field");
            console.assert((original && !modifiedKeys["basePitch"]) ||
                childBuilders["basePitch"] !== undefined ||
                updates.basePitch !== undefined, "basePitch is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Harmonic";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.artificial = (spec) => {
            updates["artificial"] = spec;
            delete childBuilders["artificial;"];
            modifiedKeys["artificial"] = true;
            return this;
        };
        this.touchingPitch = (spec) => {
            updates["touchingPitch"] = spec;
            delete childBuilders["touchingPitch;"];
            modifiedKeys["touchingPitch"] = true;
            return this;
        };
        this.soundingPitch = (spec) => {
            updates["soundingPitch"] = spec;
            delete childBuilders["soundingPitch;"];
            modifiedKeys["soundingPitch"] = true;
            return this;
        };
        this.natural = (spec) => {
            updates["natural"] = spec;
            delete childBuilders["natural;"];
            modifiedKeys["natural"] = true;
            return this;
        };
        this.basePitch = (spec) => {
            updates["basePitch"] = spec;
            delete childBuilders["basePitch;"];
            modifiedKeys["basePitch"] = true;
            return this;
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
        this.fontFamily = (spec) => {
            updates["fontFamily"] = spec;
            delete childBuilders["fontFamily;"];
            modifiedKeys["fontFamily"] = true;
            return this;
        };
        this.fontWeight = (spec) => {
            updates["fontWeight"] = spec;
            delete childBuilders["fontWeight;"];
            modifiedKeys["fontWeight"] = true;
            return this;
        };
        this.fontStyle = (spec) => {
            updates["fontStyle"] = spec;
            delete childBuilders["fontStyle;"];
            modifiedKeys["fontStyle"] = true;
            return this;
        };
        this.fontSize = (spec) => {
            updates["fontSize"] = spec;
            delete childBuilders["fontSize;"];
            modifiedKeys["fontSize"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
        this.printObject = (spec) => {
            updates["printObject"] = spec;
            delete childBuilders["printObject;"];
            modifiedKeys["printObject"] = true;
            return this;
        };
        this.placement = (spec) => {
            updates["placement"] = spec;
            delete childBuilders["placement;"];
            modifiedKeys["placement"] = true;
            return this;
        };
    }
}
function patchHarmonic(base, builder) { return builder(new HarmonicBuilder(base)).patch(); }
exports.patchHarmonic = patchHarmonic;
function buildHarmonic(builder) { return builder(new HarmonicBuilder()).build(); }
exports.buildHarmonic = buildHarmonic;
class OpenStringBuilder {
    build;
    patch;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    fontFamily;
    fontWeight;
    fontStyle;
    fontSize;
    color;
    placement;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "OpenString";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
        this.fontFamily = (spec) => {
            updates["fontFamily"] = spec;
            delete childBuilders["fontFamily;"];
            modifiedKeys["fontFamily"] = true;
            return this;
        };
        this.fontWeight = (spec) => {
            updates["fontWeight"] = spec;
            delete childBuilders["fontWeight;"];
            modifiedKeys["fontWeight"] = true;
            return this;
        };
        this.fontStyle = (spec) => {
            updates["fontStyle"] = spec;
            delete childBuilders["fontStyle;"];
            modifiedKeys["fontStyle"] = true;
            return this;
        };
        this.fontSize = (spec) => {
            updates["fontSize"] = spec;
            delete childBuilders["fontSize;"];
            modifiedKeys["fontSize"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
        this.placement = (spec) => {
            updates["placement"] = spec;
            delete childBuilders["placement;"];
            modifiedKeys["placement"] = true;
            return this;
        };
    }
}
function patchOpenString(base, builder) { return builder(new OpenStringBuilder(base)).patch(); }
exports.patchOpenString = patchOpenString;
function buildOpenString(builder) { return builder(new OpenStringBuilder()).build(); }
exports.buildOpenString = buildOpenString;
class ThumbPositionBuilder {
    build;
    patch;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    fontFamily;
    fontWeight;
    fontStyle;
    fontSize;
    color;
    placement;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "ThumbPosition";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
        this.fontFamily = (spec) => {
            updates["fontFamily"] = spec;
            delete childBuilders["fontFamily;"];
            modifiedKeys["fontFamily"] = true;
            return this;
        };
        this.fontWeight = (spec) => {
            updates["fontWeight"] = spec;
            delete childBuilders["fontWeight;"];
            modifiedKeys["fontWeight"] = true;
            return this;
        };
        this.fontStyle = (spec) => {
            updates["fontStyle"] = spec;
            delete childBuilders["fontStyle;"];
            modifiedKeys["fontStyle"] = true;
            return this;
        };
        this.fontSize = (spec) => {
            updates["fontSize"] = spec;
            delete childBuilders["fontSize;"];
            modifiedKeys["fontSize"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
        this.placement = (spec) => {
            updates["placement"] = spec;
            delete childBuilders["placement;"];
            modifiedKeys["placement"] = true;
            return this;
        };
    }
}
function patchThumbPosition(base, builder) { return builder(new ThumbPositionBuilder(base)).patch(); }
exports.patchThumbPosition = patchThumbPosition;
function buildThumbPosition(builder) { return builder(new ThumbPositionBuilder()).build(); }
exports.buildThumbPosition = buildThumbPosition;
class PluckBuilder {
    build;
    patch;
    data;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    fontFamily;
    fontWeight;
    fontStyle;
    fontSize;
    color;
    placement;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["data"]) ||
                childBuilders["data"] !== undefined ||
                updates.data !== undefined, "data is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Pluck";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.data = (spec) => {
            updates["data"] = spec;
            delete childBuilders["data;"];
            modifiedKeys["data"] = true;
            return this;
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
        this.fontFamily = (spec) => {
            updates["fontFamily"] = spec;
            delete childBuilders["fontFamily;"];
            modifiedKeys["fontFamily"] = true;
            return this;
        };
        this.fontWeight = (spec) => {
            updates["fontWeight"] = spec;
            delete childBuilders["fontWeight;"];
            modifiedKeys["fontWeight"] = true;
            return this;
        };
        this.fontStyle = (spec) => {
            updates["fontStyle"] = spec;
            delete childBuilders["fontStyle;"];
            modifiedKeys["fontStyle"] = true;
            return this;
        };
        this.fontSize = (spec) => {
            updates["fontSize"] = spec;
            delete childBuilders["fontSize;"];
            modifiedKeys["fontSize"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
        this.placement = (spec) => {
            updates["placement"] = spec;
            delete childBuilders["placement;"];
            modifiedKeys["placement"] = true;
            return this;
        };
    }
}
function patchPluck(base, builder) { return builder(new PluckBuilder(base)).patch(); }
exports.patchPluck = patchPluck;
function buildPluck(builder) { return builder(new PluckBuilder()).build(); }
exports.buildPluck = buildPluck;
class DoubleTongueBuilder {
    build;
    patch;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    fontFamily;
    fontWeight;
    fontStyle;
    fontSize;
    color;
    placement;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "DoubleTongue";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
        this.fontFamily = (spec) => {
            updates["fontFamily"] = spec;
            delete childBuilders["fontFamily;"];
            modifiedKeys["fontFamily"] = true;
            return this;
        };
        this.fontWeight = (spec) => {
            updates["fontWeight"] = spec;
            delete childBuilders["fontWeight;"];
            modifiedKeys["fontWeight"] = true;
            return this;
        };
        this.fontStyle = (spec) => {
            updates["fontStyle"] = spec;
            delete childBuilders["fontStyle;"];
            modifiedKeys["fontStyle"] = true;
            return this;
        };
        this.fontSize = (spec) => {
            updates["fontSize"] = spec;
            delete childBuilders["fontSize;"];
            modifiedKeys["fontSize"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
        this.placement = (spec) => {
            updates["placement"] = spec;
            delete childBuilders["placement;"];
            modifiedKeys["placement"] = true;
            return this;
        };
    }
}
function patchDoubleTongue(base, builder) { return builder(new DoubleTongueBuilder(base)).patch(); }
exports.patchDoubleTongue = patchDoubleTongue;
function buildDoubleTongue(builder) { return builder(new DoubleTongueBuilder()).build(); }
exports.buildDoubleTongue = buildDoubleTongue;
class TripleTongueBuilder {
    build;
    patch;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    fontFamily;
    fontWeight;
    fontStyle;
    fontSize;
    color;
    placement;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "TripleTongue";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
        this.fontFamily = (spec) => {
            updates["fontFamily"] = spec;
            delete childBuilders["fontFamily;"];
            modifiedKeys["fontFamily"] = true;
            return this;
        };
        this.fontWeight = (spec) => {
            updates["fontWeight"] = spec;
            delete childBuilders["fontWeight;"];
            modifiedKeys["fontWeight"] = true;
            return this;
        };
        this.fontStyle = (spec) => {
            updates["fontStyle"] = spec;
            delete childBuilders["fontStyle;"];
            modifiedKeys["fontStyle"] = true;
            return this;
        };
        this.fontSize = (spec) => {
            updates["fontSize"] = spec;
            delete childBuilders["fontSize;"];
            modifiedKeys["fontSize"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
        this.placement = (spec) => {
            updates["placement"] = spec;
            delete childBuilders["placement;"];
            modifiedKeys["placement"] = true;
            return this;
        };
    }
}
function patchTripleTongue(base, builder) { return builder(new TripleTongueBuilder(base)).patch(); }
exports.patchTripleTongue = patchTripleTongue;
function buildTripleTongue(builder) { return builder(new TripleTongueBuilder()).build(); }
exports.buildTripleTongue = buildTripleTongue;
class StoppedBuilder {
    build;
    patch;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    fontFamily;
    fontWeight;
    fontStyle;
    fontSize;
    color;
    placement;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Stopped";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
        this.fontFamily = (spec) => {
            updates["fontFamily"] = spec;
            delete childBuilders["fontFamily;"];
            modifiedKeys["fontFamily"] = true;
            return this;
        };
        this.fontWeight = (spec) => {
            updates["fontWeight"] = spec;
            delete childBuilders["fontWeight;"];
            modifiedKeys["fontWeight"] = true;
            return this;
        };
        this.fontStyle = (spec) => {
            updates["fontStyle"] = spec;
            delete childBuilders["fontStyle;"];
            modifiedKeys["fontStyle"] = true;
            return this;
        };
        this.fontSize = (spec) => {
            updates["fontSize"] = spec;
            delete childBuilders["fontSize;"];
            modifiedKeys["fontSize"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
        this.placement = (spec) => {
            updates["placement"] = spec;
            delete childBuilders["placement;"];
            modifiedKeys["placement"] = true;
            return this;
        };
    }
}
function patchStopped(base, builder) { return builder(new StoppedBuilder(base)).patch(); }
exports.patchStopped = patchStopped;
function buildStopped(builder) { return builder(new StoppedBuilder()).build(); }
exports.buildStopped = buildStopped;
class SnapPizzicatoBuilder {
    build;
    patch;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    fontFamily;
    fontWeight;
    fontStyle;
    fontSize;
    color;
    placement;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "SnapPizzicato";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
        this.fontFamily = (spec) => {
            updates["fontFamily"] = spec;
            delete childBuilders["fontFamily;"];
            modifiedKeys["fontFamily"] = true;
            return this;
        };
        this.fontWeight = (spec) => {
            updates["fontWeight"] = spec;
            delete childBuilders["fontWeight;"];
            modifiedKeys["fontWeight"] = true;
            return this;
        };
        this.fontStyle = (spec) => {
            updates["fontStyle"] = spec;
            delete childBuilders["fontStyle;"];
            modifiedKeys["fontStyle"] = true;
            return this;
        };
        this.fontSize = (spec) => {
            updates["fontSize"] = spec;
            delete childBuilders["fontSize;"];
            modifiedKeys["fontSize"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
        this.placement = (spec) => {
            updates["placement"] = spec;
            delete childBuilders["placement;"];
            modifiedKeys["placement"] = true;
            return this;
        };
    }
}
function patchSnapPizzicato(base, builder) { return builder(new SnapPizzicatoBuilder(base)).patch(); }
exports.patchSnapPizzicato = patchSnapPizzicato;
function buildSnapPizzicato(builder) { return builder(new SnapPizzicatoBuilder()).build(); }
exports.buildSnapPizzicato = buildSnapPizzicato;
class HammerOnBuilder {
    build;
    patch;
    number;
    type;
    data;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    fontFamily;
    fontWeight;
    fontStyle;
    fontSize;
    color;
    placement;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["type"]) ||
                childBuilders["type"] !== undefined ||
                updates.type !== undefined, "type is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "HammerOn";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.number = (spec) => {
            updates["number"] = spec;
            delete childBuilders["number;"];
            modifiedKeys["number"] = true;
            return this;
        };
        this.type = (spec) => {
            updates["type"] = spec;
            delete childBuilders["type;"];
            modifiedKeys["type"] = true;
            return this;
        };
        this.data = (spec) => {
            updates["data"] = spec;
            delete childBuilders["data;"];
            modifiedKeys["data"] = true;
            return this;
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
        this.fontFamily = (spec) => {
            updates["fontFamily"] = spec;
            delete childBuilders["fontFamily;"];
            modifiedKeys["fontFamily"] = true;
            return this;
        };
        this.fontWeight = (spec) => {
            updates["fontWeight"] = spec;
            delete childBuilders["fontWeight;"];
            modifiedKeys["fontWeight"] = true;
            return this;
        };
        this.fontStyle = (spec) => {
            updates["fontStyle"] = spec;
            delete childBuilders["fontStyle;"];
            modifiedKeys["fontStyle"] = true;
            return this;
        };
        this.fontSize = (spec) => {
            updates["fontSize"] = spec;
            delete childBuilders["fontSize;"];
            modifiedKeys["fontSize"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
        this.placement = (spec) => {
            updates["placement"] = spec;
            delete childBuilders["placement;"];
            modifiedKeys["placement"] = true;
            return this;
        };
    }
}
function patchHammerOn(base, builder) { return builder(new HammerOnBuilder(base)).patch(); }
exports.patchHammerOn = patchHammerOn;
function buildHammerOn(builder) { return builder(new HammerOnBuilder()).build(); }
exports.buildHammerOn = buildHammerOn;
class PullOffBuilder {
    build;
    patch;
    number;
    type;
    data;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    fontFamily;
    fontWeight;
    fontStyle;
    fontSize;
    color;
    placement;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["type"]) ||
                childBuilders["type"] !== undefined ||
                updates.type !== undefined, "type is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "PullOff";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.number = (spec) => {
            updates["number"] = spec;
            delete childBuilders["number;"];
            modifiedKeys["number"] = true;
            return this;
        };
        this.type = (spec) => {
            updates["type"] = spec;
            delete childBuilders["type;"];
            modifiedKeys["type"] = true;
            return this;
        };
        this.data = (spec) => {
            updates["data"] = spec;
            delete childBuilders["data;"];
            modifiedKeys["data"] = true;
            return this;
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
        this.fontFamily = (spec) => {
            updates["fontFamily"] = spec;
            delete childBuilders["fontFamily;"];
            modifiedKeys["fontFamily"] = true;
            return this;
        };
        this.fontWeight = (spec) => {
            updates["fontWeight"] = spec;
            delete childBuilders["fontWeight;"];
            modifiedKeys["fontWeight"] = true;
            return this;
        };
        this.fontStyle = (spec) => {
            updates["fontStyle"] = spec;
            delete childBuilders["fontStyle;"];
            modifiedKeys["fontStyle"] = true;
            return this;
        };
        this.fontSize = (spec) => {
            updates["fontSize"] = spec;
            delete childBuilders["fontSize;"];
            modifiedKeys["fontSize"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
        this.placement = (spec) => {
            updates["placement"] = spec;
            delete childBuilders["placement;"];
            modifiedKeys["placement"] = true;
            return this;
        };
    }
}
function patchPullOff(base, builder) { return builder(new PullOffBuilder(base)).patch(); }
exports.patchPullOff = patchPullOff;
function buildPullOff(builder) { return builder(new PullOffBuilder()).build(); }
exports.buildPullOff = buildPullOff;
class BendBuilder {
    build;
    patch;
    bendAlter;
    withBar;
    preBend;
    release;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    fontFamily;
    fontWeight;
    fontStyle;
    fontSize;
    color;
    accelerate;
    beats;
    firstBeat;
    lastBeat;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["bendAlter"]) ||
                childBuilders["bendAlter"] !== undefined ||
                updates.bendAlter !== undefined, "bendAlter is a required field");
            console.assert((original && !modifiedKeys["preBend"]) ||
                childBuilders["preBend"] !== undefined ||
                updates.preBend !== undefined, "preBend is a required field");
            console.assert((original && !modifiedKeys["release"]) ||
                childBuilders["release"] !== undefined ||
                updates.release !== undefined, "release is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Bend";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.bendAlter = (spec) => {
            updates["bendAlter"] = spec;
            delete childBuilders["bendAlter;"];
            modifiedKeys["bendAlter"] = true;
            return this;
        };
        this.withBar = (build) => {
            if (typeof build === 'function') {
                delete updates["withBar"];
                const builder = build(new WithBarBuilder(original && original["withBar"]));
                if (!original)
                    updates["withBar"] = builder.build();
                else
                    childBuilders["withBar"] = builder;
            }
            else {
                updates.withBar = build;
                delete childBuilders["withBar;"];
            }
            modifiedKeys["withBar"] = true;
            return this;
        };
        this.preBend = (spec) => {
            updates["preBend"] = spec;
            delete childBuilders["preBend;"];
            modifiedKeys["preBend"] = true;
            return this;
        };
        this.release = (spec) => {
            updates["release"] = spec;
            delete childBuilders["release;"];
            modifiedKeys["release"] = true;
            return this;
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
        this.fontFamily = (spec) => {
            updates["fontFamily"] = spec;
            delete childBuilders["fontFamily;"];
            modifiedKeys["fontFamily"] = true;
            return this;
        };
        this.fontWeight = (spec) => {
            updates["fontWeight"] = spec;
            delete childBuilders["fontWeight;"];
            modifiedKeys["fontWeight"] = true;
            return this;
        };
        this.fontStyle = (spec) => {
            updates["fontStyle"] = spec;
            delete childBuilders["fontStyle;"];
            modifiedKeys["fontStyle"] = true;
            return this;
        };
        this.fontSize = (spec) => {
            updates["fontSize"] = spec;
            delete childBuilders["fontSize;"];
            modifiedKeys["fontSize"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
        this.accelerate = (spec) => {
            updates["accelerate"] = spec;
            delete childBuilders["accelerate;"];
            modifiedKeys["accelerate"] = true;
            return this;
        };
        this.beats = (spec) => {
            updates["beats"] = spec;
            delete childBuilders["beats;"];
            modifiedKeys["beats"] = true;
            return this;
        };
        this.firstBeat = (spec) => {
            updates["firstBeat"] = spec;
            delete childBuilders["firstBeat;"];
            modifiedKeys["firstBeat"] = true;
            return this;
        };
        this.lastBeat = (spec) => {
            updates["lastBeat"] = spec;
            delete childBuilders["lastBeat;"];
            modifiedKeys["lastBeat"] = true;
            return this;
        };
    }
}
function patchBend(base, builder) { return builder(new BendBuilder(base)).patch(); }
exports.patchBend = patchBend;
function buildBend(builder) { return builder(new BendBuilder()).build(); }
exports.buildBend = buildBend;
class WithBarBuilder {
    build;
    patch;
    data;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    fontFamily;
    fontWeight;
    fontStyle;
    fontSize;
    color;
    placement;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["data"]) ||
                childBuilders["data"] !== undefined ||
                updates.data !== undefined, "data is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "WithBar";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.data = (spec) => {
            updates["data"] = spec;
            delete childBuilders["data;"];
            modifiedKeys["data"] = true;
            return this;
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
        this.fontFamily = (spec) => {
            updates["fontFamily"] = spec;
            delete childBuilders["fontFamily;"];
            modifiedKeys["fontFamily"] = true;
            return this;
        };
        this.fontWeight = (spec) => {
            updates["fontWeight"] = spec;
            delete childBuilders["fontWeight;"];
            modifiedKeys["fontWeight"] = true;
            return this;
        };
        this.fontStyle = (spec) => {
            updates["fontStyle"] = spec;
            delete childBuilders["fontStyle;"];
            modifiedKeys["fontStyle"] = true;
            return this;
        };
        this.fontSize = (spec) => {
            updates["fontSize"] = spec;
            delete childBuilders["fontSize;"];
            modifiedKeys["fontSize"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
        this.placement = (spec) => {
            updates["placement"] = spec;
            delete childBuilders["placement;"];
            modifiedKeys["placement"] = true;
            return this;
        };
    }
}
function patchWithBar(base, builder) { return builder(new WithBarBuilder(base)).patch(); }
exports.patchWithBar = patchWithBar;
function buildWithBar(builder) { return builder(new WithBarBuilder()).build(); }
exports.buildWithBar = buildWithBar;
class TapBuilder {
    build;
    patch;
    data;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    fontFamily;
    fontWeight;
    fontStyle;
    fontSize;
    color;
    placement;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["data"]) ||
                childBuilders["data"] !== undefined ||
                updates.data !== undefined, "data is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Tap";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.data = (spec) => {
            updates["data"] = spec;
            delete childBuilders["data;"];
            modifiedKeys["data"] = true;
            return this;
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
        this.fontFamily = (spec) => {
            updates["fontFamily"] = spec;
            delete childBuilders["fontFamily;"];
            modifiedKeys["fontFamily"] = true;
            return this;
        };
        this.fontWeight = (spec) => {
            updates["fontWeight"] = spec;
            delete childBuilders["fontWeight;"];
            modifiedKeys["fontWeight"] = true;
            return this;
        };
        this.fontStyle = (spec) => {
            updates["fontStyle"] = spec;
            delete childBuilders["fontStyle;"];
            modifiedKeys["fontStyle"] = true;
            return this;
        };
        this.fontSize = (spec) => {
            updates["fontSize"] = spec;
            delete childBuilders["fontSize;"];
            modifiedKeys["fontSize"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
        this.placement = (spec) => {
            updates["placement"] = spec;
            delete childBuilders["placement;"];
            modifiedKeys["placement"] = true;
            return this;
        };
    }
}
function patchTap(base, builder) { return builder(new TapBuilder(base)).patch(); }
exports.patchTap = patchTap;
function buildTap(builder) { return builder(new TapBuilder()).build(); }
exports.buildTap = buildTap;
class HeelBuilder {
    build;
    patch;
    substitution;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    fontFamily;
    fontWeight;
    fontStyle;
    fontSize;
    color;
    placement;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Heel";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.substitution = (spec) => {
            updates["substitution"] = spec;
            delete childBuilders["substitution;"];
            modifiedKeys["substitution"] = true;
            return this;
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
        this.fontFamily = (spec) => {
            updates["fontFamily"] = spec;
            delete childBuilders["fontFamily;"];
            modifiedKeys["fontFamily"] = true;
            return this;
        };
        this.fontWeight = (spec) => {
            updates["fontWeight"] = spec;
            delete childBuilders["fontWeight;"];
            modifiedKeys["fontWeight"] = true;
            return this;
        };
        this.fontStyle = (spec) => {
            updates["fontStyle"] = spec;
            delete childBuilders["fontStyle;"];
            modifiedKeys["fontStyle"] = true;
            return this;
        };
        this.fontSize = (spec) => {
            updates["fontSize"] = spec;
            delete childBuilders["fontSize;"];
            modifiedKeys["fontSize"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
        this.placement = (spec) => {
            updates["placement"] = spec;
            delete childBuilders["placement;"];
            modifiedKeys["placement"] = true;
            return this;
        };
    }
}
function patchHeel(base, builder) { return builder(new HeelBuilder(base)).patch(); }
exports.patchHeel = patchHeel;
function buildHeel(builder) { return builder(new HeelBuilder()).build(); }
exports.buildHeel = buildHeel;
class ToeBuilder {
    build;
    patch;
    substitution;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    fontFamily;
    fontWeight;
    fontStyle;
    fontSize;
    color;
    placement;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Toe";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.substitution = (spec) => {
            updates["substitution"] = spec;
            delete childBuilders["substitution;"];
            modifiedKeys["substitution"] = true;
            return this;
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
        this.fontFamily = (spec) => {
            updates["fontFamily"] = spec;
            delete childBuilders["fontFamily;"];
            modifiedKeys["fontFamily"] = true;
            return this;
        };
        this.fontWeight = (spec) => {
            updates["fontWeight"] = spec;
            delete childBuilders["fontWeight;"];
            modifiedKeys["fontWeight"] = true;
            return this;
        };
        this.fontStyle = (spec) => {
            updates["fontStyle"] = spec;
            delete childBuilders["fontStyle;"];
            modifiedKeys["fontStyle"] = true;
            return this;
        };
        this.fontSize = (spec) => {
            updates["fontSize"] = spec;
            delete childBuilders["fontSize;"];
            modifiedKeys["fontSize"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
        this.placement = (spec) => {
            updates["placement"] = spec;
            delete childBuilders["placement;"];
            modifiedKeys["placement"] = true;
            return this;
        };
    }
}
function patchToe(base, builder) { return builder(new ToeBuilder(base)).patch(); }
exports.patchToe = patchToe;
function buildToe(builder) { return builder(new ToeBuilder()).build(); }
exports.buildToe = buildToe;
class FingernailsBuilder {
    build;
    patch;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    fontFamily;
    fontWeight;
    fontStyle;
    fontSize;
    color;
    placement;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Fingernails";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
        this.fontFamily = (spec) => {
            updates["fontFamily"] = spec;
            delete childBuilders["fontFamily;"];
            modifiedKeys["fontFamily"] = true;
            return this;
        };
        this.fontWeight = (spec) => {
            updates["fontWeight"] = spec;
            delete childBuilders["fontWeight;"];
            modifiedKeys["fontWeight"] = true;
            return this;
        };
        this.fontStyle = (spec) => {
            updates["fontStyle"] = spec;
            delete childBuilders["fontStyle;"];
            modifiedKeys["fontStyle"] = true;
            return this;
        };
        this.fontSize = (spec) => {
            updates["fontSize"] = spec;
            delete childBuilders["fontSize;"];
            modifiedKeys["fontSize"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
        this.placement = (spec) => {
            updates["placement"] = spec;
            delete childBuilders["placement;"];
            modifiedKeys["placement"] = true;
            return this;
        };
    }
}
function patchFingernails(base, builder) { return builder(new FingernailsBuilder(base)).patch(); }
exports.patchFingernails = patchFingernails;
function buildFingernails(builder) { return builder(new FingernailsBuilder()).build(); }
exports.buildFingernails = buildFingernails;
class HoleBuilder {
    build;
    patch;
    holeClosed;
    holeShape;
    holeType;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    fontFamily;
    fontWeight;
    fontStyle;
    fontSize;
    color;
    placement;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["holeClosed"]) ||
                childBuilders["holeClosed"] !== undefined ||
                updates.holeClosed !== undefined, "holeClosed is a required field");
            console.assert((original && !modifiedKeys["holeShape"]) ||
                childBuilders["holeShape"] !== undefined ||
                updates.holeShape !== undefined, "holeShape is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Hole";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.holeClosed = (build) => {
            if (typeof build === 'function') {
                delete updates["holeClosed"];
                const builder = build(new HoleClosedBuilder(original && original["holeClosed"]));
                if (!original)
                    updates["holeClosed"] = builder.build();
                else
                    childBuilders["holeClosed"] = builder;
            }
            else {
                updates.holeClosed = build;
                delete childBuilders["holeClosed;"];
            }
            modifiedKeys["holeClosed"] = true;
            return this;
        };
        this.holeShape = (spec) => {
            updates["holeShape"] = spec;
            delete childBuilders["holeShape;"];
            modifiedKeys["holeShape"] = true;
            return this;
        };
        this.holeType = (spec) => {
            updates["holeType"] = spec;
            delete childBuilders["holeType;"];
            modifiedKeys["holeType"] = true;
            return this;
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
        this.fontFamily = (spec) => {
            updates["fontFamily"] = spec;
            delete childBuilders["fontFamily;"];
            modifiedKeys["fontFamily"] = true;
            return this;
        };
        this.fontWeight = (spec) => {
            updates["fontWeight"] = spec;
            delete childBuilders["fontWeight;"];
            modifiedKeys["fontWeight"] = true;
            return this;
        };
        this.fontStyle = (spec) => {
            updates["fontStyle"] = spec;
            delete childBuilders["fontStyle;"];
            modifiedKeys["fontStyle"] = true;
            return this;
        };
        this.fontSize = (spec) => {
            updates["fontSize"] = spec;
            delete childBuilders["fontSize;"];
            modifiedKeys["fontSize"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
        this.placement = (spec) => {
            updates["placement"] = spec;
            delete childBuilders["placement;"];
            modifiedKeys["placement"] = true;
            return this;
        };
    }
}
function patchHole(base, builder) { return builder(new HoleBuilder(base)).patch(); }
exports.patchHole = patchHole;
function buildHole(builder) { return builder(new HoleBuilder()).build(); }
exports.buildHole = buildHole;
class HoleClosedBuilder {
    build;
    patch;
    location;
    data;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["data"]) ||
                childBuilders["data"] !== undefined ||
                updates.data !== undefined, "data is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "HoleClosed";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.location = (spec) => {
            updates["location"] = spec;
            delete childBuilders["location;"];
            modifiedKeys["location"] = true;
            return this;
        };
        this.data = (spec) => {
            updates["data"] = spec;
            delete childBuilders["data;"];
            modifiedKeys["data"] = true;
            return this;
        };
    }
}
function patchHoleClosed(base, builder) { return builder(new HoleClosedBuilder(base)).patch(); }
exports.patchHoleClosed = patchHoleClosed;
function buildHoleClosed(builder) { return builder(new HoleClosedBuilder()).build(); }
exports.buildHoleClosed = buildHoleClosed;
class ArrowBuilder {
    build;
    patch;
    arrowStyle;
    arrowDirection;
    circularArrow;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    fontFamily;
    fontWeight;
    fontStyle;
    fontSize;
    color;
    placement;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Arrow";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.arrowStyle = (spec) => {
            updates["arrowStyle"] = spec;
            delete childBuilders["arrowStyle;"];
            modifiedKeys["arrowStyle"] = true;
            return this;
        };
        this.arrowDirection = (spec) => {
            updates["arrowDirection"] = spec;
            delete childBuilders["arrowDirection;"];
            modifiedKeys["arrowDirection"] = true;
            return this;
        };
        this.circularArrow = (spec) => {
            updates["circularArrow"] = spec;
            delete childBuilders["circularArrow;"];
            modifiedKeys["circularArrow"] = true;
            return this;
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
        this.fontFamily = (spec) => {
            updates["fontFamily"] = spec;
            delete childBuilders["fontFamily;"];
            modifiedKeys["fontFamily"] = true;
            return this;
        };
        this.fontWeight = (spec) => {
            updates["fontWeight"] = spec;
            delete childBuilders["fontWeight;"];
            modifiedKeys["fontWeight"] = true;
            return this;
        };
        this.fontStyle = (spec) => {
            updates["fontStyle"] = spec;
            delete childBuilders["fontStyle;"];
            modifiedKeys["fontStyle"] = true;
            return this;
        };
        this.fontSize = (spec) => {
            updates["fontSize"] = spec;
            delete childBuilders["fontSize;"];
            modifiedKeys["fontSize"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
        this.placement = (spec) => {
            updates["placement"] = spec;
            delete childBuilders["placement;"];
            modifiedKeys["placement"] = true;
            return this;
        };
    }
}
function patchArrow(base, builder) { return builder(new ArrowBuilder(base)).patch(); }
exports.patchArrow = patchArrow;
function buildArrow(builder) { return builder(new ArrowBuilder()).build(); }
exports.buildArrow = buildArrow;
class HandbellBuilder {
    build;
    patch;
    data;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    fontFamily;
    fontWeight;
    fontStyle;
    fontSize;
    color;
    placement;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["data"]) ||
                childBuilders["data"] !== undefined ||
                updates.data !== undefined, "data is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Handbell";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.data = (spec) => {
            updates["data"] = spec;
            delete childBuilders["data;"];
            modifiedKeys["data"] = true;
            return this;
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
        this.fontFamily = (spec) => {
            updates["fontFamily"] = spec;
            delete childBuilders["fontFamily;"];
            modifiedKeys["fontFamily"] = true;
            return this;
        };
        this.fontWeight = (spec) => {
            updates["fontWeight"] = spec;
            delete childBuilders["fontWeight;"];
            modifiedKeys["fontWeight"] = true;
            return this;
        };
        this.fontStyle = (spec) => {
            updates["fontStyle"] = spec;
            delete childBuilders["fontStyle;"];
            modifiedKeys["fontStyle"] = true;
            return this;
        };
        this.fontSize = (spec) => {
            updates["fontSize"] = spec;
            delete childBuilders["fontSize;"];
            modifiedKeys["fontSize"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
        this.placement = (spec) => {
            updates["placement"] = spec;
            delete childBuilders["placement;"];
            modifiedKeys["placement"] = true;
            return this;
        };
    }
}
function patchHandbell(base, builder) { return builder(new HandbellBuilder(base)).patch(); }
exports.patchHandbell = patchHandbell;
function buildHandbell(builder) { return builder(new HandbellBuilder()).build(); }
exports.buildHandbell = buildHandbell;
class OtherTechnicalBuilder {
    build;
    patch;
    data;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    fontFamily;
    fontWeight;
    fontStyle;
    fontSize;
    color;
    placement;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["data"]) ||
                childBuilders["data"] !== undefined ||
                updates.data !== undefined, "data is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "OtherTechnical";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.data = (spec) => {
            updates["data"] = spec;
            delete childBuilders["data;"];
            modifiedKeys["data"] = true;
            return this;
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
        this.fontFamily = (spec) => {
            updates["fontFamily"] = spec;
            delete childBuilders["fontFamily;"];
            modifiedKeys["fontFamily"] = true;
            return this;
        };
        this.fontWeight = (spec) => {
            updates["fontWeight"] = spec;
            delete childBuilders["fontWeight;"];
            modifiedKeys["fontWeight"] = true;
            return this;
        };
        this.fontStyle = (spec) => {
            updates["fontStyle"] = spec;
            delete childBuilders["fontStyle;"];
            modifiedKeys["fontStyle"] = true;
            return this;
        };
        this.fontSize = (spec) => {
            updates["fontSize"] = spec;
            delete childBuilders["fontSize;"];
            modifiedKeys["fontSize"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
        this.placement = (spec) => {
            updates["placement"] = spec;
            delete childBuilders["placement;"];
            modifiedKeys["placement"] = true;
            return this;
        };
    }
}
function patchOtherTechnical(base, builder) { return builder(new OtherTechnicalBuilder(base)).patch(); }
exports.patchOtherTechnical = patchOtherTechnical;
function buildOtherTechnical(builder) { return builder(new OtherTechnicalBuilder()).build(); }
exports.buildOtherTechnical = buildOtherTechnical;
class ArticulationsBuilder {
    build;
    patch;
    accent;
    doit;
    breathMark;
    otherArticulationsAt;
    otherArticulationsSplice;
    otherArticulations;
    detachedLegato;
    staccatissimo;
    plop;
    unstress;
    strongAccent;
    staccato;
    spiccato;
    scoop;
    falloff;
    caesura;
    stress;
    tenuto;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Articulations";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.accent = (build) => {
            if (typeof build === 'function') {
                delete updates["accent"];
                const builder = build(new AccentBuilder(original && original["accent"]));
                if (!original)
                    updates["accent"] = builder.build();
                else
                    childBuilders["accent"] = builder;
            }
            else {
                updates.accent = build;
                delete childBuilders["accent;"];
            }
            modifiedKeys["accent"] = true;
            return this;
        };
        this.doit = (build) => {
            if (typeof build === 'function') {
                delete updates["doit"];
                const builder = build(new DoitBuilder(original && original["doit"]));
                if (!original)
                    updates["doit"] = builder.build();
                else
                    childBuilders["doit"] = builder;
            }
            else {
                updates.doit = build;
                delete childBuilders["doit;"];
            }
            modifiedKeys["doit"] = true;
            return this;
        };
        this.breathMark = (build) => {
            if (typeof build === 'function') {
                delete updates["breathMark"];
                const builder = build(new BreathMarkBuilder(original && original["breathMark"]));
                if (!original)
                    updates["breathMark"] = builder.build();
                else
                    childBuilders["breathMark"] = builder;
            }
            else {
                updates.breathMark = build;
                delete childBuilders["breathMark;"];
            }
            modifiedKeys["breathMark"] = true;
            return this;
        };
        this.otherArticulations = (spec) => {
            updates["otherArticulations"] = spec;
            delete childBuilders["otherArticulations;"];
            modifiedKeys["otherArticulations"] = true;
            return this;
        };
        this.otherArticulationsAt = (idx, build) => {
            makeReference("otherArticulations");
            if (frozen["otherArticulations"][idx]) {
                throw new Error("Patching otherArticulations." + idx + " twice in a builder is unsupported.");
            }
            if (original && original._snapshot && original._snapshot["otherArticulations"] && original._snapshot["otherArticulations"][idx] && !original["otherArticulations"][idx]) {
                // Clone snapshot.
                patches.push({ p: ["otherArticulations", idx], li: original._snapshot["otherArticulations"] });
            }
            if (typeof build === 'function' && reference["otherArticulations"][idx]) {
                let patch = build(new OtherArticulationBuilder(reference["otherArticulations"][idx])).patch();
                patches = patches.concat(patch.map(patch => {
                    // TODO: detach?
                    patch.p = ["otherArticulations", idx].concat(patch.p);
                    return patch;
                }));
                frozen["otherArticulations"][idx] = true;
                return this;
            }
            let update = typeof build === 'function' ? build(new OtherArticulationBuilder(reference["otherArticulations"][idx])).build() : build;
            if (original) {
                patches.push({ p: ["otherArticulations", idx], li: update });
            }
            else {
                updates["otherArticulations"] = reference["otherArticulations"]; // TODO: Merge?
            }
            reference["otherArticulations"][idx] = update;
            frozen["otherArticulations"][idx] = true;
            return this;
        };
        this.otherArticulationsSplice = (start, deleteCount, ...items) => {
            makeReference("otherArticulations");
            let idx = start;
            if (original) {
                for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
                    if (frozen["otherArticulations"][idx]) {
                        throw new Error("Replacing otherArticulations." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["otherArticulations"][idx];
                    patches.push({ p: ["otherArticulations", idx], ld, li: items[idx - start] });
                    frozen["otherArticulations"][idx] = true;
                }
                for (; idx < start + deleteCount; ++idx) {
                    if (frozen["otherArticulations"][idx]) {
                        throw new Error("Removing otherArticulations." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["otherArticulations"][idx];
                    patches.push({ p: ["otherArticulations", idx], ld });
                }
                for (; idx < start + items.length; ++idx) {
                    patches.push({ p: ["otherArticulations", idx], li: items[idx - start] });
                    frozen["otherArticulations"][idx] = true;
                }
            }
            reference["otherArticulations"].splice(start, deleteCount, ...items);
            updates["otherArticulations"] = reference["otherArticulations"];
            frozen["otherArticulations"].splice(start, deleteCount, ...items.map(i => true));
            return this;
        };
        this.detachedLegato = (build) => {
            if (typeof build === 'function') {
                delete updates["detachedLegato"];
                const builder = build(new DetachedLegatoBuilder(original && original["detachedLegato"]));
                if (!original)
                    updates["detachedLegato"] = builder.build();
                else
                    childBuilders["detachedLegato"] = builder;
            }
            else {
                updates.detachedLegato = build;
                delete childBuilders["detachedLegato;"];
            }
            modifiedKeys["detachedLegato"] = true;
            return this;
        };
        this.staccatissimo = (build) => {
            if (typeof build === 'function') {
                delete updates["staccatissimo"];
                const builder = build(new StaccatissimoBuilder(original && original["staccatissimo"]));
                if (!original)
                    updates["staccatissimo"] = builder.build();
                else
                    childBuilders["staccatissimo"] = builder;
            }
            else {
                updates.staccatissimo = build;
                delete childBuilders["staccatissimo;"];
            }
            modifiedKeys["staccatissimo"] = true;
            return this;
        };
        this.plop = (build) => {
            if (typeof build === 'function') {
                delete updates["plop"];
                const builder = build(new PlopBuilder(original && original["plop"]));
                if (!original)
                    updates["plop"] = builder.build();
                else
                    childBuilders["plop"] = builder;
            }
            else {
                updates.plop = build;
                delete childBuilders["plop;"];
            }
            modifiedKeys["plop"] = true;
            return this;
        };
        this.unstress = (build) => {
            if (typeof build === 'function') {
                delete updates["unstress"];
                const builder = build(new UnstressBuilder(original && original["unstress"]));
                if (!original)
                    updates["unstress"] = builder.build();
                else
                    childBuilders["unstress"] = builder;
            }
            else {
                updates.unstress = build;
                delete childBuilders["unstress;"];
            }
            modifiedKeys["unstress"] = true;
            return this;
        };
        this.strongAccent = (build) => {
            if (typeof build === 'function') {
                delete updates["strongAccent"];
                const builder = build(new StrongAccentBuilder(original && original["strongAccent"]));
                if (!original)
                    updates["strongAccent"] = builder.build();
                else
                    childBuilders["strongAccent"] = builder;
            }
            else {
                updates.strongAccent = build;
                delete childBuilders["strongAccent;"];
            }
            modifiedKeys["strongAccent"] = true;
            return this;
        };
        this.staccato = (build) => {
            if (typeof build === 'function') {
                delete updates["staccato"];
                const builder = build(new StaccatoBuilder(original && original["staccato"]));
                if (!original)
                    updates["staccato"] = builder.build();
                else
                    childBuilders["staccato"] = builder;
            }
            else {
                updates.staccato = build;
                delete childBuilders["staccato;"];
            }
            modifiedKeys["staccato"] = true;
            return this;
        };
        this.spiccato = (build) => {
            if (typeof build === 'function') {
                delete updates["spiccato"];
                const builder = build(new SpiccatoBuilder(original && original["spiccato"]));
                if (!original)
                    updates["spiccato"] = builder.build();
                else
                    childBuilders["spiccato"] = builder;
            }
            else {
                updates.spiccato = build;
                delete childBuilders["spiccato;"];
            }
            modifiedKeys["spiccato"] = true;
            return this;
        };
        this.scoop = (build) => {
            if (typeof build === 'function') {
                delete updates["scoop"];
                const builder = build(new ScoopBuilder(original && original["scoop"]));
                if (!original)
                    updates["scoop"] = builder.build();
                else
                    childBuilders["scoop"] = builder;
            }
            else {
                updates.scoop = build;
                delete childBuilders["scoop;"];
            }
            modifiedKeys["scoop"] = true;
            return this;
        };
        this.falloff = (build) => {
            if (typeof build === 'function') {
                delete updates["falloff"];
                const builder = build(new FalloffBuilder(original && original["falloff"]));
                if (!original)
                    updates["falloff"] = builder.build();
                else
                    childBuilders["falloff"] = builder;
            }
            else {
                updates.falloff = build;
                delete childBuilders["falloff;"];
            }
            modifiedKeys["falloff"] = true;
            return this;
        };
        this.caesura = (build) => {
            if (typeof build === 'function') {
                delete updates["caesura"];
                const builder = build(new CaesuraBuilder(original && original["caesura"]));
                if (!original)
                    updates["caesura"] = builder.build();
                else
                    childBuilders["caesura"] = builder;
            }
            else {
                updates.caesura = build;
                delete childBuilders["caesura;"];
            }
            modifiedKeys["caesura"] = true;
            return this;
        };
        this.stress = (build) => {
            if (typeof build === 'function') {
                delete updates["stress"];
                const builder = build(new StressBuilder(original && original["stress"]));
                if (!original)
                    updates["stress"] = builder.build();
                else
                    childBuilders["stress"] = builder;
            }
            else {
                updates.stress = build;
                delete childBuilders["stress;"];
            }
            modifiedKeys["stress"] = true;
            return this;
        };
        this.tenuto = (build) => {
            if (typeof build === 'function') {
                delete updates["tenuto"];
                const builder = build(new TenutoBuilder(original && original["tenuto"]));
                if (!original)
                    updates["tenuto"] = builder.build();
                else
                    childBuilders["tenuto"] = builder;
            }
            else {
                updates.tenuto = build;
                delete childBuilders["tenuto;"];
            }
            modifiedKeys["tenuto"] = true;
            return this;
        };
    }
}
function patchArticulations(base, builder) { return builder(new ArticulationsBuilder(base)).patch(); }
exports.patchArticulations = patchArticulations;
function buildArticulations(builder) { return builder(new ArticulationsBuilder()).build(); }
exports.buildArticulations = buildArticulations;
class AccentBuilder {
    build;
    patch;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    fontFamily;
    fontWeight;
    fontStyle;
    fontSize;
    color;
    placement;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Accent";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
        this.fontFamily = (spec) => {
            updates["fontFamily"] = spec;
            delete childBuilders["fontFamily;"];
            modifiedKeys["fontFamily"] = true;
            return this;
        };
        this.fontWeight = (spec) => {
            updates["fontWeight"] = spec;
            delete childBuilders["fontWeight;"];
            modifiedKeys["fontWeight"] = true;
            return this;
        };
        this.fontStyle = (spec) => {
            updates["fontStyle"] = spec;
            delete childBuilders["fontStyle;"];
            modifiedKeys["fontStyle"] = true;
            return this;
        };
        this.fontSize = (spec) => {
            updates["fontSize"] = spec;
            delete childBuilders["fontSize;"];
            modifiedKeys["fontSize"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
        this.placement = (spec) => {
            updates["placement"] = spec;
            delete childBuilders["placement;"];
            modifiedKeys["placement"] = true;
            return this;
        };
    }
}
function patchAccent(base, builder) { return builder(new AccentBuilder(base)).patch(); }
exports.patchAccent = patchAccent;
function buildAccent(builder) { return builder(new AccentBuilder()).build(); }
exports.buildAccent = buildAccent;
class StrongAccentBuilder {
    build;
    patch;
    type;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    fontFamily;
    fontWeight;
    fontStyle;
    fontSize;
    color;
    placement;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "StrongAccent";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.type = (spec) => {
            updates["type"] = spec;
            delete childBuilders["type;"];
            modifiedKeys["type"] = true;
            return this;
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
        this.fontFamily = (spec) => {
            updates["fontFamily"] = spec;
            delete childBuilders["fontFamily;"];
            modifiedKeys["fontFamily"] = true;
            return this;
        };
        this.fontWeight = (spec) => {
            updates["fontWeight"] = spec;
            delete childBuilders["fontWeight;"];
            modifiedKeys["fontWeight"] = true;
            return this;
        };
        this.fontStyle = (spec) => {
            updates["fontStyle"] = spec;
            delete childBuilders["fontStyle;"];
            modifiedKeys["fontStyle"] = true;
            return this;
        };
        this.fontSize = (spec) => {
            updates["fontSize"] = spec;
            delete childBuilders["fontSize;"];
            modifiedKeys["fontSize"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
        this.placement = (spec) => {
            updates["placement"] = spec;
            delete childBuilders["placement;"];
            modifiedKeys["placement"] = true;
            return this;
        };
    }
}
function patchStrongAccent(base, builder) { return builder(new StrongAccentBuilder(base)).patch(); }
exports.patchStrongAccent = patchStrongAccent;
function buildStrongAccent(builder) { return builder(new StrongAccentBuilder()).build(); }
exports.buildStrongAccent = buildStrongAccent;
class StaccatoBuilder {
    build;
    patch;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    fontFamily;
    fontWeight;
    fontStyle;
    fontSize;
    color;
    placement;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Staccato";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
        this.fontFamily = (spec) => {
            updates["fontFamily"] = spec;
            delete childBuilders["fontFamily;"];
            modifiedKeys["fontFamily"] = true;
            return this;
        };
        this.fontWeight = (spec) => {
            updates["fontWeight"] = spec;
            delete childBuilders["fontWeight;"];
            modifiedKeys["fontWeight"] = true;
            return this;
        };
        this.fontStyle = (spec) => {
            updates["fontStyle"] = spec;
            delete childBuilders["fontStyle;"];
            modifiedKeys["fontStyle"] = true;
            return this;
        };
        this.fontSize = (spec) => {
            updates["fontSize"] = spec;
            delete childBuilders["fontSize;"];
            modifiedKeys["fontSize"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
        this.placement = (spec) => {
            updates["placement"] = spec;
            delete childBuilders["placement;"];
            modifiedKeys["placement"] = true;
            return this;
        };
    }
}
function patchStaccato(base, builder) { return builder(new StaccatoBuilder(base)).patch(); }
exports.patchStaccato = patchStaccato;
function buildStaccato(builder) { return builder(new StaccatoBuilder()).build(); }
exports.buildStaccato = buildStaccato;
class TenutoBuilder {
    build;
    patch;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    fontFamily;
    fontWeight;
    fontStyle;
    fontSize;
    color;
    placement;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Tenuto";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
        this.fontFamily = (spec) => {
            updates["fontFamily"] = spec;
            delete childBuilders["fontFamily;"];
            modifiedKeys["fontFamily"] = true;
            return this;
        };
        this.fontWeight = (spec) => {
            updates["fontWeight"] = spec;
            delete childBuilders["fontWeight;"];
            modifiedKeys["fontWeight"] = true;
            return this;
        };
        this.fontStyle = (spec) => {
            updates["fontStyle"] = spec;
            delete childBuilders["fontStyle;"];
            modifiedKeys["fontStyle"] = true;
            return this;
        };
        this.fontSize = (spec) => {
            updates["fontSize"] = spec;
            delete childBuilders["fontSize;"];
            modifiedKeys["fontSize"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
        this.placement = (spec) => {
            updates["placement"] = spec;
            delete childBuilders["placement;"];
            modifiedKeys["placement"] = true;
            return this;
        };
    }
}
function patchTenuto(base, builder) { return builder(new TenutoBuilder(base)).patch(); }
exports.patchTenuto = patchTenuto;
function buildTenuto(builder) { return builder(new TenutoBuilder()).build(); }
exports.buildTenuto = buildTenuto;
class DetachedLegatoBuilder {
    build;
    patch;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    fontFamily;
    fontWeight;
    fontStyle;
    fontSize;
    color;
    placement;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "DetachedLegato";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
        this.fontFamily = (spec) => {
            updates["fontFamily"] = spec;
            delete childBuilders["fontFamily;"];
            modifiedKeys["fontFamily"] = true;
            return this;
        };
        this.fontWeight = (spec) => {
            updates["fontWeight"] = spec;
            delete childBuilders["fontWeight;"];
            modifiedKeys["fontWeight"] = true;
            return this;
        };
        this.fontStyle = (spec) => {
            updates["fontStyle"] = spec;
            delete childBuilders["fontStyle;"];
            modifiedKeys["fontStyle"] = true;
            return this;
        };
        this.fontSize = (spec) => {
            updates["fontSize"] = spec;
            delete childBuilders["fontSize;"];
            modifiedKeys["fontSize"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
        this.placement = (spec) => {
            updates["placement"] = spec;
            delete childBuilders["placement;"];
            modifiedKeys["placement"] = true;
            return this;
        };
    }
}
function patchDetachedLegato(base, builder) { return builder(new DetachedLegatoBuilder(base)).patch(); }
exports.patchDetachedLegato = patchDetachedLegato;
function buildDetachedLegato(builder) { return builder(new DetachedLegatoBuilder()).build(); }
exports.buildDetachedLegato = buildDetachedLegato;
class StaccatissimoBuilder {
    build;
    patch;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    fontFamily;
    fontWeight;
    fontStyle;
    fontSize;
    color;
    placement;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Staccatissimo";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
        this.fontFamily = (spec) => {
            updates["fontFamily"] = spec;
            delete childBuilders["fontFamily;"];
            modifiedKeys["fontFamily"] = true;
            return this;
        };
        this.fontWeight = (spec) => {
            updates["fontWeight"] = spec;
            delete childBuilders["fontWeight;"];
            modifiedKeys["fontWeight"] = true;
            return this;
        };
        this.fontStyle = (spec) => {
            updates["fontStyle"] = spec;
            delete childBuilders["fontStyle;"];
            modifiedKeys["fontStyle"] = true;
            return this;
        };
        this.fontSize = (spec) => {
            updates["fontSize"] = spec;
            delete childBuilders["fontSize;"];
            modifiedKeys["fontSize"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
        this.placement = (spec) => {
            updates["placement"] = spec;
            delete childBuilders["placement;"];
            modifiedKeys["placement"] = true;
            return this;
        };
    }
}
function patchStaccatissimo(base, builder) { return builder(new StaccatissimoBuilder(base)).patch(); }
exports.patchStaccatissimo = patchStaccatissimo;
function buildStaccatissimo(builder) { return builder(new StaccatissimoBuilder()).build(); }
exports.buildStaccatissimo = buildStaccatissimo;
class SpiccatoBuilder {
    build;
    patch;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    fontFamily;
    fontWeight;
    fontStyle;
    fontSize;
    color;
    placement;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Spiccato";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
        this.fontFamily = (spec) => {
            updates["fontFamily"] = spec;
            delete childBuilders["fontFamily;"];
            modifiedKeys["fontFamily"] = true;
            return this;
        };
        this.fontWeight = (spec) => {
            updates["fontWeight"] = spec;
            delete childBuilders["fontWeight;"];
            modifiedKeys["fontWeight"] = true;
            return this;
        };
        this.fontStyle = (spec) => {
            updates["fontStyle"] = spec;
            delete childBuilders["fontStyle;"];
            modifiedKeys["fontStyle"] = true;
            return this;
        };
        this.fontSize = (spec) => {
            updates["fontSize"] = spec;
            delete childBuilders["fontSize;"];
            modifiedKeys["fontSize"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
        this.placement = (spec) => {
            updates["placement"] = spec;
            delete childBuilders["placement;"];
            modifiedKeys["placement"] = true;
            return this;
        };
    }
}
function patchSpiccato(base, builder) { return builder(new SpiccatoBuilder(base)).patch(); }
exports.patchSpiccato = patchSpiccato;
function buildSpiccato(builder) { return builder(new SpiccatoBuilder()).build(); }
exports.buildSpiccato = buildSpiccato;
class ScoopBuilder {
    build;
    patch;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    fontFamily;
    fontWeight;
    fontStyle;
    fontSize;
    color;
    placement;
    lineType;
    dashLength;
    spaceLength;
    lineShape;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Scoop";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
        this.fontFamily = (spec) => {
            updates["fontFamily"] = spec;
            delete childBuilders["fontFamily;"];
            modifiedKeys["fontFamily"] = true;
            return this;
        };
        this.fontWeight = (spec) => {
            updates["fontWeight"] = spec;
            delete childBuilders["fontWeight;"];
            modifiedKeys["fontWeight"] = true;
            return this;
        };
        this.fontStyle = (spec) => {
            updates["fontStyle"] = spec;
            delete childBuilders["fontStyle;"];
            modifiedKeys["fontStyle"] = true;
            return this;
        };
        this.fontSize = (spec) => {
            updates["fontSize"] = spec;
            delete childBuilders["fontSize;"];
            modifiedKeys["fontSize"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
        this.placement = (spec) => {
            updates["placement"] = spec;
            delete childBuilders["placement;"];
            modifiedKeys["placement"] = true;
            return this;
        };
        this.lineType = (spec) => {
            updates["lineType"] = spec;
            delete childBuilders["lineType;"];
            modifiedKeys["lineType"] = true;
            return this;
        };
        this.dashLength = (spec) => {
            updates["dashLength"] = spec;
            delete childBuilders["dashLength;"];
            modifiedKeys["dashLength"] = true;
            return this;
        };
        this.spaceLength = (spec) => {
            updates["spaceLength"] = spec;
            delete childBuilders["spaceLength;"];
            modifiedKeys["spaceLength"] = true;
            return this;
        };
        this.lineShape = (spec) => {
            updates["lineShape"] = spec;
            delete childBuilders["lineShape;"];
            modifiedKeys["lineShape"] = true;
            return this;
        };
    }
}
function patchScoop(base, builder) { return builder(new ScoopBuilder(base)).patch(); }
exports.patchScoop = patchScoop;
function buildScoop(builder) { return builder(new ScoopBuilder()).build(); }
exports.buildScoop = buildScoop;
class PlopBuilder {
    build;
    patch;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    fontFamily;
    fontWeight;
    fontStyle;
    fontSize;
    color;
    placement;
    lineType;
    dashLength;
    spaceLength;
    lineShape;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Plop";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
        this.fontFamily = (spec) => {
            updates["fontFamily"] = spec;
            delete childBuilders["fontFamily;"];
            modifiedKeys["fontFamily"] = true;
            return this;
        };
        this.fontWeight = (spec) => {
            updates["fontWeight"] = spec;
            delete childBuilders["fontWeight;"];
            modifiedKeys["fontWeight"] = true;
            return this;
        };
        this.fontStyle = (spec) => {
            updates["fontStyle"] = spec;
            delete childBuilders["fontStyle;"];
            modifiedKeys["fontStyle"] = true;
            return this;
        };
        this.fontSize = (spec) => {
            updates["fontSize"] = spec;
            delete childBuilders["fontSize;"];
            modifiedKeys["fontSize"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
        this.placement = (spec) => {
            updates["placement"] = spec;
            delete childBuilders["placement;"];
            modifiedKeys["placement"] = true;
            return this;
        };
        this.lineType = (spec) => {
            updates["lineType"] = spec;
            delete childBuilders["lineType;"];
            modifiedKeys["lineType"] = true;
            return this;
        };
        this.dashLength = (spec) => {
            updates["dashLength"] = spec;
            delete childBuilders["dashLength;"];
            modifiedKeys["dashLength"] = true;
            return this;
        };
        this.spaceLength = (spec) => {
            updates["spaceLength"] = spec;
            delete childBuilders["spaceLength;"];
            modifiedKeys["spaceLength"] = true;
            return this;
        };
        this.lineShape = (spec) => {
            updates["lineShape"] = spec;
            delete childBuilders["lineShape;"];
            modifiedKeys["lineShape"] = true;
            return this;
        };
    }
}
function patchPlop(base, builder) { return builder(new PlopBuilder(base)).patch(); }
exports.patchPlop = patchPlop;
function buildPlop(builder) { return builder(new PlopBuilder()).build(); }
exports.buildPlop = buildPlop;
class DoitBuilder {
    build;
    patch;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    fontFamily;
    fontWeight;
    fontStyle;
    fontSize;
    color;
    placement;
    lineType;
    dashLength;
    spaceLength;
    lineShape;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Doit";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
        this.fontFamily = (spec) => {
            updates["fontFamily"] = spec;
            delete childBuilders["fontFamily;"];
            modifiedKeys["fontFamily"] = true;
            return this;
        };
        this.fontWeight = (spec) => {
            updates["fontWeight"] = spec;
            delete childBuilders["fontWeight;"];
            modifiedKeys["fontWeight"] = true;
            return this;
        };
        this.fontStyle = (spec) => {
            updates["fontStyle"] = spec;
            delete childBuilders["fontStyle;"];
            modifiedKeys["fontStyle"] = true;
            return this;
        };
        this.fontSize = (spec) => {
            updates["fontSize"] = spec;
            delete childBuilders["fontSize;"];
            modifiedKeys["fontSize"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
        this.placement = (spec) => {
            updates["placement"] = spec;
            delete childBuilders["placement;"];
            modifiedKeys["placement"] = true;
            return this;
        };
        this.lineType = (spec) => {
            updates["lineType"] = spec;
            delete childBuilders["lineType;"];
            modifiedKeys["lineType"] = true;
            return this;
        };
        this.dashLength = (spec) => {
            updates["dashLength"] = spec;
            delete childBuilders["dashLength;"];
            modifiedKeys["dashLength"] = true;
            return this;
        };
        this.spaceLength = (spec) => {
            updates["spaceLength"] = spec;
            delete childBuilders["spaceLength;"];
            modifiedKeys["spaceLength"] = true;
            return this;
        };
        this.lineShape = (spec) => {
            updates["lineShape"] = spec;
            delete childBuilders["lineShape;"];
            modifiedKeys["lineShape"] = true;
            return this;
        };
    }
}
function patchDoit(base, builder) { return builder(new DoitBuilder(base)).patch(); }
exports.patchDoit = patchDoit;
function buildDoit(builder) { return builder(new DoitBuilder()).build(); }
exports.buildDoit = buildDoit;
class FalloffBuilder {
    build;
    patch;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    fontFamily;
    fontWeight;
    fontStyle;
    fontSize;
    color;
    placement;
    lineType;
    dashLength;
    spaceLength;
    lineShape;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Falloff";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
        this.fontFamily = (spec) => {
            updates["fontFamily"] = spec;
            delete childBuilders["fontFamily;"];
            modifiedKeys["fontFamily"] = true;
            return this;
        };
        this.fontWeight = (spec) => {
            updates["fontWeight"] = spec;
            delete childBuilders["fontWeight;"];
            modifiedKeys["fontWeight"] = true;
            return this;
        };
        this.fontStyle = (spec) => {
            updates["fontStyle"] = spec;
            delete childBuilders["fontStyle;"];
            modifiedKeys["fontStyle"] = true;
            return this;
        };
        this.fontSize = (spec) => {
            updates["fontSize"] = spec;
            delete childBuilders["fontSize;"];
            modifiedKeys["fontSize"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
        this.placement = (spec) => {
            updates["placement"] = spec;
            delete childBuilders["placement;"];
            modifiedKeys["placement"] = true;
            return this;
        };
        this.lineType = (spec) => {
            updates["lineType"] = spec;
            delete childBuilders["lineType;"];
            modifiedKeys["lineType"] = true;
            return this;
        };
        this.dashLength = (spec) => {
            updates["dashLength"] = spec;
            delete childBuilders["dashLength;"];
            modifiedKeys["dashLength"] = true;
            return this;
        };
        this.spaceLength = (spec) => {
            updates["spaceLength"] = spec;
            delete childBuilders["spaceLength;"];
            modifiedKeys["spaceLength"] = true;
            return this;
        };
        this.lineShape = (spec) => {
            updates["lineShape"] = spec;
            delete childBuilders["lineShape;"];
            modifiedKeys["lineShape"] = true;
            return this;
        };
    }
}
function patchFalloff(base, builder) { return builder(new FalloffBuilder(base)).patch(); }
exports.patchFalloff = patchFalloff;
function buildFalloff(builder) { return builder(new FalloffBuilder()).build(); }
exports.buildFalloff = buildFalloff;
class BreathMarkBuilder {
    build;
    patch;
    type;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    fontFamily;
    fontWeight;
    fontStyle;
    fontSize;
    color;
    placement;
    lineType;
    dashLength;
    spaceLength;
    lineShape;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["type"]) ||
                childBuilders["type"] !== undefined ||
                updates.type !== undefined, "type is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "BreathMark";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.type = (spec) => {
            updates["type"] = spec;
            delete childBuilders["type;"];
            modifiedKeys["type"] = true;
            return this;
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
        this.fontFamily = (spec) => {
            updates["fontFamily"] = spec;
            delete childBuilders["fontFamily;"];
            modifiedKeys["fontFamily"] = true;
            return this;
        };
        this.fontWeight = (spec) => {
            updates["fontWeight"] = spec;
            delete childBuilders["fontWeight;"];
            modifiedKeys["fontWeight"] = true;
            return this;
        };
        this.fontStyle = (spec) => {
            updates["fontStyle"] = spec;
            delete childBuilders["fontStyle;"];
            modifiedKeys["fontStyle"] = true;
            return this;
        };
        this.fontSize = (spec) => {
            updates["fontSize"] = spec;
            delete childBuilders["fontSize;"];
            modifiedKeys["fontSize"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
        this.placement = (spec) => {
            updates["placement"] = spec;
            delete childBuilders["placement;"];
            modifiedKeys["placement"] = true;
            return this;
        };
        this.lineType = (spec) => {
            updates["lineType"] = spec;
            delete childBuilders["lineType;"];
            modifiedKeys["lineType"] = true;
            return this;
        };
        this.dashLength = (spec) => {
            updates["dashLength"] = spec;
            delete childBuilders["dashLength;"];
            modifiedKeys["dashLength"] = true;
            return this;
        };
        this.spaceLength = (spec) => {
            updates["spaceLength"] = spec;
            delete childBuilders["spaceLength;"];
            modifiedKeys["spaceLength"] = true;
            return this;
        };
        this.lineShape = (spec) => {
            updates["lineShape"] = spec;
            delete childBuilders["lineShape;"];
            modifiedKeys["lineShape"] = true;
            return this;
        };
    }
}
function patchBreathMark(base, builder) { return builder(new BreathMarkBuilder(base)).patch(); }
exports.patchBreathMark = patchBreathMark;
function buildBreathMark(builder) { return builder(new BreathMarkBuilder()).build(); }
exports.buildBreathMark = buildBreathMark;
class CaesuraBuilder {
    build;
    patch;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    fontFamily;
    fontWeight;
    fontStyle;
    fontSize;
    color;
    placement;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Caesura";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
        this.fontFamily = (spec) => {
            updates["fontFamily"] = spec;
            delete childBuilders["fontFamily;"];
            modifiedKeys["fontFamily"] = true;
            return this;
        };
        this.fontWeight = (spec) => {
            updates["fontWeight"] = spec;
            delete childBuilders["fontWeight;"];
            modifiedKeys["fontWeight"] = true;
            return this;
        };
        this.fontStyle = (spec) => {
            updates["fontStyle"] = spec;
            delete childBuilders["fontStyle;"];
            modifiedKeys["fontStyle"] = true;
            return this;
        };
        this.fontSize = (spec) => {
            updates["fontSize"] = spec;
            delete childBuilders["fontSize;"];
            modifiedKeys["fontSize"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
        this.placement = (spec) => {
            updates["placement"] = spec;
            delete childBuilders["placement;"];
            modifiedKeys["placement"] = true;
            return this;
        };
    }
}
function patchCaesura(base, builder) { return builder(new CaesuraBuilder(base)).patch(); }
exports.patchCaesura = patchCaesura;
function buildCaesura(builder) { return builder(new CaesuraBuilder()).build(); }
exports.buildCaesura = buildCaesura;
class StressBuilder {
    build;
    patch;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    fontFamily;
    fontWeight;
    fontStyle;
    fontSize;
    color;
    placement;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Stress";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
        this.fontFamily = (spec) => {
            updates["fontFamily"] = spec;
            delete childBuilders["fontFamily;"];
            modifiedKeys["fontFamily"] = true;
            return this;
        };
        this.fontWeight = (spec) => {
            updates["fontWeight"] = spec;
            delete childBuilders["fontWeight;"];
            modifiedKeys["fontWeight"] = true;
            return this;
        };
        this.fontStyle = (spec) => {
            updates["fontStyle"] = spec;
            delete childBuilders["fontStyle;"];
            modifiedKeys["fontStyle"] = true;
            return this;
        };
        this.fontSize = (spec) => {
            updates["fontSize"] = spec;
            delete childBuilders["fontSize;"];
            modifiedKeys["fontSize"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
        this.placement = (spec) => {
            updates["placement"] = spec;
            delete childBuilders["placement;"];
            modifiedKeys["placement"] = true;
            return this;
        };
    }
}
function patchStress(base, builder) { return builder(new StressBuilder(base)).patch(); }
exports.patchStress = patchStress;
function buildStress(builder) { return builder(new StressBuilder()).build(); }
exports.buildStress = buildStress;
class UnstressBuilder {
    build;
    patch;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    fontFamily;
    fontWeight;
    fontStyle;
    fontSize;
    color;
    placement;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Unstress";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
        this.fontFamily = (spec) => {
            updates["fontFamily"] = spec;
            delete childBuilders["fontFamily;"];
            modifiedKeys["fontFamily"] = true;
            return this;
        };
        this.fontWeight = (spec) => {
            updates["fontWeight"] = spec;
            delete childBuilders["fontWeight;"];
            modifiedKeys["fontWeight"] = true;
            return this;
        };
        this.fontStyle = (spec) => {
            updates["fontStyle"] = spec;
            delete childBuilders["fontStyle;"];
            modifiedKeys["fontStyle"] = true;
            return this;
        };
        this.fontSize = (spec) => {
            updates["fontSize"] = spec;
            delete childBuilders["fontSize;"];
            modifiedKeys["fontSize"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
        this.placement = (spec) => {
            updates["placement"] = spec;
            delete childBuilders["placement;"];
            modifiedKeys["placement"] = true;
            return this;
        };
    }
}
function patchUnstress(base, builder) { return builder(new UnstressBuilder(base)).patch(); }
exports.patchUnstress = patchUnstress;
function buildUnstress(builder) { return builder(new UnstressBuilder()).build(); }
exports.buildUnstress = buildUnstress;
class OtherArticulationBuilder {
    build;
    patch;
    data;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    fontFamily;
    fontWeight;
    fontStyle;
    fontSize;
    color;
    placement;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["data"]) ||
                childBuilders["data"] !== undefined ||
                updates.data !== undefined, "data is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "OtherArticulation";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.data = (spec) => {
            updates["data"] = spec;
            delete childBuilders["data;"];
            modifiedKeys["data"] = true;
            return this;
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
        this.fontFamily = (spec) => {
            updates["fontFamily"] = spec;
            delete childBuilders["fontFamily;"];
            modifiedKeys["fontFamily"] = true;
            return this;
        };
        this.fontWeight = (spec) => {
            updates["fontWeight"] = spec;
            delete childBuilders["fontWeight;"];
            modifiedKeys["fontWeight"] = true;
            return this;
        };
        this.fontStyle = (spec) => {
            updates["fontStyle"] = spec;
            delete childBuilders["fontStyle;"];
            modifiedKeys["fontStyle"] = true;
            return this;
        };
        this.fontSize = (spec) => {
            updates["fontSize"] = spec;
            delete childBuilders["fontSize;"];
            modifiedKeys["fontSize"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
        this.placement = (spec) => {
            updates["placement"] = spec;
            delete childBuilders["placement;"];
            modifiedKeys["placement"] = true;
            return this;
        };
    }
}
function patchOtherArticulation(base, builder) { return builder(new OtherArticulationBuilder(base)).patch(); }
exports.patchOtherArticulation = patchOtherArticulation;
function buildOtherArticulation(builder) { return builder(new OtherArticulationBuilder()).build(); }
exports.buildOtherArticulation = buildOtherArticulation;
class ArpeggiateBuilder {
    build;
    patch;
    number;
    direction;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    color;
    placement;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Arpeggiate";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.number = (spec) => {
            updates["number"] = spec;
            delete childBuilders["number;"];
            modifiedKeys["number"] = true;
            return this;
        };
        this.direction = (spec) => {
            updates["direction"] = spec;
            delete childBuilders["direction;"];
            modifiedKeys["direction"] = true;
            return this;
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
        this.placement = (spec) => {
            updates["placement"] = spec;
            delete childBuilders["placement;"];
            modifiedKeys["placement"] = true;
            return this;
        };
    }
}
function patchArpeggiate(base, builder) { return builder(new ArpeggiateBuilder(base)).patch(); }
exports.patchArpeggiate = patchArpeggiate;
function buildArpeggiate(builder) { return builder(new ArpeggiateBuilder()).build(); }
exports.buildArpeggiate = buildArpeggiate;
class NonArpeggiateBuilder {
    build;
    patch;
    number;
    type;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    color;
    placement;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["type"]) ||
                childBuilders["type"] !== undefined ||
                updates.type !== undefined, "type is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "NonArpeggiate";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.number = (spec) => {
            updates["number"] = spec;
            delete childBuilders["number;"];
            modifiedKeys["number"] = true;
            return this;
        };
        this.type = (spec) => {
            updates["type"] = spec;
            delete childBuilders["type;"];
            modifiedKeys["type"] = true;
            return this;
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
        this.placement = (spec) => {
            updates["placement"] = spec;
            delete childBuilders["placement;"];
            modifiedKeys["placement"] = true;
            return this;
        };
    }
}
function patchNonArpeggiate(base, builder) { return builder(new NonArpeggiateBuilder(base)).patch(); }
exports.patchNonArpeggiate = patchNonArpeggiate;
function buildNonArpeggiate(builder) { return builder(new NonArpeggiateBuilder()).build(); }
exports.buildNonArpeggiate = buildNonArpeggiate;
class LaughingBuilder {
    build;
    patch;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Laughing";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
    }
}
function patchLaughing(base, builder) { return builder(new LaughingBuilder(base)).patch(); }
exports.patchLaughing = patchLaughing;
function buildLaughing(builder) { return builder(new LaughingBuilder()).build(); }
exports.buildLaughing = buildLaughing;
class HummingBuilder {
    build;
    patch;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Humming";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
    }
}
function patchHumming(base, builder) { return builder(new HummingBuilder(base)).patch(); }
exports.patchHumming = patchHumming;
function buildHumming(builder) { return builder(new HummingBuilder()).build(); }
exports.buildHumming = buildHumming;
class EndLineBuilder {
    build;
    patch;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "EndLine";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
    }
}
function patchEndLine(base, builder) { return builder(new EndLineBuilder(base)).patch(); }
exports.patchEndLine = patchEndLine;
function buildEndLine(builder) { return builder(new EndLineBuilder()).build(); }
exports.buildEndLine = buildEndLine;
class EndParagraphBuilder {
    build;
    patch;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "EndParagraph";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
    }
}
function patchEndParagraph(base, builder) { return builder(new EndParagraphBuilder(base)).patch(); }
exports.patchEndParagraph = patchEndParagraph;
function buildEndParagraph(builder) { return builder(new EndParagraphBuilder()).build(); }
exports.buildEndParagraph = buildEndParagraph;
class LyricPartsBuilder {
    build;
    patch;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "LyricParts";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
    }
}
function patchLyricParts(base, builder) { return builder(new LyricPartsBuilder(base)).patch(); }
exports.patchLyricParts = patchLyricParts;
function buildLyricParts(builder) { return builder(new LyricPartsBuilder()).build(); }
exports.buildLyricParts = buildLyricParts;
class LyricBuilder {
    build;
    patch;
    lyricParts;
    number;
    name;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    color;
    printObject;
    justify;
    placement;
    footnote;
    level;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["lyricParts"]) ||
                childBuilders["lyricParts"] !== undefined ||
                updates.lyricParts !== undefined, "lyricParts is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Lyric";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.lyricParts = (spec) => {
            updates["lyricParts"] = spec;
            delete childBuilders["lyricParts;"];
            modifiedKeys["lyricParts"] = true;
            return this;
        };
        this.number = (spec) => {
            updates["number"] = spec;
            delete childBuilders["number;"];
            modifiedKeys["number"] = true;
            return this;
        };
        this.name = (spec) => {
            updates["name"] = spec;
            delete childBuilders["name;"];
            modifiedKeys["name"] = true;
            return this;
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
        this.printObject = (spec) => {
            updates["printObject"] = spec;
            delete childBuilders["printObject;"];
            modifiedKeys["printObject"] = true;
            return this;
        };
        this.justify = (spec) => {
            updates["justify"] = spec;
            delete childBuilders["justify;"];
            modifiedKeys["justify"] = true;
            return this;
        };
        this.placement = (spec) => {
            updates["placement"] = spec;
            delete childBuilders["placement;"];
            modifiedKeys["placement"] = true;
            return this;
        };
        this.footnote = (build) => {
            if (typeof build === 'function') {
                delete updates["footnote"];
                const builder = build(new FootnoteBuilder(original && original["footnote"]));
                if (!original)
                    updates["footnote"] = builder.build();
                else
                    childBuilders["footnote"] = builder;
            }
            else {
                updates.footnote = build;
                delete childBuilders["footnote;"];
            }
            modifiedKeys["footnote"] = true;
            return this;
        };
        this.level = (build) => {
            if (typeof build === 'function') {
                delete updates["level"];
                const builder = build(new LevelBuilder(original && original["level"]));
                if (!original)
                    updates["level"] = builder.build();
                else
                    childBuilders["level"] = builder;
            }
            else {
                updates.level = build;
                delete childBuilders["level;"];
            }
            modifiedKeys["level"] = true;
            return this;
        };
    }
}
function patchLyric(base, builder) { return builder(new LyricBuilder(base)).patch(); }
exports.patchLyric = patchLyric;
function buildLyric(builder) { return builder(new LyricBuilder()).build(); }
exports.buildLyric = buildLyric;
class TextBuilder {
    build;
    patch;
    data;
    fontFamily;
    fontWeight;
    fontStyle;
    fontSize;
    color;
    underline;
    overline;
    lineThrough;
    rotation;
    letterSpacing;
    dir;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["data"]) ||
                childBuilders["data"] !== undefined ||
                updates.data !== undefined, "data is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Text";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.data = (spec) => {
            updates["data"] = spec;
            delete childBuilders["data;"];
            modifiedKeys["data"] = true;
            return this;
        };
        this.fontFamily = (spec) => {
            updates["fontFamily"] = spec;
            delete childBuilders["fontFamily;"];
            modifiedKeys["fontFamily"] = true;
            return this;
        };
        this.fontWeight = (spec) => {
            updates["fontWeight"] = spec;
            delete childBuilders["fontWeight;"];
            modifiedKeys["fontWeight"] = true;
            return this;
        };
        this.fontStyle = (spec) => {
            updates["fontStyle"] = spec;
            delete childBuilders["fontStyle;"];
            modifiedKeys["fontStyle"] = true;
            return this;
        };
        this.fontSize = (spec) => {
            updates["fontSize"] = spec;
            delete childBuilders["fontSize;"];
            modifiedKeys["fontSize"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
        this.underline = (spec) => {
            updates["underline"] = spec;
            delete childBuilders["underline;"];
            modifiedKeys["underline"] = true;
            return this;
        };
        this.overline = (spec) => {
            updates["overline"] = spec;
            delete childBuilders["overline;"];
            modifiedKeys["overline"] = true;
            return this;
        };
        this.lineThrough = (spec) => {
            updates["lineThrough"] = spec;
            delete childBuilders["lineThrough;"];
            modifiedKeys["lineThrough"] = true;
            return this;
        };
        this.rotation = (spec) => {
            updates["rotation"] = spec;
            delete childBuilders["rotation;"];
            modifiedKeys["rotation"] = true;
            return this;
        };
        this.letterSpacing = (spec) => {
            updates["letterSpacing"] = spec;
            delete childBuilders["letterSpacing;"];
            modifiedKeys["letterSpacing"] = true;
            return this;
        };
        this.dir = (spec) => {
            updates["dir"] = spec;
            delete childBuilders["dir;"];
            modifiedKeys["dir"] = true;
            return this;
        };
    }
}
function patchText(base, builder) { return builder(new TextBuilder(base)).patch(); }
exports.patchText = patchText;
function buildText(builder) { return builder(new TextBuilder()).build(); }
exports.buildText = buildText;
class SyllabicBuilder {
    build;
    patch;
    data;
    fontFamily;
    fontWeight;
    fontStyle;
    fontSize;
    color;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["data"]) ||
                childBuilders["data"] !== undefined ||
                updates.data !== undefined, "data is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Syllabic";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.data = (spec) => {
            updates["data"] = spec;
            delete childBuilders["data;"];
            modifiedKeys["data"] = true;
            return this;
        };
        this.fontFamily = (spec) => {
            updates["fontFamily"] = spec;
            delete childBuilders["fontFamily;"];
            modifiedKeys["fontFamily"] = true;
            return this;
        };
        this.fontWeight = (spec) => {
            updates["fontWeight"] = spec;
            delete childBuilders["fontWeight;"];
            modifiedKeys["fontWeight"] = true;
            return this;
        };
        this.fontStyle = (spec) => {
            updates["fontStyle"] = spec;
            delete childBuilders["fontStyle;"];
            modifiedKeys["fontStyle"] = true;
            return this;
        };
        this.fontSize = (spec) => {
            updates["fontSize"] = spec;
            delete childBuilders["fontSize;"];
            modifiedKeys["fontSize"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
    }
}
function patchSyllabic(base, builder) { return builder(new SyllabicBuilder(base)).patch(); }
exports.patchSyllabic = patchSyllabic;
function buildSyllabic(builder) { return builder(new SyllabicBuilder()).build(); }
exports.buildSyllabic = buildSyllabic;
class ElisionBuilder {
    build;
    patch;
    data;
    fontFamily;
    fontWeight;
    fontStyle;
    fontSize;
    color;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["data"]) ||
                childBuilders["data"] !== undefined ||
                updates.data !== undefined, "data is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Elision";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.data = (spec) => {
            updates["data"] = spec;
            delete childBuilders["data;"];
            modifiedKeys["data"] = true;
            return this;
        };
        this.fontFamily = (spec) => {
            updates["fontFamily"] = spec;
            delete childBuilders["fontFamily;"];
            modifiedKeys["fontFamily"] = true;
            return this;
        };
        this.fontWeight = (spec) => {
            updates["fontWeight"] = spec;
            delete childBuilders["fontWeight;"];
            modifiedKeys["fontWeight"] = true;
            return this;
        };
        this.fontStyle = (spec) => {
            updates["fontStyle"] = spec;
            delete childBuilders["fontStyle;"];
            modifiedKeys["fontStyle"] = true;
            return this;
        };
        this.fontSize = (spec) => {
            updates["fontSize"] = spec;
            delete childBuilders["fontSize;"];
            modifiedKeys["fontSize"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
    }
}
function patchElision(base, builder) { return builder(new ElisionBuilder(base)).patch(); }
exports.patchElision = patchElision;
function buildElision(builder) { return builder(new ElisionBuilder()).build(); }
exports.buildElision = buildElision;
class ExtendBuilder {
    build;
    patch;
    type;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    fontFamily;
    fontWeight;
    fontStyle;
    fontSize;
    color;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Extend";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.type = (spec) => {
            updates["type"] = spec;
            delete childBuilders["type;"];
            modifiedKeys["type"] = true;
            return this;
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
        this.fontFamily = (spec) => {
            updates["fontFamily"] = spec;
            delete childBuilders["fontFamily;"];
            modifiedKeys["fontFamily"] = true;
            return this;
        };
        this.fontWeight = (spec) => {
            updates["fontWeight"] = spec;
            delete childBuilders["fontWeight;"];
            modifiedKeys["fontWeight"] = true;
            return this;
        };
        this.fontStyle = (spec) => {
            updates["fontStyle"] = spec;
            delete childBuilders["fontStyle;"];
            modifiedKeys["fontStyle"] = true;
            return this;
        };
        this.fontSize = (spec) => {
            updates["fontSize"] = spec;
            delete childBuilders["fontSize;"];
            modifiedKeys["fontSize"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
    }
}
function patchExtend(base, builder) { return builder(new ExtendBuilder(base)).patch(); }
exports.patchExtend = patchExtend;
function buildExtend(builder) { return builder(new ExtendBuilder()).build(); }
exports.buildExtend = buildExtend;
class FiguredBassBuilder {
    build;
    patch;
    figuresAt;
    figuresSplice;
    figures;
    duration;
    parentheses;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    fontFamily;
    fontWeight;
    fontStyle;
    fontSize;
    color;
    footnote;
    level;
    printDot;
    printLyric;
    printObject;
    printSpacing;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["figures"]) ||
                childBuilders["figures"] !== undefined ||
                updates.figures !== undefined, "figures is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "FiguredBass";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.figures = (spec) => {
            updates["figures"] = spec;
            delete childBuilders["figures;"];
            modifiedKeys["figures"] = true;
            return this;
        };
        this.figuresAt = (idx, build) => {
            makeReference("figures");
            if (frozen["figures"][idx]) {
                throw new Error("Patching figures." + idx + " twice in a builder is unsupported.");
            }
            if (original && original._snapshot && original._snapshot["figures"] && original._snapshot["figures"][idx] && !original["figures"][idx]) {
                // Clone snapshot.
                patches.push({ p: ["figures", idx], li: original._snapshot["figures"] });
            }
            if (typeof build === 'function' && reference["figures"][idx]) {
                let patch = build(new FigureBuilder(reference["figures"][idx])).patch();
                patches = patches.concat(patch.map(patch => {
                    // TODO: detach?
                    patch.p = ["figures", idx].concat(patch.p);
                    return patch;
                }));
                frozen["figures"][idx] = true;
                return this;
            }
            let update = typeof build === 'function' ? build(new FigureBuilder(reference["figures"][idx])).build() : build;
            if (original) {
                patches.push({ p: ["figures", idx], li: update });
            }
            else {
                updates["figures"] = reference["figures"]; // TODO: Merge?
            }
            reference["figures"][idx] = update;
            frozen["figures"][idx] = true;
            return this;
        };
        this.figuresSplice = (start, deleteCount, ...items) => {
            makeReference("figures");
            let idx = start;
            if (original) {
                for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
                    if (frozen["figures"][idx]) {
                        throw new Error("Replacing figures." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["figures"][idx];
                    patches.push({ p: ["figures", idx], ld, li: items[idx - start] });
                    frozen["figures"][idx] = true;
                }
                for (; idx < start + deleteCount; ++idx) {
                    if (frozen["figures"][idx]) {
                        throw new Error("Removing figures." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["figures"][idx];
                    patches.push({ p: ["figures", idx], ld });
                }
                for (; idx < start + items.length; ++idx) {
                    patches.push({ p: ["figures", idx], li: items[idx - start] });
                    frozen["figures"][idx] = true;
                }
            }
            reference["figures"].splice(start, deleteCount, ...items);
            updates["figures"] = reference["figures"];
            frozen["figures"].splice(start, deleteCount, ...items.map(i => true));
            return this;
        };
        this.duration = (spec) => {
            updates["duration"] = spec;
            delete childBuilders["duration;"];
            modifiedKeys["duration"] = true;
            return this;
        };
        this.parentheses = (spec) => {
            updates["parentheses"] = spec;
            delete childBuilders["parentheses;"];
            modifiedKeys["parentheses"] = true;
            return this;
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
        this.fontFamily = (spec) => {
            updates["fontFamily"] = spec;
            delete childBuilders["fontFamily;"];
            modifiedKeys["fontFamily"] = true;
            return this;
        };
        this.fontWeight = (spec) => {
            updates["fontWeight"] = spec;
            delete childBuilders["fontWeight;"];
            modifiedKeys["fontWeight"] = true;
            return this;
        };
        this.fontStyle = (spec) => {
            updates["fontStyle"] = spec;
            delete childBuilders["fontStyle;"];
            modifiedKeys["fontStyle"] = true;
            return this;
        };
        this.fontSize = (spec) => {
            updates["fontSize"] = spec;
            delete childBuilders["fontSize;"];
            modifiedKeys["fontSize"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
        this.footnote = (build) => {
            if (typeof build === 'function') {
                delete updates["footnote"];
                const builder = build(new FootnoteBuilder(original && original["footnote"]));
                if (!original)
                    updates["footnote"] = builder.build();
                else
                    childBuilders["footnote"] = builder;
            }
            else {
                updates.footnote = build;
                delete childBuilders["footnote;"];
            }
            modifiedKeys["footnote"] = true;
            return this;
        };
        this.level = (build) => {
            if (typeof build === 'function') {
                delete updates["level"];
                const builder = build(new LevelBuilder(original && original["level"]));
                if (!original)
                    updates["level"] = builder.build();
                else
                    childBuilders["level"] = builder;
            }
            else {
                updates.level = build;
                delete childBuilders["level;"];
            }
            modifiedKeys["level"] = true;
            return this;
        };
        this.printDot = (spec) => {
            updates["printDot"] = spec;
            delete childBuilders["printDot;"];
            modifiedKeys["printDot"] = true;
            return this;
        };
        this.printLyric = (spec) => {
            updates["printLyric"] = spec;
            delete childBuilders["printLyric;"];
            modifiedKeys["printLyric"] = true;
            return this;
        };
        this.printObject = (spec) => {
            updates["printObject"] = spec;
            delete childBuilders["printObject;"];
            modifiedKeys["printObject"] = true;
            return this;
        };
        this.printSpacing = (spec) => {
            updates["printSpacing"] = spec;
            delete childBuilders["printSpacing;"];
            modifiedKeys["printSpacing"] = true;
            return this;
        };
    }
}
function patchFiguredBass(base, builder) { return builder(new FiguredBassBuilder(base)).patch(); }
exports.patchFiguredBass = patchFiguredBass;
function buildFiguredBass(builder) { return builder(new FiguredBassBuilder()).build(); }
exports.buildFiguredBass = buildFiguredBass;
class FigureBuilder {
    build;
    patch;
    prefix;
    figureNumber;
    extend;
    suffix;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    fontFamily;
    fontWeight;
    fontStyle;
    fontSize;
    color;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Figure";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.prefix = (build) => {
            if (typeof build === 'function') {
                delete updates["prefix"];
                const builder = build(new PrefixBuilder(original && original["prefix"]));
                if (!original)
                    updates["prefix"] = builder.build();
                else
                    childBuilders["prefix"] = builder;
            }
            else {
                updates.prefix = build;
                delete childBuilders["prefix;"];
            }
            modifiedKeys["prefix"] = true;
            return this;
        };
        this.figureNumber = (build) => {
            if (typeof build === 'function') {
                delete updates["figureNumber"];
                const builder = build(new FigureNumberBuilder(original && original["figureNumber"]));
                if (!original)
                    updates["figureNumber"] = builder.build();
                else
                    childBuilders["figureNumber"] = builder;
            }
            else {
                updates.figureNumber = build;
                delete childBuilders["figureNumber;"];
            }
            modifiedKeys["figureNumber"] = true;
            return this;
        };
        this.extend = (build) => {
            if (typeof build === 'function') {
                delete updates["extend"];
                const builder = build(new ExtendBuilder(original && original["extend"]));
                if (!original)
                    updates["extend"] = builder.build();
                else
                    childBuilders["extend"] = builder;
            }
            else {
                updates.extend = build;
                delete childBuilders["extend;"];
            }
            modifiedKeys["extend"] = true;
            return this;
        };
        this.suffix = (build) => {
            if (typeof build === 'function') {
                delete updates["suffix"];
                const builder = build(new SuffixBuilder(original && original["suffix"]));
                if (!original)
                    updates["suffix"] = builder.build();
                else
                    childBuilders["suffix"] = builder;
            }
            else {
                updates.suffix = build;
                delete childBuilders["suffix;"];
            }
            modifiedKeys["suffix"] = true;
            return this;
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
        this.fontFamily = (spec) => {
            updates["fontFamily"] = spec;
            delete childBuilders["fontFamily;"];
            modifiedKeys["fontFamily"] = true;
            return this;
        };
        this.fontWeight = (spec) => {
            updates["fontWeight"] = spec;
            delete childBuilders["fontWeight;"];
            modifiedKeys["fontWeight"] = true;
            return this;
        };
        this.fontStyle = (spec) => {
            updates["fontStyle"] = spec;
            delete childBuilders["fontStyle;"];
            modifiedKeys["fontStyle"] = true;
            return this;
        };
        this.fontSize = (spec) => {
            updates["fontSize"] = spec;
            delete childBuilders["fontSize;"];
            modifiedKeys["fontSize"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
    }
}
function patchFigure(base, builder) { return builder(new FigureBuilder(base)).patch(); }
exports.patchFigure = patchFigure;
function buildFigure(builder) { return builder(new FigureBuilder()).build(); }
exports.buildFigure = buildFigure;
class PrefixBuilder {
    build;
    patch;
    data;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    fontFamily;
    fontWeight;
    fontStyle;
    fontSize;
    color;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["data"]) ||
                childBuilders["data"] !== undefined ||
                updates.data !== undefined, "data is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Prefix";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.data = (spec) => {
            updates["data"] = spec;
            delete childBuilders["data;"];
            modifiedKeys["data"] = true;
            return this;
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
        this.fontFamily = (spec) => {
            updates["fontFamily"] = spec;
            delete childBuilders["fontFamily;"];
            modifiedKeys["fontFamily"] = true;
            return this;
        };
        this.fontWeight = (spec) => {
            updates["fontWeight"] = spec;
            delete childBuilders["fontWeight;"];
            modifiedKeys["fontWeight"] = true;
            return this;
        };
        this.fontStyle = (spec) => {
            updates["fontStyle"] = spec;
            delete childBuilders["fontStyle;"];
            modifiedKeys["fontStyle"] = true;
            return this;
        };
        this.fontSize = (spec) => {
            updates["fontSize"] = spec;
            delete childBuilders["fontSize;"];
            modifiedKeys["fontSize"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
    }
}
function patchPrefix(base, builder) { return builder(new PrefixBuilder(base)).patch(); }
exports.patchPrefix = patchPrefix;
function buildPrefix(builder) { return builder(new PrefixBuilder()).build(); }
exports.buildPrefix = buildPrefix;
class FigureNumberBuilder {
    build;
    patch;
    data;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    fontFamily;
    fontWeight;
    fontStyle;
    fontSize;
    color;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["data"]) ||
                childBuilders["data"] !== undefined ||
                updates.data !== undefined, "data is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "FigureNumber";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.data = (spec) => {
            updates["data"] = spec;
            delete childBuilders["data;"];
            modifiedKeys["data"] = true;
            return this;
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
        this.fontFamily = (spec) => {
            updates["fontFamily"] = spec;
            delete childBuilders["fontFamily;"];
            modifiedKeys["fontFamily"] = true;
            return this;
        };
        this.fontWeight = (spec) => {
            updates["fontWeight"] = spec;
            delete childBuilders["fontWeight;"];
            modifiedKeys["fontWeight"] = true;
            return this;
        };
        this.fontStyle = (spec) => {
            updates["fontStyle"] = spec;
            delete childBuilders["fontStyle;"];
            modifiedKeys["fontStyle"] = true;
            return this;
        };
        this.fontSize = (spec) => {
            updates["fontSize"] = spec;
            delete childBuilders["fontSize;"];
            modifiedKeys["fontSize"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
    }
}
function patchFigureNumber(base, builder) { return builder(new FigureNumberBuilder(base)).patch(); }
exports.patchFigureNumber = patchFigureNumber;
function buildFigureNumber(builder) { return builder(new FigureNumberBuilder()).build(); }
exports.buildFigureNumber = buildFigureNumber;
class SuffixBuilder {
    build;
    patch;
    data;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    fontFamily;
    fontWeight;
    fontStyle;
    fontSize;
    color;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["data"]) ||
                childBuilders["data"] !== undefined ||
                updates.data !== undefined, "data is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Suffix";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.data = (spec) => {
            updates["data"] = spec;
            delete childBuilders["data;"];
            modifiedKeys["data"] = true;
            return this;
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
        this.fontFamily = (spec) => {
            updates["fontFamily"] = spec;
            delete childBuilders["fontFamily;"];
            modifiedKeys["fontFamily"] = true;
            return this;
        };
        this.fontWeight = (spec) => {
            updates["fontWeight"] = spec;
            delete childBuilders["fontWeight;"];
            modifiedKeys["fontWeight"] = true;
            return this;
        };
        this.fontStyle = (spec) => {
            updates["fontStyle"] = spec;
            delete childBuilders["fontStyle;"];
            modifiedKeys["fontStyle"] = true;
            return this;
        };
        this.fontSize = (spec) => {
            updates["fontSize"] = spec;
            delete childBuilders["fontSize;"];
            modifiedKeys["fontSize"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
    }
}
function patchSuffix(base, builder) { return builder(new SuffixBuilder(base)).patch(); }
exports.patchSuffix = patchSuffix;
function buildSuffix(builder) { return builder(new SuffixBuilder()).build(); }
exports.buildSuffix = buildSuffix;
class BackupBuilder {
    build;
    patch;
    duration;
    footnote;
    level;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["duration"]) ||
                childBuilders["duration"] !== undefined ||
                updates.duration !== undefined, "duration is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Backup";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.duration = (spec) => {
            updates["duration"] = spec;
            delete childBuilders["duration;"];
            modifiedKeys["duration"] = true;
            return this;
        };
        this.footnote = (build) => {
            if (typeof build === 'function') {
                delete updates["footnote"];
                const builder = build(new FootnoteBuilder(original && original["footnote"]));
                if (!original)
                    updates["footnote"] = builder.build();
                else
                    childBuilders["footnote"] = builder;
            }
            else {
                updates.footnote = build;
                delete childBuilders["footnote;"];
            }
            modifiedKeys["footnote"] = true;
            return this;
        };
        this.level = (build) => {
            if (typeof build === 'function') {
                delete updates["level"];
                const builder = build(new LevelBuilder(original && original["level"]));
                if (!original)
                    updates["level"] = builder.build();
                else
                    childBuilders["level"] = builder;
            }
            else {
                updates.level = build;
                delete childBuilders["level;"];
            }
            modifiedKeys["level"] = true;
            return this;
        };
    }
}
function patchBackup(base, builder) { return builder(new BackupBuilder(base)).patch(); }
exports.patchBackup = patchBackup;
function buildBackup(builder) { return builder(new BackupBuilder()).build(); }
exports.buildBackup = buildBackup;
class ForwardBuilder {
    build;
    patch;
    duration;
    staff;
    voice;
    footnote;
    level;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["duration"]) ||
                childBuilders["duration"] !== undefined ||
                updates.duration !== undefined, "duration is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Forward";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.duration = (spec) => {
            updates["duration"] = spec;
            delete childBuilders["duration;"];
            modifiedKeys["duration"] = true;
            return this;
        };
        this.staff = (spec) => {
            updates["staff"] = spec;
            delete childBuilders["staff;"];
            modifiedKeys["staff"] = true;
            return this;
        };
        this.voice = (spec) => {
            updates["voice"] = spec;
            delete childBuilders["voice;"];
            modifiedKeys["voice"] = true;
            return this;
        };
        this.footnote = (build) => {
            if (typeof build === 'function') {
                delete updates["footnote"];
                const builder = build(new FootnoteBuilder(original && original["footnote"]));
                if (!original)
                    updates["footnote"] = builder.build();
                else
                    childBuilders["footnote"] = builder;
            }
            else {
                updates.footnote = build;
                delete childBuilders["footnote;"];
            }
            modifiedKeys["footnote"] = true;
            return this;
        };
        this.level = (build) => {
            if (typeof build === 'function') {
                delete updates["level"];
                const builder = build(new LevelBuilder(original && original["level"]));
                if (!original)
                    updates["level"] = builder.build();
                else
                    childBuilders["level"] = builder;
            }
            else {
                updates.level = build;
                delete childBuilders["level;"];
            }
            modifiedKeys["level"] = true;
            return this;
        };
    }
}
function patchForward(base, builder) { return builder(new ForwardBuilder(base)).patch(); }
exports.patchForward = patchForward;
function buildForward(builder) { return builder(new ForwardBuilder()).build(); }
exports.buildForward = buildForward;
class BarlineBuilder {
    build;
    patch;
    segno;
    coda;
    location;
    codaAttrib;
    wavyLine;
    fermatasAt;
    fermatasSplice;
    fermatas;
    segnoAttrib;
    divisions;
    barStyle;
    ending;
    repeat;
    footnote;
    level;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Barline";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.segno = (build) => {
            if (typeof build === 'function') {
                delete updates["segno"];
                const builder = build(new SegnoBuilder(original && original["segno"]));
                if (!original)
                    updates["segno"] = builder.build();
                else
                    childBuilders["segno"] = builder;
            }
            else {
                updates.segno = build;
                delete childBuilders["segno;"];
            }
            modifiedKeys["segno"] = true;
            return this;
        };
        this.coda = (build) => {
            if (typeof build === 'function') {
                delete updates["coda"];
                const builder = build(new CodaBuilder(original && original["coda"]));
                if (!original)
                    updates["coda"] = builder.build();
                else
                    childBuilders["coda"] = builder;
            }
            else {
                updates.coda = build;
                delete childBuilders["coda;"];
            }
            modifiedKeys["coda"] = true;
            return this;
        };
        this.location = (spec) => {
            updates["location"] = spec;
            delete childBuilders["location;"];
            modifiedKeys["location"] = true;
            return this;
        };
        this.codaAttrib = (spec) => {
            updates["codaAttrib"] = spec;
            delete childBuilders["codaAttrib;"];
            modifiedKeys["codaAttrib"] = true;
            return this;
        };
        this.wavyLine = (build) => {
            if (typeof build === 'function') {
                delete updates["wavyLine"];
                const builder = build(new WavyLineBuilder(original && original["wavyLine"]));
                if (!original)
                    updates["wavyLine"] = builder.build();
                else
                    childBuilders["wavyLine"] = builder;
            }
            else {
                updates.wavyLine = build;
                delete childBuilders["wavyLine;"];
            }
            modifiedKeys["wavyLine"] = true;
            return this;
        };
        this.fermatas = (spec) => {
            updates["fermatas"] = spec;
            delete childBuilders["fermatas;"];
            modifiedKeys["fermatas"] = true;
            return this;
        };
        this.fermatasAt = (idx, build) => {
            makeReference("fermatas");
            if (frozen["fermatas"][idx]) {
                throw new Error("Patching fermatas." + idx + " twice in a builder is unsupported.");
            }
            if (original && original._snapshot && original._snapshot["fermatas"] && original._snapshot["fermatas"][idx] && !original["fermatas"][idx]) {
                // Clone snapshot.
                patches.push({ p: ["fermatas", idx], li: original._snapshot["fermatas"] });
            }
            if (typeof build === 'function' && reference["fermatas"][idx]) {
                let patch = build(new FermataBuilder(reference["fermatas"][idx])).patch();
                patches = patches.concat(patch.map(patch => {
                    // TODO: detach?
                    patch.p = ["fermatas", idx].concat(patch.p);
                    return patch;
                }));
                frozen["fermatas"][idx] = true;
                return this;
            }
            let update = typeof build === 'function' ? build(new FermataBuilder(reference["fermatas"][idx])).build() : build;
            if (original) {
                patches.push({ p: ["fermatas", idx], li: update });
            }
            else {
                updates["fermatas"] = reference["fermatas"]; // TODO: Merge?
            }
            reference["fermatas"][idx] = update;
            frozen["fermatas"][idx] = true;
            return this;
        };
        this.fermatasSplice = (start, deleteCount, ...items) => {
            makeReference("fermatas");
            let idx = start;
            if (original) {
                for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
                    if (frozen["fermatas"][idx]) {
                        throw new Error("Replacing fermatas." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["fermatas"][idx];
                    patches.push({ p: ["fermatas", idx], ld, li: items[idx - start] });
                    frozen["fermatas"][idx] = true;
                }
                for (; idx < start + deleteCount; ++idx) {
                    if (frozen["fermatas"][idx]) {
                        throw new Error("Removing fermatas." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["fermatas"][idx];
                    patches.push({ p: ["fermatas", idx], ld });
                }
                for (; idx < start + items.length; ++idx) {
                    patches.push({ p: ["fermatas", idx], li: items[idx - start] });
                    frozen["fermatas"][idx] = true;
                }
            }
            reference["fermatas"].splice(start, deleteCount, ...items);
            updates["fermatas"] = reference["fermatas"];
            frozen["fermatas"].splice(start, deleteCount, ...items.map(i => true));
            return this;
        };
        this.segnoAttrib = (spec) => {
            updates["segnoAttrib"] = spec;
            delete childBuilders["segnoAttrib;"];
            modifiedKeys["segnoAttrib"] = true;
            return this;
        };
        this.divisions = (spec) => {
            updates["divisions"] = spec;
            delete childBuilders["divisions;"];
            modifiedKeys["divisions"] = true;
            return this;
        };
        this.barStyle = (build) => {
            if (typeof build === 'function') {
                delete updates["barStyle"];
                const builder = build(new BarStyleBuilder(original && original["barStyle"]));
                if (!original)
                    updates["barStyle"] = builder.build();
                else
                    childBuilders["barStyle"] = builder;
            }
            else {
                updates.barStyle = build;
                delete childBuilders["barStyle;"];
            }
            modifiedKeys["barStyle"] = true;
            return this;
        };
        this.ending = (build) => {
            if (typeof build === 'function') {
                delete updates["ending"];
                const builder = build(new EndingBuilder(original && original["ending"]));
                if (!original)
                    updates["ending"] = builder.build();
                else
                    childBuilders["ending"] = builder;
            }
            else {
                updates.ending = build;
                delete childBuilders["ending;"];
            }
            modifiedKeys["ending"] = true;
            return this;
        };
        this.repeat = (build) => {
            if (typeof build === 'function') {
                delete updates["repeat"];
                const builder = build(new RepeatBuilder(original && original["repeat"]));
                if (!original)
                    updates["repeat"] = builder.build();
                else
                    childBuilders["repeat"] = builder;
            }
            else {
                updates.repeat = build;
                delete childBuilders["repeat;"];
            }
            modifiedKeys["repeat"] = true;
            return this;
        };
        this.footnote = (build) => {
            if (typeof build === 'function') {
                delete updates["footnote"];
                const builder = build(new FootnoteBuilder(original && original["footnote"]));
                if (!original)
                    updates["footnote"] = builder.build();
                else
                    childBuilders["footnote"] = builder;
            }
            else {
                updates.footnote = build;
                delete childBuilders["footnote;"];
            }
            modifiedKeys["footnote"] = true;
            return this;
        };
        this.level = (build) => {
            if (typeof build === 'function') {
                delete updates["level"];
                const builder = build(new LevelBuilder(original && original["level"]));
                if (!original)
                    updates["level"] = builder.build();
                else
                    childBuilders["level"] = builder;
            }
            else {
                updates.level = build;
                delete childBuilders["level;"];
            }
            modifiedKeys["level"] = true;
            return this;
        };
    }
}
function patchBarline(base, builder) { return builder(new BarlineBuilder(base)).patch(); }
exports.patchBarline = patchBarline;
function buildBarline(builder) { return builder(new BarlineBuilder()).build(); }
exports.buildBarline = buildBarline;
class BarStyleBuilder {
    build;
    patch;
    data;
    color;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["data"]) ||
                childBuilders["data"] !== undefined ||
                updates.data !== undefined, "data is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "BarStyle";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.data = (spec) => {
            updates["data"] = spec;
            delete childBuilders["data;"];
            modifiedKeys["data"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
    }
}
function patchBarStyle(base, builder) { return builder(new BarStyleBuilder(base)).patch(); }
exports.patchBarStyle = patchBarStyle;
function buildBarStyle(builder) { return builder(new BarStyleBuilder()).build(); }
exports.buildBarStyle = buildBarStyle;
class EndingBuilder {
    build;
    patch;
    endLength;
    textX;
    number;
    textY;
    type;
    ending;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    fontFamily;
    fontWeight;
    fontStyle;
    fontSize;
    color;
    printObject;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["endLength"]) ||
                childBuilders["endLength"] !== undefined ||
                updates.endLength !== undefined, "endLength is a required field");
            console.assert((original && !modifiedKeys["textX"]) ||
                childBuilders["textX"] !== undefined ||
                updates.textX !== undefined, "textX is a required field");
            console.assert((original && !modifiedKeys["number"]) ||
                childBuilders["number"] !== undefined ||
                updates.number !== undefined, "number is a required field");
            console.assert((original && !modifiedKeys["textY"]) ||
                childBuilders["textY"] !== undefined ||
                updates.textY !== undefined, "textY is a required field");
            console.assert((original && !modifiedKeys["type"]) ||
                childBuilders["type"] !== undefined ||
                updates.type !== undefined, "type is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Ending";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.endLength = (spec) => {
            updates["endLength"] = spec;
            delete childBuilders["endLength;"];
            modifiedKeys["endLength"] = true;
            return this;
        };
        this.textX = (spec) => {
            updates["textX"] = spec;
            delete childBuilders["textX;"];
            modifiedKeys["textX"] = true;
            return this;
        };
        this.number = (spec) => {
            updates["number"] = spec;
            delete childBuilders["number;"];
            modifiedKeys["number"] = true;
            return this;
        };
        this.textY = (spec) => {
            updates["textY"] = spec;
            delete childBuilders["textY;"];
            modifiedKeys["textY"] = true;
            return this;
        };
        this.type = (spec) => {
            updates["type"] = spec;
            delete childBuilders["type;"];
            modifiedKeys["type"] = true;
            return this;
        };
        this.ending = (spec) => {
            updates["ending"] = spec;
            delete childBuilders["ending;"];
            modifiedKeys["ending"] = true;
            return this;
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
        this.fontFamily = (spec) => {
            updates["fontFamily"] = spec;
            delete childBuilders["fontFamily;"];
            modifiedKeys["fontFamily"] = true;
            return this;
        };
        this.fontWeight = (spec) => {
            updates["fontWeight"] = spec;
            delete childBuilders["fontWeight;"];
            modifiedKeys["fontWeight"] = true;
            return this;
        };
        this.fontStyle = (spec) => {
            updates["fontStyle"] = spec;
            delete childBuilders["fontStyle;"];
            modifiedKeys["fontStyle"] = true;
            return this;
        };
        this.fontSize = (spec) => {
            updates["fontSize"] = spec;
            delete childBuilders["fontSize;"];
            modifiedKeys["fontSize"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
        this.printObject = (spec) => {
            updates["printObject"] = spec;
            delete childBuilders["printObject;"];
            modifiedKeys["printObject"] = true;
            return this;
        };
    }
}
function patchEnding(base, builder) { return builder(new EndingBuilder(base)).patch(); }
exports.patchEnding = patchEnding;
function buildEnding(builder) { return builder(new EndingBuilder()).build(); }
exports.buildEnding = buildEnding;
class RepeatBuilder {
    build;
    patch;
    times;
    winged;
    direction;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["times"]) ||
                childBuilders["times"] !== undefined ||
                updates.times !== undefined, "times is a required field");
            console.assert((original && !modifiedKeys["winged"]) ||
                childBuilders["winged"] !== undefined ||
                updates.winged !== undefined, "winged is a required field");
            console.assert((original && !modifiedKeys["direction"]) ||
                childBuilders["direction"] !== undefined ||
                updates.direction !== undefined, "direction is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Repeat";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.times = (spec) => {
            updates["times"] = spec;
            delete childBuilders["times;"];
            modifiedKeys["times"] = true;
            return this;
        };
        this.winged = (spec) => {
            updates["winged"] = spec;
            delete childBuilders["winged;"];
            modifiedKeys["winged"] = true;
            return this;
        };
        this.direction = (spec) => {
            updates["direction"] = spec;
            delete childBuilders["direction;"];
            modifiedKeys["direction"] = true;
            return this;
        };
    }
}
function patchRepeat(base, builder) { return builder(new RepeatBuilder(base)).patch(); }
exports.patchRepeat = patchRepeat;
function buildRepeat(builder) { return builder(new RepeatBuilder()).build(); }
exports.buildRepeat = buildRepeat;
class DirectionBuilder {
    build;
    patch;
    directionTypesAt;
    directionTypesSplice;
    directionTypes;
    staff;
    offset;
    sound;
    placement;
    voice;
    footnote;
    level;
    directive;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["directionTypes"]) ||
                childBuilders["directionTypes"] !== undefined ||
                updates.directionTypes !== undefined, "directionTypes is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Direction";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.directionTypes = (spec) => {
            updates["directionTypes"] = spec;
            delete childBuilders["directionTypes;"];
            modifiedKeys["directionTypes"] = true;
            return this;
        };
        this.directionTypesAt = (idx, build) => {
            makeReference("directionTypes");
            if (frozen["directionTypes"][idx]) {
                throw new Error("Patching directionTypes." + idx + " twice in a builder is unsupported.");
            }
            if (original && original._snapshot && original._snapshot["directionTypes"] && original._snapshot["directionTypes"][idx] && !original["directionTypes"][idx]) {
                // Clone snapshot.
                patches.push({ p: ["directionTypes", idx], li: original._snapshot["directionTypes"] });
            }
            if (typeof build === 'function' && reference["directionTypes"][idx]) {
                let patch = build(new DirectionTypeBuilder(reference["directionTypes"][idx])).patch();
                patches = patches.concat(patch.map(patch => {
                    // TODO: detach?
                    patch.p = ["directionTypes", idx].concat(patch.p);
                    return patch;
                }));
                frozen["directionTypes"][idx] = true;
                return this;
            }
            let update = typeof build === 'function' ? build(new DirectionTypeBuilder(reference["directionTypes"][idx])).build() : build;
            if (original) {
                patches.push({ p: ["directionTypes", idx], li: update });
            }
            else {
                updates["directionTypes"] = reference["directionTypes"]; // TODO: Merge?
            }
            reference["directionTypes"][idx] = update;
            frozen["directionTypes"][idx] = true;
            return this;
        };
        this.directionTypesSplice = (start, deleteCount, ...items) => {
            makeReference("directionTypes");
            let idx = start;
            if (original) {
                for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
                    if (frozen["directionTypes"][idx]) {
                        throw new Error("Replacing directionTypes." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["directionTypes"][idx];
                    patches.push({ p: ["directionTypes", idx], ld, li: items[idx - start] });
                    frozen["directionTypes"][idx] = true;
                }
                for (; idx < start + deleteCount; ++idx) {
                    if (frozen["directionTypes"][idx]) {
                        throw new Error("Removing directionTypes." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["directionTypes"][idx];
                    patches.push({ p: ["directionTypes", idx], ld });
                }
                for (; idx < start + items.length; ++idx) {
                    patches.push({ p: ["directionTypes", idx], li: items[idx - start] });
                    frozen["directionTypes"][idx] = true;
                }
            }
            reference["directionTypes"].splice(start, deleteCount, ...items);
            updates["directionTypes"] = reference["directionTypes"];
            frozen["directionTypes"].splice(start, deleteCount, ...items.map(i => true));
            return this;
        };
        this.staff = (spec) => {
            updates["staff"] = spec;
            delete childBuilders["staff;"];
            modifiedKeys["staff"] = true;
            return this;
        };
        this.offset = (build) => {
            if (typeof build === 'function') {
                delete updates["offset"];
                const builder = build(new OffsetBuilder(original && original["offset"]));
                if (!original)
                    updates["offset"] = builder.build();
                else
                    childBuilders["offset"] = builder;
            }
            else {
                updates.offset = build;
                delete childBuilders["offset;"];
            }
            modifiedKeys["offset"] = true;
            return this;
        };
        this.sound = (build) => {
            if (typeof build === 'function') {
                delete updates["sound"];
                const builder = build(new SoundBuilder(original && original["sound"]));
                if (!original)
                    updates["sound"] = builder.build();
                else
                    childBuilders["sound"] = builder;
            }
            else {
                updates.sound = build;
                delete childBuilders["sound;"];
            }
            modifiedKeys["sound"] = true;
            return this;
        };
        this.placement = (spec) => {
            updates["placement"] = spec;
            delete childBuilders["placement;"];
            modifiedKeys["placement"] = true;
            return this;
        };
        this.voice = (spec) => {
            updates["voice"] = spec;
            delete childBuilders["voice;"];
            modifiedKeys["voice"] = true;
            return this;
        };
        this.footnote = (build) => {
            if (typeof build === 'function') {
                delete updates["footnote"];
                const builder = build(new FootnoteBuilder(original && original["footnote"]));
                if (!original)
                    updates["footnote"] = builder.build();
                else
                    childBuilders["footnote"] = builder;
            }
            else {
                updates.footnote = build;
                delete childBuilders["footnote;"];
            }
            modifiedKeys["footnote"] = true;
            return this;
        };
        this.level = (build) => {
            if (typeof build === 'function') {
                delete updates["level"];
                const builder = build(new LevelBuilder(original && original["level"]));
                if (!original)
                    updates["level"] = builder.build();
                else
                    childBuilders["level"] = builder;
            }
            else {
                updates.level = build;
                delete childBuilders["level;"];
            }
            modifiedKeys["level"] = true;
            return this;
        };
        this.directive = (spec) => {
            updates["directive"] = spec;
            delete childBuilders["directive;"];
            modifiedKeys["directive"] = true;
            return this;
        };
    }
}
function patchDirection(base, builder) { return builder(new DirectionBuilder(base)).patch(); }
exports.patchDirection = patchDirection;
function buildDirection(builder) { return builder(new DirectionBuilder()).build(); }
exports.buildDirection = buildDirection;
class DirectionTypeBuilder {
    build;
    patch;
    percussionsAt;
    percussionsSplice;
    percussions;
    rehearsalsAt;
    rehearsalsSplice;
    rehearsals;
    pedal;
    principalVoice;
    accordionRegistration;
    eyeglasses;
    image;
    harpPedals;
    metronome;
    otherDirection;
    segnosAt;
    segnosSplice;
    segnos;
    scordatura;
    stringMute;
    wedge;
    dashes;
    damp;
    bracket;
    dynamics;
    octaveShift;
    wordsAt;
    wordsSplice;
    words;
    dampAll;
    codasAt;
    codasSplice;
    codas;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "DirectionType";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.percussions = (spec) => {
            updates["percussions"] = spec;
            delete childBuilders["percussions;"];
            modifiedKeys["percussions"] = true;
            return this;
        };
        this.percussionsAt = (idx, build) => {
            makeReference("percussions");
            if (frozen["percussions"][idx]) {
                throw new Error("Patching percussions." + idx + " twice in a builder is unsupported.");
            }
            if (original && original._snapshot && original._snapshot["percussions"] && original._snapshot["percussions"][idx] && !original["percussions"][idx]) {
                // Clone snapshot.
                patches.push({ p: ["percussions", idx], li: original._snapshot["percussions"] });
            }
            if (typeof build === 'function' && reference["percussions"][idx]) {
                let patch = build(new PercussionBuilder(reference["percussions"][idx])).patch();
                patches = patches.concat(patch.map(patch => {
                    // TODO: detach?
                    patch.p = ["percussions", idx].concat(patch.p);
                    return patch;
                }));
                frozen["percussions"][idx] = true;
                return this;
            }
            let update = typeof build === 'function' ? build(new PercussionBuilder(reference["percussions"][idx])).build() : build;
            if (original) {
                patches.push({ p: ["percussions", idx], li: update });
            }
            else {
                updates["percussions"] = reference["percussions"]; // TODO: Merge?
            }
            reference["percussions"][idx] = update;
            frozen["percussions"][idx] = true;
            return this;
        };
        this.percussionsSplice = (start, deleteCount, ...items) => {
            makeReference("percussions");
            let idx = start;
            if (original) {
                for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
                    if (frozen["percussions"][idx]) {
                        throw new Error("Replacing percussions." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["percussions"][idx];
                    patches.push({ p: ["percussions", idx], ld, li: items[idx - start] });
                    frozen["percussions"][idx] = true;
                }
                for (; idx < start + deleteCount; ++idx) {
                    if (frozen["percussions"][idx]) {
                        throw new Error("Removing percussions." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["percussions"][idx];
                    patches.push({ p: ["percussions", idx], ld });
                }
                for (; idx < start + items.length; ++idx) {
                    patches.push({ p: ["percussions", idx], li: items[idx - start] });
                    frozen["percussions"][idx] = true;
                }
            }
            reference["percussions"].splice(start, deleteCount, ...items);
            updates["percussions"] = reference["percussions"];
            frozen["percussions"].splice(start, deleteCount, ...items.map(i => true));
            return this;
        };
        this.rehearsals = (spec) => {
            updates["rehearsals"] = spec;
            delete childBuilders["rehearsals;"];
            modifiedKeys["rehearsals"] = true;
            return this;
        };
        this.rehearsalsAt = (idx, build) => {
            makeReference("rehearsals");
            if (frozen["rehearsals"][idx]) {
                throw new Error("Patching rehearsals." + idx + " twice in a builder is unsupported.");
            }
            if (original && original._snapshot && original._snapshot["rehearsals"] && original._snapshot["rehearsals"][idx] && !original["rehearsals"][idx]) {
                // Clone snapshot.
                patches.push({ p: ["rehearsals", idx], li: original._snapshot["rehearsals"] });
            }
            if (typeof build === 'function' && reference["rehearsals"][idx]) {
                let patch = build(new RehearsalBuilder(reference["rehearsals"][idx])).patch();
                patches = patches.concat(patch.map(patch => {
                    // TODO: detach?
                    patch.p = ["rehearsals", idx].concat(patch.p);
                    return patch;
                }));
                frozen["rehearsals"][idx] = true;
                return this;
            }
            let update = typeof build === 'function' ? build(new RehearsalBuilder(reference["rehearsals"][idx])).build() : build;
            if (original) {
                patches.push({ p: ["rehearsals", idx], li: update });
            }
            else {
                updates["rehearsals"] = reference["rehearsals"]; // TODO: Merge?
            }
            reference["rehearsals"][idx] = update;
            frozen["rehearsals"][idx] = true;
            return this;
        };
        this.rehearsalsSplice = (start, deleteCount, ...items) => {
            makeReference("rehearsals");
            let idx = start;
            if (original) {
                for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
                    if (frozen["rehearsals"][idx]) {
                        throw new Error("Replacing rehearsals." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["rehearsals"][idx];
                    patches.push({ p: ["rehearsals", idx], ld, li: items[idx - start] });
                    frozen["rehearsals"][idx] = true;
                }
                for (; idx < start + deleteCount; ++idx) {
                    if (frozen["rehearsals"][idx]) {
                        throw new Error("Removing rehearsals." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["rehearsals"][idx];
                    patches.push({ p: ["rehearsals", idx], ld });
                }
                for (; idx < start + items.length; ++idx) {
                    patches.push({ p: ["rehearsals", idx], li: items[idx - start] });
                    frozen["rehearsals"][idx] = true;
                }
            }
            reference["rehearsals"].splice(start, deleteCount, ...items);
            updates["rehearsals"] = reference["rehearsals"];
            frozen["rehearsals"].splice(start, deleteCount, ...items.map(i => true));
            return this;
        };
        this.pedal = (build) => {
            if (typeof build === 'function') {
                delete updates["pedal"];
                const builder = build(new PedalBuilder(original && original["pedal"]));
                if (!original)
                    updates["pedal"] = builder.build();
                else
                    childBuilders["pedal"] = builder;
            }
            else {
                updates.pedal = build;
                delete childBuilders["pedal;"];
            }
            modifiedKeys["pedal"] = true;
            return this;
        };
        this.principalVoice = (build) => {
            if (typeof build === 'function') {
                delete updates["principalVoice"];
                const builder = build(new PrincipalVoiceBuilder(original && original["principalVoice"]));
                if (!original)
                    updates["principalVoice"] = builder.build();
                else
                    childBuilders["principalVoice"] = builder;
            }
            else {
                updates.principalVoice = build;
                delete childBuilders["principalVoice;"];
            }
            modifiedKeys["principalVoice"] = true;
            return this;
        };
        this.accordionRegistration = (build) => {
            if (typeof build === 'function') {
                delete updates["accordionRegistration"];
                const builder = build(new AccordionRegistrationBuilder(original && original["accordionRegistration"]));
                if (!original)
                    updates["accordionRegistration"] = builder.build();
                else
                    childBuilders["accordionRegistration"] = builder;
            }
            else {
                updates.accordionRegistration = build;
                delete childBuilders["accordionRegistration;"];
            }
            modifiedKeys["accordionRegistration"] = true;
            return this;
        };
        this.eyeglasses = (build) => {
            if (typeof build === 'function') {
                delete updates["eyeglasses"];
                const builder = build(new EyeglassesBuilder(original && original["eyeglasses"]));
                if (!original)
                    updates["eyeglasses"] = builder.build();
                else
                    childBuilders["eyeglasses"] = builder;
            }
            else {
                updates.eyeglasses = build;
                delete childBuilders["eyeglasses;"];
            }
            modifiedKeys["eyeglasses"] = true;
            return this;
        };
        this.image = (build) => {
            if (typeof build === 'function') {
                delete updates["image"];
                const builder = build(new ImageBuilder(original && original["image"]));
                if (!original)
                    updates["image"] = builder.build();
                else
                    childBuilders["image"] = builder;
            }
            else {
                updates.image = build;
                delete childBuilders["image;"];
            }
            modifiedKeys["image"] = true;
            return this;
        };
        this.harpPedals = (build) => {
            if (typeof build === 'function') {
                delete updates["harpPedals"];
                const builder = build(new HarpPedalsBuilder(original && original["harpPedals"]));
                if (!original)
                    updates["harpPedals"] = builder.build();
                else
                    childBuilders["harpPedals"] = builder;
            }
            else {
                updates.harpPedals = build;
                delete childBuilders["harpPedals;"];
            }
            modifiedKeys["harpPedals"] = true;
            return this;
        };
        this.metronome = (build) => {
            if (typeof build === 'function') {
                delete updates["metronome"];
                const builder = build(new MetronomeBuilder(original && original["metronome"]));
                if (!original)
                    updates["metronome"] = builder.build();
                else
                    childBuilders["metronome"] = builder;
            }
            else {
                updates.metronome = build;
                delete childBuilders["metronome;"];
            }
            modifiedKeys["metronome"] = true;
            return this;
        };
        this.otherDirection = (build) => {
            if (typeof build === 'function') {
                delete updates["otherDirection"];
                const builder = build(new OtherDirectionBuilder(original && original["otherDirection"]));
                if (!original)
                    updates["otherDirection"] = builder.build();
                else
                    childBuilders["otherDirection"] = builder;
            }
            else {
                updates.otherDirection = build;
                delete childBuilders["otherDirection;"];
            }
            modifiedKeys["otherDirection"] = true;
            return this;
        };
        this.segnos = (spec) => {
            updates["segnos"] = spec;
            delete childBuilders["segnos;"];
            modifiedKeys["segnos"] = true;
            return this;
        };
        this.segnosAt = (idx, build) => {
            makeReference("segnos");
            if (frozen["segnos"][idx]) {
                throw new Error("Patching segnos." + idx + " twice in a builder is unsupported.");
            }
            if (original && original._snapshot && original._snapshot["segnos"] && original._snapshot["segnos"][idx] && !original["segnos"][idx]) {
                // Clone snapshot.
                patches.push({ p: ["segnos", idx], li: original._snapshot["segnos"] });
            }
            if (typeof build === 'function' && reference["segnos"][idx]) {
                let patch = build(new SegnoBuilder(reference["segnos"][idx])).patch();
                patches = patches.concat(patch.map(patch => {
                    // TODO: detach?
                    patch.p = ["segnos", idx].concat(patch.p);
                    return patch;
                }));
                frozen["segnos"][idx] = true;
                return this;
            }
            let update = typeof build === 'function' ? build(new SegnoBuilder(reference["segnos"][idx])).build() : build;
            if (original) {
                patches.push({ p: ["segnos", idx], li: update });
            }
            else {
                updates["segnos"] = reference["segnos"]; // TODO: Merge?
            }
            reference["segnos"][idx] = update;
            frozen["segnos"][idx] = true;
            return this;
        };
        this.segnosSplice = (start, deleteCount, ...items) => {
            makeReference("segnos");
            let idx = start;
            if (original) {
                for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
                    if (frozen["segnos"][idx]) {
                        throw new Error("Replacing segnos." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["segnos"][idx];
                    patches.push({ p: ["segnos", idx], ld, li: items[idx - start] });
                    frozen["segnos"][idx] = true;
                }
                for (; idx < start + deleteCount; ++idx) {
                    if (frozen["segnos"][idx]) {
                        throw new Error("Removing segnos." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["segnos"][idx];
                    patches.push({ p: ["segnos", idx], ld });
                }
                for (; idx < start + items.length; ++idx) {
                    patches.push({ p: ["segnos", idx], li: items[idx - start] });
                    frozen["segnos"][idx] = true;
                }
            }
            reference["segnos"].splice(start, deleteCount, ...items);
            updates["segnos"] = reference["segnos"];
            frozen["segnos"].splice(start, deleteCount, ...items.map(i => true));
            return this;
        };
        this.scordatura = (build) => {
            if (typeof build === 'function') {
                delete updates["scordatura"];
                const builder = build(new ScordaturaBuilder(original && original["scordatura"]));
                if (!original)
                    updates["scordatura"] = builder.build();
                else
                    childBuilders["scordatura"] = builder;
            }
            else {
                updates.scordatura = build;
                delete childBuilders["scordatura;"];
            }
            modifiedKeys["scordatura"] = true;
            return this;
        };
        this.stringMute = (build) => {
            if (typeof build === 'function') {
                delete updates["stringMute"];
                const builder = build(new StringMuteBuilder(original && original["stringMute"]));
                if (!original)
                    updates["stringMute"] = builder.build();
                else
                    childBuilders["stringMute"] = builder;
            }
            else {
                updates.stringMute = build;
                delete childBuilders["stringMute;"];
            }
            modifiedKeys["stringMute"] = true;
            return this;
        };
        this.wedge = (build) => {
            if (typeof build === 'function') {
                delete updates["wedge"];
                const builder = build(new WedgeBuilder(original && original["wedge"]));
                if (!original)
                    updates["wedge"] = builder.build();
                else
                    childBuilders["wedge"] = builder;
            }
            else {
                updates.wedge = build;
                delete childBuilders["wedge;"];
            }
            modifiedKeys["wedge"] = true;
            return this;
        };
        this.dashes = (build) => {
            if (typeof build === 'function') {
                delete updates["dashes"];
                const builder = build(new DashesBuilder(original && original["dashes"]));
                if (!original)
                    updates["dashes"] = builder.build();
                else
                    childBuilders["dashes"] = builder;
            }
            else {
                updates.dashes = build;
                delete childBuilders["dashes;"];
            }
            modifiedKeys["dashes"] = true;
            return this;
        };
        this.damp = (build) => {
            if (typeof build === 'function') {
                delete updates["damp"];
                const builder = build(new DampBuilder(original && original["damp"]));
                if (!original)
                    updates["damp"] = builder.build();
                else
                    childBuilders["damp"] = builder;
            }
            else {
                updates.damp = build;
                delete childBuilders["damp;"];
            }
            modifiedKeys["damp"] = true;
            return this;
        };
        this.bracket = (build) => {
            if (typeof build === 'function') {
                delete updates["bracket"];
                const builder = build(new BracketBuilder(original && original["bracket"]));
                if (!original)
                    updates["bracket"] = builder.build();
                else
                    childBuilders["bracket"] = builder;
            }
            else {
                updates.bracket = build;
                delete childBuilders["bracket;"];
            }
            modifiedKeys["bracket"] = true;
            return this;
        };
        this.dynamics = (build) => {
            if (typeof build === 'function') {
                delete updates["dynamics"];
                const builder = build(new DynamicsBuilder(original && original["dynamics"]));
                if (!original)
                    updates["dynamics"] = builder.build();
                else
                    childBuilders["dynamics"] = builder;
            }
            else {
                updates.dynamics = build;
                delete childBuilders["dynamics;"];
            }
            modifiedKeys["dynamics"] = true;
            return this;
        };
        this.octaveShift = (build) => {
            if (typeof build === 'function') {
                delete updates["octaveShift"];
                const builder = build(new OctaveShiftBuilder(original && original["octaveShift"]));
                if (!original)
                    updates["octaveShift"] = builder.build();
                else
                    childBuilders["octaveShift"] = builder;
            }
            else {
                updates.octaveShift = build;
                delete childBuilders["octaveShift;"];
            }
            modifiedKeys["octaveShift"] = true;
            return this;
        };
        this.words = (spec) => {
            updates["words"] = spec;
            delete childBuilders["words;"];
            modifiedKeys["words"] = true;
            return this;
        };
        this.wordsAt = (idx, build) => {
            makeReference("words");
            if (frozen["words"][idx]) {
                throw new Error("Patching words." + idx + " twice in a builder is unsupported.");
            }
            if (original && original._snapshot && original._snapshot["words"] && original._snapshot["words"][idx] && !original["words"][idx]) {
                // Clone snapshot.
                patches.push({ p: ["words", idx], li: original._snapshot["words"] });
            }
            if (typeof build === 'function' && reference["words"][idx]) {
                let patch = build(new WordsBuilder(reference["words"][idx])).patch();
                patches = patches.concat(patch.map(patch => {
                    // TODO: detach?
                    patch.p = ["words", idx].concat(patch.p);
                    return patch;
                }));
                frozen["words"][idx] = true;
                return this;
            }
            let update = typeof build === 'function' ? build(new WordsBuilder(reference["words"][idx])).build() : build;
            if (original) {
                patches.push({ p: ["words", idx], li: update });
            }
            else {
                updates["words"] = reference["words"]; // TODO: Merge?
            }
            reference["words"][idx] = update;
            frozen["words"][idx] = true;
            return this;
        };
        this.wordsSplice = (start, deleteCount, ...items) => {
            makeReference("words");
            let idx = start;
            if (original) {
                for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
                    if (frozen["words"][idx]) {
                        throw new Error("Replacing words." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["words"][idx];
                    patches.push({ p: ["words", idx], ld, li: items[idx - start] });
                    frozen["words"][idx] = true;
                }
                for (; idx < start + deleteCount; ++idx) {
                    if (frozen["words"][idx]) {
                        throw new Error("Removing words." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["words"][idx];
                    patches.push({ p: ["words", idx], ld });
                }
                for (; idx < start + items.length; ++idx) {
                    patches.push({ p: ["words", idx], li: items[idx - start] });
                    frozen["words"][idx] = true;
                }
            }
            reference["words"].splice(start, deleteCount, ...items);
            updates["words"] = reference["words"];
            frozen["words"].splice(start, deleteCount, ...items.map(i => true));
            return this;
        };
        this.dampAll = (build) => {
            if (typeof build === 'function') {
                delete updates["dampAll"];
                const builder = build(new DampAllBuilder(original && original["dampAll"]));
                if (!original)
                    updates["dampAll"] = builder.build();
                else
                    childBuilders["dampAll"] = builder;
            }
            else {
                updates.dampAll = build;
                delete childBuilders["dampAll;"];
            }
            modifiedKeys["dampAll"] = true;
            return this;
        };
        this.codas = (spec) => {
            updates["codas"] = spec;
            delete childBuilders["codas;"];
            modifiedKeys["codas"] = true;
            return this;
        };
        this.codasAt = (idx, build) => {
            makeReference("codas");
            if (frozen["codas"][idx]) {
                throw new Error("Patching codas." + idx + " twice in a builder is unsupported.");
            }
            if (original && original._snapshot && original._snapshot["codas"] && original._snapshot["codas"][idx] && !original["codas"][idx]) {
                // Clone snapshot.
                patches.push({ p: ["codas", idx], li: original._snapshot["codas"] });
            }
            if (typeof build === 'function' && reference["codas"][idx]) {
                let patch = build(new CodaBuilder(reference["codas"][idx])).patch();
                patches = patches.concat(patch.map(patch => {
                    // TODO: detach?
                    patch.p = ["codas", idx].concat(patch.p);
                    return patch;
                }));
                frozen["codas"][idx] = true;
                return this;
            }
            let update = typeof build === 'function' ? build(new CodaBuilder(reference["codas"][idx])).build() : build;
            if (original) {
                patches.push({ p: ["codas", idx], li: update });
            }
            else {
                updates["codas"] = reference["codas"]; // TODO: Merge?
            }
            reference["codas"][idx] = update;
            frozen["codas"][idx] = true;
            return this;
        };
        this.codasSplice = (start, deleteCount, ...items) => {
            makeReference("codas");
            let idx = start;
            if (original) {
                for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
                    if (frozen["codas"][idx]) {
                        throw new Error("Replacing codas." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["codas"][idx];
                    patches.push({ p: ["codas", idx], ld, li: items[idx - start] });
                    frozen["codas"][idx] = true;
                }
                for (; idx < start + deleteCount; ++idx) {
                    if (frozen["codas"][idx]) {
                        throw new Error("Removing codas." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["codas"][idx];
                    patches.push({ p: ["codas", idx], ld });
                }
                for (; idx < start + items.length; ++idx) {
                    patches.push({ p: ["codas", idx], li: items[idx - start] });
                    frozen["codas"][idx] = true;
                }
            }
            reference["codas"].splice(start, deleteCount, ...items);
            updates["codas"] = reference["codas"];
            frozen["codas"].splice(start, deleteCount, ...items.map(i => true));
            return this;
        };
    }
}
function patchDirectionType(base, builder) { return builder(new DirectionTypeBuilder(base)).patch(); }
exports.patchDirectionType = patchDirectionType;
function buildDirectionType(builder) { return builder(new DirectionTypeBuilder()).build(); }
exports.buildDirectionType = buildDirectionType;
class RehearsalBuilder {
    build;
    patch;
    data;
    justify;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    fontFamily;
    fontWeight;
    fontStyle;
    fontSize;
    color;
    halign;
    valign;
    underline;
    overline;
    lineThrough;
    rotation;
    letterSpacing;
    lineHeight;
    dir;
    enclosure;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["data"]) ||
                childBuilders["data"] !== undefined ||
                updates.data !== undefined, "data is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Rehearsal";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.data = (spec) => {
            updates["data"] = spec;
            delete childBuilders["data;"];
            modifiedKeys["data"] = true;
            return this;
        };
        this.justify = (spec) => {
            updates["justify"] = spec;
            delete childBuilders["justify;"];
            modifiedKeys["justify"] = true;
            return this;
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
        this.fontFamily = (spec) => {
            updates["fontFamily"] = spec;
            delete childBuilders["fontFamily;"];
            modifiedKeys["fontFamily"] = true;
            return this;
        };
        this.fontWeight = (spec) => {
            updates["fontWeight"] = spec;
            delete childBuilders["fontWeight;"];
            modifiedKeys["fontWeight"] = true;
            return this;
        };
        this.fontStyle = (spec) => {
            updates["fontStyle"] = spec;
            delete childBuilders["fontStyle;"];
            modifiedKeys["fontStyle"] = true;
            return this;
        };
        this.fontSize = (spec) => {
            updates["fontSize"] = spec;
            delete childBuilders["fontSize;"];
            modifiedKeys["fontSize"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
        this.halign = (spec) => {
            updates["halign"] = spec;
            delete childBuilders["halign;"];
            modifiedKeys["halign"] = true;
            return this;
        };
        this.valign = (spec) => {
            updates["valign"] = spec;
            delete childBuilders["valign;"];
            modifiedKeys["valign"] = true;
            return this;
        };
        this.underline = (spec) => {
            updates["underline"] = spec;
            delete childBuilders["underline;"];
            modifiedKeys["underline"] = true;
            return this;
        };
        this.overline = (spec) => {
            updates["overline"] = spec;
            delete childBuilders["overline;"];
            modifiedKeys["overline"] = true;
            return this;
        };
        this.lineThrough = (spec) => {
            updates["lineThrough"] = spec;
            delete childBuilders["lineThrough;"];
            modifiedKeys["lineThrough"] = true;
            return this;
        };
        this.rotation = (spec) => {
            updates["rotation"] = spec;
            delete childBuilders["rotation;"];
            modifiedKeys["rotation"] = true;
            return this;
        };
        this.letterSpacing = (spec) => {
            updates["letterSpacing"] = spec;
            delete childBuilders["letterSpacing;"];
            modifiedKeys["letterSpacing"] = true;
            return this;
        };
        this.lineHeight = (spec) => {
            updates["lineHeight"] = spec;
            delete childBuilders["lineHeight;"];
            modifiedKeys["lineHeight"] = true;
            return this;
        };
        this.dir = (spec) => {
            updates["dir"] = spec;
            delete childBuilders["dir;"];
            modifiedKeys["dir"] = true;
            return this;
        };
        this.enclosure = (spec) => {
            updates["enclosure"] = spec;
            delete childBuilders["enclosure;"];
            modifiedKeys["enclosure"] = true;
            return this;
        };
    }
}
function patchRehearsal(base, builder) { return builder(new RehearsalBuilder(base)).patch(); }
exports.patchRehearsal = patchRehearsal;
function buildRehearsal(builder) { return builder(new RehearsalBuilder()).build(); }
exports.buildRehearsal = buildRehearsal;
class WordsBuilder {
    build;
    patch;
    data;
    justify;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    fontFamily;
    fontWeight;
    fontStyle;
    fontSize;
    color;
    halign;
    valign;
    underline;
    overline;
    lineThrough;
    rotation;
    letterSpacing;
    lineHeight;
    dir;
    enclosure;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["data"]) ||
                childBuilders["data"] !== undefined ||
                updates.data !== undefined, "data is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Words";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.data = (spec) => {
            updates["data"] = spec;
            delete childBuilders["data;"];
            modifiedKeys["data"] = true;
            return this;
        };
        this.justify = (spec) => {
            updates["justify"] = spec;
            delete childBuilders["justify;"];
            modifiedKeys["justify"] = true;
            return this;
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
        this.fontFamily = (spec) => {
            updates["fontFamily"] = spec;
            delete childBuilders["fontFamily;"];
            modifiedKeys["fontFamily"] = true;
            return this;
        };
        this.fontWeight = (spec) => {
            updates["fontWeight"] = spec;
            delete childBuilders["fontWeight;"];
            modifiedKeys["fontWeight"] = true;
            return this;
        };
        this.fontStyle = (spec) => {
            updates["fontStyle"] = spec;
            delete childBuilders["fontStyle;"];
            modifiedKeys["fontStyle"] = true;
            return this;
        };
        this.fontSize = (spec) => {
            updates["fontSize"] = spec;
            delete childBuilders["fontSize;"];
            modifiedKeys["fontSize"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
        this.halign = (spec) => {
            updates["halign"] = spec;
            delete childBuilders["halign;"];
            modifiedKeys["halign"] = true;
            return this;
        };
        this.valign = (spec) => {
            updates["valign"] = spec;
            delete childBuilders["valign;"];
            modifiedKeys["valign"] = true;
            return this;
        };
        this.underline = (spec) => {
            updates["underline"] = spec;
            delete childBuilders["underline;"];
            modifiedKeys["underline"] = true;
            return this;
        };
        this.overline = (spec) => {
            updates["overline"] = spec;
            delete childBuilders["overline;"];
            modifiedKeys["overline"] = true;
            return this;
        };
        this.lineThrough = (spec) => {
            updates["lineThrough"] = spec;
            delete childBuilders["lineThrough;"];
            modifiedKeys["lineThrough"] = true;
            return this;
        };
        this.rotation = (spec) => {
            updates["rotation"] = spec;
            delete childBuilders["rotation;"];
            modifiedKeys["rotation"] = true;
            return this;
        };
        this.letterSpacing = (spec) => {
            updates["letterSpacing"] = spec;
            delete childBuilders["letterSpacing;"];
            modifiedKeys["letterSpacing"] = true;
            return this;
        };
        this.lineHeight = (spec) => {
            updates["lineHeight"] = spec;
            delete childBuilders["lineHeight;"];
            modifiedKeys["lineHeight"] = true;
            return this;
        };
        this.dir = (spec) => {
            updates["dir"] = spec;
            delete childBuilders["dir;"];
            modifiedKeys["dir"] = true;
            return this;
        };
        this.enclosure = (spec) => {
            updates["enclosure"] = spec;
            delete childBuilders["enclosure;"];
            modifiedKeys["enclosure"] = true;
            return this;
        };
    }
}
function patchWords(base, builder) { return builder(new WordsBuilder(base)).patch(); }
exports.patchWords = patchWords;
function buildWords(builder) { return builder(new WordsBuilder()).build(); }
exports.buildWords = buildWords;
class WedgeBuilder {
    build;
    patch;
    number;
    niente;
    type;
    spread;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    color;
    lineType;
    dashLength;
    spaceLength;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["type"]) ||
                childBuilders["type"] !== undefined ||
                updates.type !== undefined, "type is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Wedge";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.number = (spec) => {
            updates["number"] = spec;
            delete childBuilders["number;"];
            modifiedKeys["number"] = true;
            return this;
        };
        this.niente = (spec) => {
            updates["niente"] = spec;
            delete childBuilders["niente;"];
            modifiedKeys["niente"] = true;
            return this;
        };
        this.type = (spec) => {
            updates["type"] = spec;
            delete childBuilders["type;"];
            modifiedKeys["type"] = true;
            return this;
        };
        this.spread = (spec) => {
            updates["spread"] = spec;
            delete childBuilders["spread;"];
            modifiedKeys["spread"] = true;
            return this;
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
        this.lineType = (spec) => {
            updates["lineType"] = spec;
            delete childBuilders["lineType;"];
            modifiedKeys["lineType"] = true;
            return this;
        };
        this.dashLength = (spec) => {
            updates["dashLength"] = spec;
            delete childBuilders["dashLength;"];
            modifiedKeys["dashLength"] = true;
            return this;
        };
        this.spaceLength = (spec) => {
            updates["spaceLength"] = spec;
            delete childBuilders["spaceLength;"];
            modifiedKeys["spaceLength"] = true;
            return this;
        };
    }
}
function patchWedge(base, builder) { return builder(new WedgeBuilder(base)).patch(); }
exports.patchWedge = patchWedge;
function buildWedge(builder) { return builder(new WedgeBuilder()).build(); }
exports.buildWedge = buildWedge;
class DashesBuilder {
    build;
    patch;
    number;
    type;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    color;
    dashLength;
    spaceLength;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["number"]) ||
                childBuilders["number"] !== undefined ||
                updates.number !== undefined, "number is a required field");
            console.assert((original && !modifiedKeys["type"]) ||
                childBuilders["type"] !== undefined ||
                updates.type !== undefined, "type is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Dashes";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.number = (spec) => {
            updates["number"] = spec;
            delete childBuilders["number;"];
            modifiedKeys["number"] = true;
            return this;
        };
        this.type = (spec) => {
            updates["type"] = spec;
            delete childBuilders["type;"];
            modifiedKeys["type"] = true;
            return this;
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
        this.dashLength = (spec) => {
            updates["dashLength"] = spec;
            delete childBuilders["dashLength;"];
            modifiedKeys["dashLength"] = true;
            return this;
        };
        this.spaceLength = (spec) => {
            updates["spaceLength"] = spec;
            delete childBuilders["spaceLength;"];
            modifiedKeys["spaceLength"] = true;
            return this;
        };
    }
}
function patchDashes(base, builder) { return builder(new DashesBuilder(base)).patch(); }
exports.patchDashes = patchDashes;
function buildDashes(builder) { return builder(new DashesBuilder()).build(); }
exports.buildDashes = buildDashes;
class BracketBuilder {
    build;
    patch;
    endLength;
    number;
    type;
    lineEnd;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    color;
    lineType;
    dashLength;
    spaceLength;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["endLength"]) ||
                childBuilders["endLength"] !== undefined ||
                updates.endLength !== undefined, "endLength is a required field");
            console.assert((original && !modifiedKeys["number"]) ||
                childBuilders["number"] !== undefined ||
                updates.number !== undefined, "number is a required field");
            console.assert((original && !modifiedKeys["type"]) ||
                childBuilders["type"] !== undefined ||
                updates.type !== undefined, "type is a required field");
            console.assert((original && !modifiedKeys["lineEnd"]) ||
                childBuilders["lineEnd"] !== undefined ||
                updates.lineEnd !== undefined, "lineEnd is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Bracket";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.endLength = (spec) => {
            updates["endLength"] = spec;
            delete childBuilders["endLength;"];
            modifiedKeys["endLength"] = true;
            return this;
        };
        this.number = (spec) => {
            updates["number"] = spec;
            delete childBuilders["number;"];
            modifiedKeys["number"] = true;
            return this;
        };
        this.type = (spec) => {
            updates["type"] = spec;
            delete childBuilders["type;"];
            modifiedKeys["type"] = true;
            return this;
        };
        this.lineEnd = (spec) => {
            updates["lineEnd"] = spec;
            delete childBuilders["lineEnd;"];
            modifiedKeys["lineEnd"] = true;
            return this;
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
        this.lineType = (spec) => {
            updates["lineType"] = spec;
            delete childBuilders["lineType;"];
            modifiedKeys["lineType"] = true;
            return this;
        };
        this.dashLength = (spec) => {
            updates["dashLength"] = spec;
            delete childBuilders["dashLength;"];
            modifiedKeys["dashLength"] = true;
            return this;
        };
        this.spaceLength = (spec) => {
            updates["spaceLength"] = spec;
            delete childBuilders["spaceLength;"];
            modifiedKeys["spaceLength"] = true;
            return this;
        };
    }
}
function patchBracket(base, builder) { return builder(new BracketBuilder(base)).patch(); }
exports.patchBracket = patchBracket;
function buildBracket(builder) { return builder(new BracketBuilder()).build(); }
exports.buildBracket = buildBracket;
class PedalBuilder {
    build;
    patch;
    line;
    sign;
    type;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    fontFamily;
    fontWeight;
    fontStyle;
    fontSize;
    color;
    halign;
    valign;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["line"]) ||
                childBuilders["line"] !== undefined ||
                updates.line !== undefined, "line is a required field");
            console.assert((original && !modifiedKeys["sign"]) ||
                childBuilders["sign"] !== undefined ||
                updates.sign !== undefined, "sign is a required field");
            console.assert((original && !modifiedKeys["type"]) ||
                childBuilders["type"] !== undefined ||
                updates.type !== undefined, "type is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Pedal";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.line = (spec) => {
            updates["line"] = spec;
            delete childBuilders["line;"];
            modifiedKeys["line"] = true;
            return this;
        };
        this.sign = (spec) => {
            updates["sign"] = spec;
            delete childBuilders["sign;"];
            modifiedKeys["sign"] = true;
            return this;
        };
        this.type = (spec) => {
            updates["type"] = spec;
            delete childBuilders["type;"];
            modifiedKeys["type"] = true;
            return this;
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
        this.fontFamily = (spec) => {
            updates["fontFamily"] = spec;
            delete childBuilders["fontFamily;"];
            modifiedKeys["fontFamily"] = true;
            return this;
        };
        this.fontWeight = (spec) => {
            updates["fontWeight"] = spec;
            delete childBuilders["fontWeight;"];
            modifiedKeys["fontWeight"] = true;
            return this;
        };
        this.fontStyle = (spec) => {
            updates["fontStyle"] = spec;
            delete childBuilders["fontStyle;"];
            modifiedKeys["fontStyle"] = true;
            return this;
        };
        this.fontSize = (spec) => {
            updates["fontSize"] = spec;
            delete childBuilders["fontSize;"];
            modifiedKeys["fontSize"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
        this.halign = (spec) => {
            updates["halign"] = spec;
            delete childBuilders["halign;"];
            modifiedKeys["halign"] = true;
            return this;
        };
        this.valign = (spec) => {
            updates["valign"] = spec;
            delete childBuilders["valign;"];
            modifiedKeys["valign"] = true;
            return this;
        };
    }
}
function patchPedal(base, builder) { return builder(new PedalBuilder(base)).patch(); }
exports.patchPedal = patchPedal;
function buildPedal(builder) { return builder(new PedalBuilder()).build(); }
exports.buildPedal = buildPedal;
class MetronomeBuilder {
    build;
    patch;
    metronomeNotesAt;
    metronomeNotesSplice;
    metronomeNotes;
    perMinute;
    parentheses;
    beatUnit;
    beatUnitDotsAt;
    beatUnitDotsSplice;
    beatUnitDots;
    beatUnitChange;
    beatUnitDotsChangeAt;
    beatUnitDotsChangeSplice;
    beatUnitDotsChange;
    metronomeRelation;
    justify;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    fontFamily;
    fontWeight;
    fontStyle;
    fontSize;
    color;
    halign;
    valign;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["metronomeNotes"]) ||
                childBuilders["metronomeNotes"] !== undefined ||
                updates.metronomeNotes !== undefined, "metronomeNotes is a required field");
            console.assert((original && !modifiedKeys["perMinute"]) ||
                childBuilders["perMinute"] !== undefined ||
                updates.perMinute !== undefined, "perMinute is a required field");
            console.assert((original && !modifiedKeys["parentheses"]) ||
                childBuilders["parentheses"] !== undefined ||
                updates.parentheses !== undefined, "parentheses is a required field");
            console.assert((original && !modifiedKeys["beatUnit"]) ||
                childBuilders["beatUnit"] !== undefined ||
                updates.beatUnit !== undefined, "beatUnit is a required field");
            console.assert((original && !modifiedKeys["beatUnitDots"]) ||
                childBuilders["beatUnitDots"] !== undefined ||
                updates.beatUnitDots !== undefined, "beatUnitDots is a required field");
            console.assert((original && !modifiedKeys["beatUnitChange"]) ||
                childBuilders["beatUnitChange"] !== undefined ||
                updates.beatUnitChange !== undefined, "beatUnitChange is a required field");
            console.assert((original && !modifiedKeys["beatUnitDotsChange"]) ||
                childBuilders["beatUnitDotsChange"] !== undefined ||
                updates.beatUnitDotsChange !== undefined, "beatUnitDotsChange is a required field");
            console.assert((original && !modifiedKeys["metronomeRelation"]) ||
                childBuilders["metronomeRelation"] !== undefined ||
                updates.metronomeRelation !== undefined, "metronomeRelation is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Metronome";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.metronomeNotes = (spec) => {
            updates["metronomeNotes"] = spec;
            delete childBuilders["metronomeNotes;"];
            modifiedKeys["metronomeNotes"] = true;
            return this;
        };
        this.metronomeNotesAt = (idx, build) => {
            makeReference("metronomeNotes");
            if (frozen["metronomeNotes"][idx]) {
                throw new Error("Patching metronomeNotes." + idx + " twice in a builder is unsupported.");
            }
            if (original && original._snapshot && original._snapshot["metronomeNotes"] && original._snapshot["metronomeNotes"][idx] && !original["metronomeNotes"][idx]) {
                // Clone snapshot.
                patches.push({ p: ["metronomeNotes", idx], li: original._snapshot["metronomeNotes"] });
            }
            if (typeof build === 'function' && reference["metronomeNotes"][idx]) {
                let patch = build(new MetronomeNoteBuilder(reference["metronomeNotes"][idx])).patch();
                patches = patches.concat(patch.map(patch => {
                    // TODO: detach?
                    patch.p = ["metronomeNotes", idx].concat(patch.p);
                    return patch;
                }));
                frozen["metronomeNotes"][idx] = true;
                return this;
            }
            let update = typeof build === 'function' ? build(new MetronomeNoteBuilder(reference["metronomeNotes"][idx])).build() : build;
            if (original) {
                patches.push({ p: ["metronomeNotes", idx], li: update });
            }
            else {
                updates["metronomeNotes"] = reference["metronomeNotes"]; // TODO: Merge?
            }
            reference["metronomeNotes"][idx] = update;
            frozen["metronomeNotes"][idx] = true;
            return this;
        };
        this.metronomeNotesSplice = (start, deleteCount, ...items) => {
            makeReference("metronomeNotes");
            let idx = start;
            if (original) {
                for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
                    if (frozen["metronomeNotes"][idx]) {
                        throw new Error("Replacing metronomeNotes." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["metronomeNotes"][idx];
                    patches.push({ p: ["metronomeNotes", idx], ld, li: items[idx - start] });
                    frozen["metronomeNotes"][idx] = true;
                }
                for (; idx < start + deleteCount; ++idx) {
                    if (frozen["metronomeNotes"][idx]) {
                        throw new Error("Removing metronomeNotes." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["metronomeNotes"][idx];
                    patches.push({ p: ["metronomeNotes", idx], ld });
                }
                for (; idx < start + items.length; ++idx) {
                    patches.push({ p: ["metronomeNotes", idx], li: items[idx - start] });
                    frozen["metronomeNotes"][idx] = true;
                }
            }
            reference["metronomeNotes"].splice(start, deleteCount, ...items);
            updates["metronomeNotes"] = reference["metronomeNotes"];
            frozen["metronomeNotes"].splice(start, deleteCount, ...items.map(i => true));
            return this;
        };
        this.perMinute = (build) => {
            if (typeof build === 'function') {
                delete updates["perMinute"];
                const builder = build(new PerMinuteBuilder(original && original["perMinute"]));
                if (!original)
                    updates["perMinute"] = builder.build();
                else
                    childBuilders["perMinute"] = builder;
            }
            else {
                updates.perMinute = build;
                delete childBuilders["perMinute;"];
            }
            modifiedKeys["perMinute"] = true;
            return this;
        };
        this.parentheses = (spec) => {
            updates["parentheses"] = spec;
            delete childBuilders["parentheses;"];
            modifiedKeys["parentheses"] = true;
            return this;
        };
        this.beatUnit = (spec) => {
            updates["beatUnit"] = spec;
            delete childBuilders["beatUnit;"];
            modifiedKeys["beatUnit"] = true;
            return this;
        };
        this.beatUnitDots = (spec) => {
            updates["beatUnitDots"] = spec;
            delete childBuilders["beatUnitDots;"];
            modifiedKeys["beatUnitDots"] = true;
            return this;
        };
        this.beatUnitDotsAt = (idx, build) => {
            makeReference("beatUnitDots");
            if (frozen["beatUnitDots"][idx]) {
                throw new Error("Patching beatUnitDots." + idx + " twice in a builder is unsupported.");
            }
            if (original && original._snapshot && original._snapshot["beatUnitDots"] && original._snapshot["beatUnitDots"][idx] && !original["beatUnitDots"][idx]) {
                // Clone snapshot.
                patches.push({ p: ["beatUnitDots", idx], li: original._snapshot["beatUnitDots"] });
            }
            if (typeof build === 'function' && reference["beatUnitDots"][idx]) {
                let patch = build(new BeatUnitDotBuilder(reference["beatUnitDots"][idx])).patch();
                patches = patches.concat(patch.map(patch => {
                    // TODO: detach?
                    patch.p = ["beatUnitDots", idx].concat(patch.p);
                    return patch;
                }));
                frozen["beatUnitDots"][idx] = true;
                return this;
            }
            let update = typeof build === 'function' ? build(new BeatUnitDotBuilder(reference["beatUnitDots"][idx])).build() : build;
            if (original) {
                patches.push({ p: ["beatUnitDots", idx], li: update });
            }
            else {
                updates["beatUnitDots"] = reference["beatUnitDots"]; // TODO: Merge?
            }
            reference["beatUnitDots"][idx] = update;
            frozen["beatUnitDots"][idx] = true;
            return this;
        };
        this.beatUnitDotsSplice = (start, deleteCount, ...items) => {
            makeReference("beatUnitDots");
            let idx = start;
            if (original) {
                for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
                    if (frozen["beatUnitDots"][idx]) {
                        throw new Error("Replacing beatUnitDots." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["beatUnitDots"][idx];
                    patches.push({ p: ["beatUnitDots", idx], ld, li: items[idx - start] });
                    frozen["beatUnitDots"][idx] = true;
                }
                for (; idx < start + deleteCount; ++idx) {
                    if (frozen["beatUnitDots"][idx]) {
                        throw new Error("Removing beatUnitDots." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["beatUnitDots"][idx];
                    patches.push({ p: ["beatUnitDots", idx], ld });
                }
                for (; idx < start + items.length; ++idx) {
                    patches.push({ p: ["beatUnitDots", idx], li: items[idx - start] });
                    frozen["beatUnitDots"][idx] = true;
                }
            }
            reference["beatUnitDots"].splice(start, deleteCount, ...items);
            updates["beatUnitDots"] = reference["beatUnitDots"];
            frozen["beatUnitDots"].splice(start, deleteCount, ...items.map(i => true));
            return this;
        };
        this.beatUnitChange = (spec) => {
            updates["beatUnitChange"] = spec;
            delete childBuilders["beatUnitChange;"];
            modifiedKeys["beatUnitChange"] = true;
            return this;
        };
        this.beatUnitDotsChange = (spec) => {
            updates["beatUnitDotsChange"] = spec;
            delete childBuilders["beatUnitDotsChange;"];
            modifiedKeys["beatUnitDotsChange"] = true;
            return this;
        };
        this.beatUnitDotsChangeAt = (idx, build) => {
            makeReference("beatUnitDotsChange");
            if (frozen["beatUnitDotsChange"][idx]) {
                throw new Error("Patching beatUnitDotsChange." + idx + " twice in a builder is unsupported.");
            }
            if (original && original._snapshot && original._snapshot["beatUnitDotsChange"] && original._snapshot["beatUnitDotsChange"][idx] && !original["beatUnitDotsChange"][idx]) {
                // Clone snapshot.
                patches.push({ p: ["beatUnitDotsChange", idx], li: original._snapshot["beatUnitDotsChange"] });
            }
            if (typeof build === 'function' && reference["beatUnitDotsChange"][idx]) {
                let patch = build(new BeatUnitDotBuilder(reference["beatUnitDotsChange"][idx])).patch();
                patches = patches.concat(patch.map(patch => {
                    // TODO: detach?
                    patch.p = ["beatUnitDotsChange", idx].concat(patch.p);
                    return patch;
                }));
                frozen["beatUnitDotsChange"][idx] = true;
                return this;
            }
            let update = typeof build === 'function' ? build(new BeatUnitDotBuilder(reference["beatUnitDotsChange"][idx])).build() : build;
            if (original) {
                patches.push({ p: ["beatUnitDotsChange", idx], li: update });
            }
            else {
                updates["beatUnitDotsChange"] = reference["beatUnitDotsChange"]; // TODO: Merge?
            }
            reference["beatUnitDotsChange"][idx] = update;
            frozen["beatUnitDotsChange"][idx] = true;
            return this;
        };
        this.beatUnitDotsChangeSplice = (start, deleteCount, ...items) => {
            makeReference("beatUnitDotsChange");
            let idx = start;
            if (original) {
                for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
                    if (frozen["beatUnitDotsChange"][idx]) {
                        throw new Error("Replacing beatUnitDotsChange." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["beatUnitDotsChange"][idx];
                    patches.push({ p: ["beatUnitDotsChange", idx], ld, li: items[idx - start] });
                    frozen["beatUnitDotsChange"][idx] = true;
                }
                for (; idx < start + deleteCount; ++idx) {
                    if (frozen["beatUnitDotsChange"][idx]) {
                        throw new Error("Removing beatUnitDotsChange." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["beatUnitDotsChange"][idx];
                    patches.push({ p: ["beatUnitDotsChange", idx], ld });
                }
                for (; idx < start + items.length; ++idx) {
                    patches.push({ p: ["beatUnitDotsChange", idx], li: items[idx - start] });
                    frozen["beatUnitDotsChange"][idx] = true;
                }
            }
            reference["beatUnitDotsChange"].splice(start, deleteCount, ...items);
            updates["beatUnitDotsChange"] = reference["beatUnitDotsChange"];
            frozen["beatUnitDotsChange"].splice(start, deleteCount, ...items.map(i => true));
            return this;
        };
        this.metronomeRelation = (spec) => {
            updates["metronomeRelation"] = spec;
            delete childBuilders["metronomeRelation;"];
            modifiedKeys["metronomeRelation"] = true;
            return this;
        };
        this.justify = (spec) => {
            updates["justify"] = spec;
            delete childBuilders["justify;"];
            modifiedKeys["justify"] = true;
            return this;
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
        this.fontFamily = (spec) => {
            updates["fontFamily"] = spec;
            delete childBuilders["fontFamily;"];
            modifiedKeys["fontFamily"] = true;
            return this;
        };
        this.fontWeight = (spec) => {
            updates["fontWeight"] = spec;
            delete childBuilders["fontWeight;"];
            modifiedKeys["fontWeight"] = true;
            return this;
        };
        this.fontStyle = (spec) => {
            updates["fontStyle"] = spec;
            delete childBuilders["fontStyle;"];
            modifiedKeys["fontStyle"] = true;
            return this;
        };
        this.fontSize = (spec) => {
            updates["fontSize"] = spec;
            delete childBuilders["fontSize;"];
            modifiedKeys["fontSize"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
        this.halign = (spec) => {
            updates["halign"] = spec;
            delete childBuilders["halign;"];
            modifiedKeys["halign"] = true;
            return this;
        };
        this.valign = (spec) => {
            updates["valign"] = spec;
            delete childBuilders["valign;"];
            modifiedKeys["valign"] = true;
            return this;
        };
    }
}
function patchMetronome(base, builder) { return builder(new MetronomeBuilder(base)).patch(); }
exports.patchMetronome = patchMetronome;
function buildMetronome(builder) { return builder(new MetronomeBuilder()).build(); }
exports.buildMetronome = buildMetronome;
class BeatUnitDotBuilder {
    build;
    patch;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "BeatUnitDot";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
    }
}
function patchBeatUnitDot(base, builder) { return builder(new BeatUnitDotBuilder(base)).patch(); }
exports.patchBeatUnitDot = patchBeatUnitDot;
function buildBeatUnitDot(builder) { return builder(new BeatUnitDotBuilder()).build(); }
exports.buildBeatUnitDot = buildBeatUnitDot;
class PerMinuteBuilder {
    build;
    patch;
    data;
    fontFamily;
    fontWeight;
    fontStyle;
    fontSize;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["data"]) ||
                childBuilders["data"] !== undefined ||
                updates.data !== undefined, "data is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "PerMinute";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.data = (spec) => {
            updates["data"] = spec;
            delete childBuilders["data;"];
            modifiedKeys["data"] = true;
            return this;
        };
        this.fontFamily = (spec) => {
            updates["fontFamily"] = spec;
            delete childBuilders["fontFamily;"];
            modifiedKeys["fontFamily"] = true;
            return this;
        };
        this.fontWeight = (spec) => {
            updates["fontWeight"] = spec;
            delete childBuilders["fontWeight;"];
            modifiedKeys["fontWeight"] = true;
            return this;
        };
        this.fontStyle = (spec) => {
            updates["fontStyle"] = spec;
            delete childBuilders["fontStyle;"];
            modifiedKeys["fontStyle"] = true;
            return this;
        };
        this.fontSize = (spec) => {
            updates["fontSize"] = spec;
            delete childBuilders["fontSize;"];
            modifiedKeys["fontSize"] = true;
            return this;
        };
    }
}
function patchPerMinute(base, builder) { return builder(new PerMinuteBuilder(base)).patch(); }
exports.patchPerMinute = patchPerMinute;
function buildPerMinute(builder) { return builder(new PerMinuteBuilder()).build(); }
exports.buildPerMinute = buildPerMinute;
class MetronomeNoteBuilder {
    build;
    patch;
    metronomeDotsAt;
    metronomeDotsSplice;
    metronomeDots;
    metronomeBeamsAt;
    metronomeBeamsSplice;
    metronomeBeams;
    metronomeType;
    metronomeTuplet;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["metronomeDots"]) ||
                childBuilders["metronomeDots"] !== undefined ||
                updates.metronomeDots !== undefined, "metronomeDots is a required field");
            console.assert((original && !modifiedKeys["metronomeBeams"]) ||
                childBuilders["metronomeBeams"] !== undefined ||
                updates.metronomeBeams !== undefined, "metronomeBeams is a required field");
            console.assert((original && !modifiedKeys["metronomeType"]) ||
                childBuilders["metronomeType"] !== undefined ||
                updates.metronomeType !== undefined, "metronomeType is a required field");
            console.assert((original && !modifiedKeys["metronomeTuplet"]) ||
                childBuilders["metronomeTuplet"] !== undefined ||
                updates.metronomeTuplet !== undefined, "metronomeTuplet is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "MetronomeNote";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.metronomeDots = (spec) => {
            updates["metronomeDots"] = spec;
            delete childBuilders["metronomeDots;"];
            modifiedKeys["metronomeDots"] = true;
            return this;
        };
        this.metronomeDotsAt = (idx, build) => {
            makeReference("metronomeDots");
            if (frozen["metronomeDots"][idx]) {
                throw new Error("Patching metronomeDots." + idx + " twice in a builder is unsupported.");
            }
            if (original && original._snapshot && original._snapshot["metronomeDots"] && original._snapshot["metronomeDots"][idx] && !original["metronomeDots"][idx]) {
                // Clone snapshot.
                patches.push({ p: ["metronomeDots", idx], li: original._snapshot["metronomeDots"] });
            }
            if (typeof build === 'function' && reference["metronomeDots"][idx]) {
                let patch = build(new MetronomeDotBuilder(reference["metronomeDots"][idx])).patch();
                patches = patches.concat(patch.map(patch => {
                    // TODO: detach?
                    patch.p = ["metronomeDots", idx].concat(patch.p);
                    return patch;
                }));
                frozen["metronomeDots"][idx] = true;
                return this;
            }
            let update = typeof build === 'function' ? build(new MetronomeDotBuilder(reference["metronomeDots"][idx])).build() : build;
            if (original) {
                patches.push({ p: ["metronomeDots", idx], li: update });
            }
            else {
                updates["metronomeDots"] = reference["metronomeDots"]; // TODO: Merge?
            }
            reference["metronomeDots"][idx] = update;
            frozen["metronomeDots"][idx] = true;
            return this;
        };
        this.metronomeDotsSplice = (start, deleteCount, ...items) => {
            makeReference("metronomeDots");
            let idx = start;
            if (original) {
                for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
                    if (frozen["metronomeDots"][idx]) {
                        throw new Error("Replacing metronomeDots." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["metronomeDots"][idx];
                    patches.push({ p: ["metronomeDots", idx], ld, li: items[idx - start] });
                    frozen["metronomeDots"][idx] = true;
                }
                for (; idx < start + deleteCount; ++idx) {
                    if (frozen["metronomeDots"][idx]) {
                        throw new Error("Removing metronomeDots." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["metronomeDots"][idx];
                    patches.push({ p: ["metronomeDots", idx], ld });
                }
                for (; idx < start + items.length; ++idx) {
                    patches.push({ p: ["metronomeDots", idx], li: items[idx - start] });
                    frozen["metronomeDots"][idx] = true;
                }
            }
            reference["metronomeDots"].splice(start, deleteCount, ...items);
            updates["metronomeDots"] = reference["metronomeDots"];
            frozen["metronomeDots"].splice(start, deleteCount, ...items.map(i => true));
            return this;
        };
        this.metronomeBeams = (spec) => {
            updates["metronomeBeams"] = spec;
            delete childBuilders["metronomeBeams;"];
            modifiedKeys["metronomeBeams"] = true;
            return this;
        };
        this.metronomeBeamsAt = (idx, build) => {
            makeReference("metronomeBeams");
            if (frozen["metronomeBeams"][idx]) {
                throw new Error("Patching metronomeBeams." + idx + " twice in a builder is unsupported.");
            }
            if (original && original._snapshot && original._snapshot["metronomeBeams"] && original._snapshot["metronomeBeams"][idx] && !original["metronomeBeams"][idx]) {
                // Clone snapshot.
                patches.push({ p: ["metronomeBeams", idx], li: original._snapshot["metronomeBeams"] });
            }
            if (typeof build === 'function' && reference["metronomeBeams"][idx]) {
                let patch = build(new MetronomeBeamBuilder(reference["metronomeBeams"][idx])).patch();
                patches = patches.concat(patch.map(patch => {
                    // TODO: detach?
                    patch.p = ["metronomeBeams", idx].concat(patch.p);
                    return patch;
                }));
                frozen["metronomeBeams"][idx] = true;
                return this;
            }
            let update = typeof build === 'function' ? build(new MetronomeBeamBuilder(reference["metronomeBeams"][idx])).build() : build;
            if (original) {
                patches.push({ p: ["metronomeBeams", idx], li: update });
            }
            else {
                updates["metronomeBeams"] = reference["metronomeBeams"]; // TODO: Merge?
            }
            reference["metronomeBeams"][idx] = update;
            frozen["metronomeBeams"][idx] = true;
            return this;
        };
        this.metronomeBeamsSplice = (start, deleteCount, ...items) => {
            makeReference("metronomeBeams");
            let idx = start;
            if (original) {
                for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
                    if (frozen["metronomeBeams"][idx]) {
                        throw new Error("Replacing metronomeBeams." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["metronomeBeams"][idx];
                    patches.push({ p: ["metronomeBeams", idx], ld, li: items[idx - start] });
                    frozen["metronomeBeams"][idx] = true;
                }
                for (; idx < start + deleteCount; ++idx) {
                    if (frozen["metronomeBeams"][idx]) {
                        throw new Error("Removing metronomeBeams." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["metronomeBeams"][idx];
                    patches.push({ p: ["metronomeBeams", idx], ld });
                }
                for (; idx < start + items.length; ++idx) {
                    patches.push({ p: ["metronomeBeams", idx], li: items[idx - start] });
                    frozen["metronomeBeams"][idx] = true;
                }
            }
            reference["metronomeBeams"].splice(start, deleteCount, ...items);
            updates["metronomeBeams"] = reference["metronomeBeams"];
            frozen["metronomeBeams"].splice(start, deleteCount, ...items.map(i => true));
            return this;
        };
        this.metronomeType = (spec) => {
            updates["metronomeType"] = spec;
            delete childBuilders["metronomeType;"];
            modifiedKeys["metronomeType"] = true;
            return this;
        };
        this.metronomeTuplet = (build) => {
            if (typeof build === 'function') {
                delete updates["metronomeTuplet"];
                const builder = build(new MetronomeTupletBuilder(original && original["metronomeTuplet"]));
                if (!original)
                    updates["metronomeTuplet"] = builder.build();
                else
                    childBuilders["metronomeTuplet"] = builder;
            }
            else {
                updates.metronomeTuplet = build;
                delete childBuilders["metronomeTuplet;"];
            }
            modifiedKeys["metronomeTuplet"] = true;
            return this;
        };
    }
}
function patchMetronomeNote(base, builder) { return builder(new MetronomeNoteBuilder(base)).patch(); }
exports.patchMetronomeNote = patchMetronomeNote;
function buildMetronomeNote(builder) { return builder(new MetronomeNoteBuilder()).build(); }
exports.buildMetronomeNote = buildMetronomeNote;
class MetronomeDotBuilder {
    build;
    patch;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "MetronomeDot";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
    }
}
function patchMetronomeDot(base, builder) { return builder(new MetronomeDotBuilder(base)).patch(); }
exports.patchMetronomeDot = patchMetronomeDot;
function buildMetronomeDot(builder) { return builder(new MetronomeDotBuilder()).build(); }
exports.buildMetronomeDot = buildMetronomeDot;
class MetronomeBeamBuilder {
    build;
    patch;
    number;
    data;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["number"]) ||
                childBuilders["number"] !== undefined ||
                updates.number !== undefined, "number is a required field");
            console.assert((original && !modifiedKeys["data"]) ||
                childBuilders["data"] !== undefined ||
                updates.data !== undefined, "data is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "MetronomeBeam";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.number = (spec) => {
            updates["number"] = spec;
            delete childBuilders["number;"];
            modifiedKeys["number"] = true;
            return this;
        };
        this.data = (spec) => {
            updates["data"] = spec;
            delete childBuilders["data;"];
            modifiedKeys["data"] = true;
            return this;
        };
    }
}
function patchMetronomeBeam(base, builder) { return builder(new MetronomeBeamBuilder(base)).patch(); }
exports.patchMetronomeBeam = patchMetronomeBeam;
function buildMetronomeBeam(builder) { return builder(new MetronomeBeamBuilder()).build(); }
exports.buildMetronomeBeam = buildMetronomeBeam;
class MetronomeTupletBuilder {
    build;
    patch;
    actualNotes;
    bracket;
    showNumber;
    normalType;
    type;
    normalNotes;
    normalDotsAt;
    normalDotsSplice;
    normalDots;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["actualNotes"]) ||
                childBuilders["actualNotes"] !== undefined ||
                updates.actualNotes !== undefined, "actualNotes is a required field");
            console.assert((original && !modifiedKeys["bracket"]) ||
                childBuilders["bracket"] !== undefined ||
                updates.bracket !== undefined, "bracket is a required field");
            console.assert((original && !modifiedKeys["showNumber"]) ||
                childBuilders["showNumber"] !== undefined ||
                updates.showNumber !== undefined, "showNumber is a required field");
            console.assert((original && !modifiedKeys["normalType"]) ||
                childBuilders["normalType"] !== undefined ||
                updates.normalType !== undefined, "normalType is a required field");
            console.assert((original && !modifiedKeys["type"]) ||
                childBuilders["type"] !== undefined ||
                updates.type !== undefined, "type is a required field");
            console.assert((original && !modifiedKeys["normalNotes"]) ||
                childBuilders["normalNotes"] !== undefined ||
                updates.normalNotes !== undefined, "normalNotes is a required field");
            console.assert((original && !modifiedKeys["normalDots"]) ||
                childBuilders["normalDots"] !== undefined ||
                updates.normalDots !== undefined, "normalDots is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "MetronomeTuplet";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.actualNotes = (spec) => {
            updates["actualNotes"] = spec;
            delete childBuilders["actualNotes;"];
            modifiedKeys["actualNotes"] = true;
            return this;
        };
        this.bracket = (spec) => {
            updates["bracket"] = spec;
            delete childBuilders["bracket;"];
            modifiedKeys["bracket"] = true;
            return this;
        };
        this.showNumber = (spec) => {
            updates["showNumber"] = spec;
            delete childBuilders["showNumber;"];
            modifiedKeys["showNumber"] = true;
            return this;
        };
        this.normalType = (spec) => {
            updates["normalType"] = spec;
            delete childBuilders["normalType;"];
            modifiedKeys["normalType"] = true;
            return this;
        };
        this.type = (spec) => {
            updates["type"] = spec;
            delete childBuilders["type;"];
            modifiedKeys["type"] = true;
            return this;
        };
        this.normalNotes = (spec) => {
            updates["normalNotes"] = spec;
            delete childBuilders["normalNotes;"];
            modifiedKeys["normalNotes"] = true;
            return this;
        };
        this.normalDots = (spec) => {
            updates["normalDots"] = spec;
            delete childBuilders["normalDots;"];
            modifiedKeys["normalDots"] = true;
            return this;
        };
        this.normalDotsAt = (idx, build) => {
            makeReference("normalDots");
            if (frozen["normalDots"][idx]) {
                throw new Error("Patching normalDots." + idx + " twice in a builder is unsupported.");
            }
            if (original && original._snapshot && original._snapshot["normalDots"] && original._snapshot["normalDots"][idx] && !original["normalDots"][idx]) {
                // Clone snapshot.
                patches.push({ p: ["normalDots", idx], li: original._snapshot["normalDots"] });
            }
            if (typeof build === 'function' && reference["normalDots"][idx]) {
                let patch = build(new NormalDotBuilder(reference["normalDots"][idx])).patch();
                patches = patches.concat(patch.map(patch => {
                    // TODO: detach?
                    patch.p = ["normalDots", idx].concat(patch.p);
                    return patch;
                }));
                frozen["normalDots"][idx] = true;
                return this;
            }
            let update = typeof build === 'function' ? build(new NormalDotBuilder(reference["normalDots"][idx])).build() : build;
            if (original) {
                patches.push({ p: ["normalDots", idx], li: update });
            }
            else {
                updates["normalDots"] = reference["normalDots"]; // TODO: Merge?
            }
            reference["normalDots"][idx] = update;
            frozen["normalDots"][idx] = true;
            return this;
        };
        this.normalDotsSplice = (start, deleteCount, ...items) => {
            makeReference("normalDots");
            let idx = start;
            if (original) {
                for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
                    if (frozen["normalDots"][idx]) {
                        throw new Error("Replacing normalDots." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["normalDots"][idx];
                    patches.push({ p: ["normalDots", idx], ld, li: items[idx - start] });
                    frozen["normalDots"][idx] = true;
                }
                for (; idx < start + deleteCount; ++idx) {
                    if (frozen["normalDots"][idx]) {
                        throw new Error("Removing normalDots." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["normalDots"][idx];
                    patches.push({ p: ["normalDots", idx], ld });
                }
                for (; idx < start + items.length; ++idx) {
                    patches.push({ p: ["normalDots", idx], li: items[idx - start] });
                    frozen["normalDots"][idx] = true;
                }
            }
            reference["normalDots"].splice(start, deleteCount, ...items);
            updates["normalDots"] = reference["normalDots"];
            frozen["normalDots"].splice(start, deleteCount, ...items.map(i => true));
            return this;
        };
    }
}
function patchMetronomeTuplet(base, builder) { return builder(new MetronomeTupletBuilder(base)).patch(); }
exports.patchMetronomeTuplet = patchMetronomeTuplet;
function buildMetronomeTuplet(builder) { return builder(new MetronomeTupletBuilder()).build(); }
exports.buildMetronomeTuplet = buildMetronomeTuplet;
class OctaveShiftBuilder {
    build;
    patch;
    number;
    size;
    type;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    fontFamily;
    fontWeight;
    fontStyle;
    fontSize;
    color;
    dashLength;
    spaceLength;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["number"]) ||
                childBuilders["number"] !== undefined ||
                updates.number !== undefined, "number is a required field");
            console.assert((original && !modifiedKeys["size"]) ||
                childBuilders["size"] !== undefined ||
                updates.size !== undefined, "size is a required field");
            console.assert((original && !modifiedKeys["type"]) ||
                childBuilders["type"] !== undefined ||
                updates.type !== undefined, "type is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "OctaveShift";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.number = (spec) => {
            updates["number"] = spec;
            delete childBuilders["number;"];
            modifiedKeys["number"] = true;
            return this;
        };
        this.size = (spec) => {
            updates["size"] = spec;
            delete childBuilders["size;"];
            modifiedKeys["size"] = true;
            return this;
        };
        this.type = (spec) => {
            updates["type"] = spec;
            delete childBuilders["type;"];
            modifiedKeys["type"] = true;
            return this;
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
        this.fontFamily = (spec) => {
            updates["fontFamily"] = spec;
            delete childBuilders["fontFamily;"];
            modifiedKeys["fontFamily"] = true;
            return this;
        };
        this.fontWeight = (spec) => {
            updates["fontWeight"] = spec;
            delete childBuilders["fontWeight;"];
            modifiedKeys["fontWeight"] = true;
            return this;
        };
        this.fontStyle = (spec) => {
            updates["fontStyle"] = spec;
            delete childBuilders["fontStyle;"];
            modifiedKeys["fontStyle"] = true;
            return this;
        };
        this.fontSize = (spec) => {
            updates["fontSize"] = spec;
            delete childBuilders["fontSize;"];
            modifiedKeys["fontSize"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
        this.dashLength = (spec) => {
            updates["dashLength"] = spec;
            delete childBuilders["dashLength;"];
            modifiedKeys["dashLength"] = true;
            return this;
        };
        this.spaceLength = (spec) => {
            updates["spaceLength"] = spec;
            delete childBuilders["spaceLength;"];
            modifiedKeys["spaceLength"] = true;
            return this;
        };
    }
}
function patchOctaveShift(base, builder) { return builder(new OctaveShiftBuilder(base)).patch(); }
exports.patchOctaveShift = patchOctaveShift;
function buildOctaveShift(builder) { return builder(new OctaveShiftBuilder()).build(); }
exports.buildOctaveShift = buildOctaveShift;
class HarpPedalsBuilder {
    build;
    patch;
    pedalTuningsAt;
    pedalTuningsSplice;
    pedalTunings;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    fontFamily;
    fontWeight;
    fontStyle;
    fontSize;
    color;
    halign;
    valign;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["pedalTunings"]) ||
                childBuilders["pedalTunings"] !== undefined ||
                updates.pedalTunings !== undefined, "pedalTunings is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "HarpPedals";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.pedalTunings = (spec) => {
            updates["pedalTunings"] = spec;
            delete childBuilders["pedalTunings;"];
            modifiedKeys["pedalTunings"] = true;
            return this;
        };
        this.pedalTuningsAt = (idx, build) => {
            makeReference("pedalTunings");
            if (frozen["pedalTunings"][idx]) {
                throw new Error("Patching pedalTunings." + idx + " twice in a builder is unsupported.");
            }
            if (original && original._snapshot && original._snapshot["pedalTunings"] && original._snapshot["pedalTunings"][idx] && !original["pedalTunings"][idx]) {
                // Clone snapshot.
                patches.push({ p: ["pedalTunings", idx], li: original._snapshot["pedalTunings"] });
            }
            if (typeof build === 'function' && reference["pedalTunings"][idx]) {
                let patch = build(new PedalTuningBuilder(reference["pedalTunings"][idx])).patch();
                patches = patches.concat(patch.map(patch => {
                    // TODO: detach?
                    patch.p = ["pedalTunings", idx].concat(patch.p);
                    return patch;
                }));
                frozen["pedalTunings"][idx] = true;
                return this;
            }
            let update = typeof build === 'function' ? build(new PedalTuningBuilder(reference["pedalTunings"][idx])).build() : build;
            if (original) {
                patches.push({ p: ["pedalTunings", idx], li: update });
            }
            else {
                updates["pedalTunings"] = reference["pedalTunings"]; // TODO: Merge?
            }
            reference["pedalTunings"][idx] = update;
            frozen["pedalTunings"][idx] = true;
            return this;
        };
        this.pedalTuningsSplice = (start, deleteCount, ...items) => {
            makeReference("pedalTunings");
            let idx = start;
            if (original) {
                for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
                    if (frozen["pedalTunings"][idx]) {
                        throw new Error("Replacing pedalTunings." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["pedalTunings"][idx];
                    patches.push({ p: ["pedalTunings", idx], ld, li: items[idx - start] });
                    frozen["pedalTunings"][idx] = true;
                }
                for (; idx < start + deleteCount; ++idx) {
                    if (frozen["pedalTunings"][idx]) {
                        throw new Error("Removing pedalTunings." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["pedalTunings"][idx];
                    patches.push({ p: ["pedalTunings", idx], ld });
                }
                for (; idx < start + items.length; ++idx) {
                    patches.push({ p: ["pedalTunings", idx], li: items[idx - start] });
                    frozen["pedalTunings"][idx] = true;
                }
            }
            reference["pedalTunings"].splice(start, deleteCount, ...items);
            updates["pedalTunings"] = reference["pedalTunings"];
            frozen["pedalTunings"].splice(start, deleteCount, ...items.map(i => true));
            return this;
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
        this.fontFamily = (spec) => {
            updates["fontFamily"] = spec;
            delete childBuilders["fontFamily;"];
            modifiedKeys["fontFamily"] = true;
            return this;
        };
        this.fontWeight = (spec) => {
            updates["fontWeight"] = spec;
            delete childBuilders["fontWeight;"];
            modifiedKeys["fontWeight"] = true;
            return this;
        };
        this.fontStyle = (spec) => {
            updates["fontStyle"] = spec;
            delete childBuilders["fontStyle;"];
            modifiedKeys["fontStyle"] = true;
            return this;
        };
        this.fontSize = (spec) => {
            updates["fontSize"] = spec;
            delete childBuilders["fontSize;"];
            modifiedKeys["fontSize"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
        this.halign = (spec) => {
            updates["halign"] = spec;
            delete childBuilders["halign;"];
            modifiedKeys["halign"] = true;
            return this;
        };
        this.valign = (spec) => {
            updates["valign"] = spec;
            delete childBuilders["valign;"];
            modifiedKeys["valign"] = true;
            return this;
        };
    }
}
function patchHarpPedals(base, builder) { return builder(new HarpPedalsBuilder(base)).patch(); }
exports.patchHarpPedals = patchHarpPedals;
function buildHarpPedals(builder) { return builder(new HarpPedalsBuilder()).build(); }
exports.buildHarpPedals = buildHarpPedals;
class PedalTuningBuilder {
    build;
    patch;
    pedalStep;
    pedalAlter;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["pedalStep"]) ||
                childBuilders["pedalStep"] !== undefined ||
                updates.pedalStep !== undefined, "pedalStep is a required field");
            console.assert((original && !modifiedKeys["pedalAlter"]) ||
                childBuilders["pedalAlter"] !== undefined ||
                updates.pedalAlter !== undefined, "pedalAlter is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "PedalTuning";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.pedalStep = (spec) => {
            updates["pedalStep"] = spec;
            delete childBuilders["pedalStep;"];
            modifiedKeys["pedalStep"] = true;
            return this;
        };
        this.pedalAlter = (spec) => {
            updates["pedalAlter"] = spec;
            delete childBuilders["pedalAlter;"];
            modifiedKeys["pedalAlter"] = true;
            return this;
        };
    }
}
function patchPedalTuning(base, builder) { return builder(new PedalTuningBuilder(base)).patch(); }
exports.patchPedalTuning = patchPedalTuning;
function buildPedalTuning(builder) { return builder(new PedalTuningBuilder()).build(); }
exports.buildPedalTuning = buildPedalTuning;
class DampBuilder {
    build;
    patch;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    fontFamily;
    fontWeight;
    fontStyle;
    fontSize;
    color;
    halign;
    valign;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Damp";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
        this.fontFamily = (spec) => {
            updates["fontFamily"] = spec;
            delete childBuilders["fontFamily;"];
            modifiedKeys["fontFamily"] = true;
            return this;
        };
        this.fontWeight = (spec) => {
            updates["fontWeight"] = spec;
            delete childBuilders["fontWeight;"];
            modifiedKeys["fontWeight"] = true;
            return this;
        };
        this.fontStyle = (spec) => {
            updates["fontStyle"] = spec;
            delete childBuilders["fontStyle;"];
            modifiedKeys["fontStyle"] = true;
            return this;
        };
        this.fontSize = (spec) => {
            updates["fontSize"] = spec;
            delete childBuilders["fontSize;"];
            modifiedKeys["fontSize"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
        this.halign = (spec) => {
            updates["halign"] = spec;
            delete childBuilders["halign;"];
            modifiedKeys["halign"] = true;
            return this;
        };
        this.valign = (spec) => {
            updates["valign"] = spec;
            delete childBuilders["valign;"];
            modifiedKeys["valign"] = true;
            return this;
        };
    }
}
function patchDamp(base, builder) { return builder(new DampBuilder(base)).patch(); }
exports.patchDamp = patchDamp;
function buildDamp(builder) { return builder(new DampBuilder()).build(); }
exports.buildDamp = buildDamp;
class DampAllBuilder {
    build;
    patch;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    fontFamily;
    fontWeight;
    fontStyle;
    fontSize;
    color;
    halign;
    valign;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "DampAll";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
        this.fontFamily = (spec) => {
            updates["fontFamily"] = spec;
            delete childBuilders["fontFamily;"];
            modifiedKeys["fontFamily"] = true;
            return this;
        };
        this.fontWeight = (spec) => {
            updates["fontWeight"] = spec;
            delete childBuilders["fontWeight;"];
            modifiedKeys["fontWeight"] = true;
            return this;
        };
        this.fontStyle = (spec) => {
            updates["fontStyle"] = spec;
            delete childBuilders["fontStyle;"];
            modifiedKeys["fontStyle"] = true;
            return this;
        };
        this.fontSize = (spec) => {
            updates["fontSize"] = spec;
            delete childBuilders["fontSize;"];
            modifiedKeys["fontSize"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
        this.halign = (spec) => {
            updates["halign"] = spec;
            delete childBuilders["halign;"];
            modifiedKeys["halign"] = true;
            return this;
        };
        this.valign = (spec) => {
            updates["valign"] = spec;
            delete childBuilders["valign;"];
            modifiedKeys["valign"] = true;
            return this;
        };
    }
}
function patchDampAll(base, builder) { return builder(new DampAllBuilder(base)).patch(); }
exports.patchDampAll = patchDampAll;
function buildDampAll(builder) { return builder(new DampAllBuilder()).build(); }
exports.buildDampAll = buildDampAll;
class EyeglassesBuilder {
    build;
    patch;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    fontFamily;
    fontWeight;
    fontStyle;
    fontSize;
    color;
    halign;
    valign;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Eyeglasses";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
        this.fontFamily = (spec) => {
            updates["fontFamily"] = spec;
            delete childBuilders["fontFamily;"];
            modifiedKeys["fontFamily"] = true;
            return this;
        };
        this.fontWeight = (spec) => {
            updates["fontWeight"] = spec;
            delete childBuilders["fontWeight;"];
            modifiedKeys["fontWeight"] = true;
            return this;
        };
        this.fontStyle = (spec) => {
            updates["fontStyle"] = spec;
            delete childBuilders["fontStyle;"];
            modifiedKeys["fontStyle"] = true;
            return this;
        };
        this.fontSize = (spec) => {
            updates["fontSize"] = spec;
            delete childBuilders["fontSize;"];
            modifiedKeys["fontSize"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
        this.halign = (spec) => {
            updates["halign"] = spec;
            delete childBuilders["halign;"];
            modifiedKeys["halign"] = true;
            return this;
        };
        this.valign = (spec) => {
            updates["valign"] = spec;
            delete childBuilders["valign;"];
            modifiedKeys["valign"] = true;
            return this;
        };
    }
}
function patchEyeglasses(base, builder) { return builder(new EyeglassesBuilder(base)).patch(); }
exports.patchEyeglasses = patchEyeglasses;
function buildEyeglasses(builder) { return builder(new EyeglassesBuilder()).build(); }
exports.buildEyeglasses = buildEyeglasses;
class StringMuteBuilder {
    build;
    patch;
    type;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    fontFamily;
    fontWeight;
    fontStyle;
    fontSize;
    color;
    halign;
    valign;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["type"]) ||
                childBuilders["type"] !== undefined ||
                updates.type !== undefined, "type is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "StringMute";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.type = (spec) => {
            updates["type"] = spec;
            delete childBuilders["type;"];
            modifiedKeys["type"] = true;
            return this;
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
        this.fontFamily = (spec) => {
            updates["fontFamily"] = spec;
            delete childBuilders["fontFamily;"];
            modifiedKeys["fontFamily"] = true;
            return this;
        };
        this.fontWeight = (spec) => {
            updates["fontWeight"] = spec;
            delete childBuilders["fontWeight;"];
            modifiedKeys["fontWeight"] = true;
            return this;
        };
        this.fontStyle = (spec) => {
            updates["fontStyle"] = spec;
            delete childBuilders["fontStyle;"];
            modifiedKeys["fontStyle"] = true;
            return this;
        };
        this.fontSize = (spec) => {
            updates["fontSize"] = spec;
            delete childBuilders["fontSize;"];
            modifiedKeys["fontSize"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
        this.halign = (spec) => {
            updates["halign"] = spec;
            delete childBuilders["halign;"];
            modifiedKeys["halign"] = true;
            return this;
        };
        this.valign = (spec) => {
            updates["valign"] = spec;
            delete childBuilders["valign;"];
            modifiedKeys["valign"] = true;
            return this;
        };
    }
}
function patchStringMute(base, builder) { return builder(new StringMuteBuilder(base)).patch(); }
exports.patchStringMute = patchStringMute;
function buildStringMute(builder) { return builder(new StringMuteBuilder()).build(); }
exports.buildStringMute = buildStringMute;
class ScordaturaBuilder {
    build;
    patch;
    accordsAt;
    accordsSplice;
    accords;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["accords"]) ||
                childBuilders["accords"] !== undefined ||
                updates.accords !== undefined, "accords is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Scordatura";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.accords = (spec) => {
            updates["accords"] = spec;
            delete childBuilders["accords;"];
            modifiedKeys["accords"] = true;
            return this;
        };
        this.accordsAt = (idx, build) => {
            makeReference("accords");
            if (frozen["accords"][idx]) {
                throw new Error("Patching accords." + idx + " twice in a builder is unsupported.");
            }
            if (original && original._snapshot && original._snapshot["accords"] && original._snapshot["accords"][idx] && !original["accords"][idx]) {
                // Clone snapshot.
                patches.push({ p: ["accords", idx], li: original._snapshot["accords"] });
            }
            if (typeof build === 'function' && reference["accords"][idx]) {
                let patch = build(new AccordBuilder(reference["accords"][idx])).patch();
                patches = patches.concat(patch.map(patch => {
                    // TODO: detach?
                    patch.p = ["accords", idx].concat(patch.p);
                    return patch;
                }));
                frozen["accords"][idx] = true;
                return this;
            }
            let update = typeof build === 'function' ? build(new AccordBuilder(reference["accords"][idx])).build() : build;
            if (original) {
                patches.push({ p: ["accords", idx], li: update });
            }
            else {
                updates["accords"] = reference["accords"]; // TODO: Merge?
            }
            reference["accords"][idx] = update;
            frozen["accords"][idx] = true;
            return this;
        };
        this.accordsSplice = (start, deleteCount, ...items) => {
            makeReference("accords");
            let idx = start;
            if (original) {
                for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
                    if (frozen["accords"][idx]) {
                        throw new Error("Replacing accords." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["accords"][idx];
                    patches.push({ p: ["accords", idx], ld, li: items[idx - start] });
                    frozen["accords"][idx] = true;
                }
                for (; idx < start + deleteCount; ++idx) {
                    if (frozen["accords"][idx]) {
                        throw new Error("Removing accords." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["accords"][idx];
                    patches.push({ p: ["accords", idx], ld });
                }
                for (; idx < start + items.length; ++idx) {
                    patches.push({ p: ["accords", idx], li: items[idx - start] });
                    frozen["accords"][idx] = true;
                }
            }
            reference["accords"].splice(start, deleteCount, ...items);
            updates["accords"] = reference["accords"];
            frozen["accords"].splice(start, deleteCount, ...items.map(i => true));
            return this;
        };
    }
}
function patchScordatura(base, builder) { return builder(new ScordaturaBuilder(base)).patch(); }
exports.patchScordatura = patchScordatura;
function buildScordatura(builder) { return builder(new ScordaturaBuilder()).build(); }
exports.buildScordatura = buildScordatura;
class AccordBuilder {
    build;
    patch;
    tuningAlter;
    string;
    tuningStep;
    tuningOctave;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["tuningAlter"]) ||
                childBuilders["tuningAlter"] !== undefined ||
                updates.tuningAlter !== undefined, "tuningAlter is a required field");
            console.assert((original && !modifiedKeys["string"]) ||
                childBuilders["string"] !== undefined ||
                updates.string !== undefined, "string is a required field");
            console.assert((original && !modifiedKeys["tuningStep"]) ||
                childBuilders["tuningStep"] !== undefined ||
                updates.tuningStep !== undefined, "tuningStep is a required field");
            console.assert((original && !modifiedKeys["tuningOctave"]) ||
                childBuilders["tuningOctave"] !== undefined ||
                updates.tuningOctave !== undefined, "tuningOctave is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Accord";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.tuningAlter = (spec) => {
            updates["tuningAlter"] = spec;
            delete childBuilders["tuningAlter;"];
            modifiedKeys["tuningAlter"] = true;
            return this;
        };
        this.string = (spec) => {
            updates["string"] = spec;
            delete childBuilders["string;"];
            modifiedKeys["string"] = true;
            return this;
        };
        this.tuningStep = (spec) => {
            updates["tuningStep"] = spec;
            delete childBuilders["tuningStep;"];
            modifiedKeys["tuningStep"] = true;
            return this;
        };
        this.tuningOctave = (spec) => {
            updates["tuningOctave"] = spec;
            delete childBuilders["tuningOctave;"];
            modifiedKeys["tuningOctave"] = true;
            return this;
        };
    }
}
function patchAccord(base, builder) { return builder(new AccordBuilder(base)).patch(); }
exports.patchAccord = patchAccord;
function buildAccord(builder) { return builder(new AccordBuilder()).build(); }
exports.buildAccord = buildAccord;
class ImageBuilder {
    build;
    patch;
    type;
    source;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    halign;
    valignImage;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["type"]) ||
                childBuilders["type"] !== undefined ||
                updates.type !== undefined, "type is a required field");
            console.assert((original && !modifiedKeys["source"]) ||
                childBuilders["source"] !== undefined ||
                updates.source !== undefined, "source is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Image";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.type = (spec) => {
            updates["type"] = spec;
            delete childBuilders["type;"];
            modifiedKeys["type"] = true;
            return this;
        };
        this.source = (spec) => {
            updates["source"] = spec;
            delete childBuilders["source;"];
            modifiedKeys["source"] = true;
            return this;
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
        this.halign = (spec) => {
            updates["halign"] = spec;
            delete childBuilders["halign;"];
            modifiedKeys["halign"] = true;
            return this;
        };
        this.valignImage = (spec) => {
            updates["valignImage"] = spec;
            delete childBuilders["valignImage;"];
            modifiedKeys["valignImage"] = true;
            return this;
        };
    }
}
function patchImage(base, builder) { return builder(new ImageBuilder(base)).patch(); }
exports.patchImage = patchImage;
function buildImage(builder) { return builder(new ImageBuilder()).build(); }
exports.buildImage = buildImage;
class PrincipalVoiceBuilder {
    build;
    patch;
    symbol;
    data;
    type;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    fontFamily;
    fontWeight;
    fontStyle;
    fontSize;
    color;
    halign;
    valign;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["symbol"]) ||
                childBuilders["symbol"] !== undefined ||
                updates.symbol !== undefined, "symbol is a required field");
            console.assert((original && !modifiedKeys["type"]) ||
                childBuilders["type"] !== undefined ||
                updates.type !== undefined, "type is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "PrincipalVoice";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.symbol = (spec) => {
            updates["symbol"] = spec;
            delete childBuilders["symbol;"];
            modifiedKeys["symbol"] = true;
            return this;
        };
        this.data = (spec) => {
            updates["data"] = spec;
            delete childBuilders["data;"];
            modifiedKeys["data"] = true;
            return this;
        };
        this.type = (spec) => {
            updates["type"] = spec;
            delete childBuilders["type;"];
            modifiedKeys["type"] = true;
            return this;
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
        this.fontFamily = (spec) => {
            updates["fontFamily"] = spec;
            delete childBuilders["fontFamily;"];
            modifiedKeys["fontFamily"] = true;
            return this;
        };
        this.fontWeight = (spec) => {
            updates["fontWeight"] = spec;
            delete childBuilders["fontWeight;"];
            modifiedKeys["fontWeight"] = true;
            return this;
        };
        this.fontStyle = (spec) => {
            updates["fontStyle"] = spec;
            delete childBuilders["fontStyle;"];
            modifiedKeys["fontStyle"] = true;
            return this;
        };
        this.fontSize = (spec) => {
            updates["fontSize"] = spec;
            delete childBuilders["fontSize;"];
            modifiedKeys["fontSize"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
        this.halign = (spec) => {
            updates["halign"] = spec;
            delete childBuilders["halign;"];
            modifiedKeys["halign"] = true;
            return this;
        };
        this.valign = (spec) => {
            updates["valign"] = spec;
            delete childBuilders["valign;"];
            modifiedKeys["valign"] = true;
            return this;
        };
    }
}
function patchPrincipalVoice(base, builder) { return builder(new PrincipalVoiceBuilder(base)).patch(); }
exports.patchPrincipalVoice = patchPrincipalVoice;
function buildPrincipalVoice(builder) { return builder(new PrincipalVoiceBuilder()).build(); }
exports.buildPrincipalVoice = buildPrincipalVoice;
class AccordionRegistrationBuilder {
    build;
    patch;
    accordionMiddle;
    accordionHigh;
    accordionLow;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    fontFamily;
    fontWeight;
    fontStyle;
    fontSize;
    color;
    halign;
    valign;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["accordionMiddle"]) ||
                childBuilders["accordionMiddle"] !== undefined ||
                updates.accordionMiddle !== undefined, "accordionMiddle is a required field");
            console.assert((original && !modifiedKeys["accordionHigh"]) ||
                childBuilders["accordionHigh"] !== undefined ||
                updates.accordionHigh !== undefined, "accordionHigh is a required field");
            console.assert((original && !modifiedKeys["accordionLow"]) ||
                childBuilders["accordionLow"] !== undefined ||
                updates.accordionLow !== undefined, "accordionLow is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "AccordionRegistration";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.accordionMiddle = (spec) => {
            updates["accordionMiddle"] = spec;
            delete childBuilders["accordionMiddle;"];
            modifiedKeys["accordionMiddle"] = true;
            return this;
        };
        this.accordionHigh = (spec) => {
            updates["accordionHigh"] = spec;
            delete childBuilders["accordionHigh;"];
            modifiedKeys["accordionHigh"] = true;
            return this;
        };
        this.accordionLow = (spec) => {
            updates["accordionLow"] = spec;
            delete childBuilders["accordionLow;"];
            modifiedKeys["accordionLow"] = true;
            return this;
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
        this.fontFamily = (spec) => {
            updates["fontFamily"] = spec;
            delete childBuilders["fontFamily;"];
            modifiedKeys["fontFamily"] = true;
            return this;
        };
        this.fontWeight = (spec) => {
            updates["fontWeight"] = spec;
            delete childBuilders["fontWeight;"];
            modifiedKeys["fontWeight"] = true;
            return this;
        };
        this.fontStyle = (spec) => {
            updates["fontStyle"] = spec;
            delete childBuilders["fontStyle;"];
            modifiedKeys["fontStyle"] = true;
            return this;
        };
        this.fontSize = (spec) => {
            updates["fontSize"] = spec;
            delete childBuilders["fontSize;"];
            modifiedKeys["fontSize"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
        this.halign = (spec) => {
            updates["halign"] = spec;
            delete childBuilders["halign;"];
            modifiedKeys["halign"] = true;
            return this;
        };
        this.valign = (spec) => {
            updates["valign"] = spec;
            delete childBuilders["valign;"];
            modifiedKeys["valign"] = true;
            return this;
        };
    }
}
function patchAccordionRegistration(base, builder) { return builder(new AccordionRegistrationBuilder(base)).patch(); }
exports.patchAccordionRegistration = patchAccordionRegistration;
function buildAccordionRegistration(builder) { return builder(new AccordionRegistrationBuilder()).build(); }
exports.buildAccordionRegistration = buildAccordionRegistration;
class PercussionBuilder {
    build;
    patch;
    stickLocation;
    otherPercussion;
    wood;
    effect;
    glass;
    timpani;
    stick;
    metal;
    pitched;
    membrane;
    beater;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    fontFamily;
    fontWeight;
    fontStyle;
    fontSize;
    color;
    halign;
    valign;
    enclosure;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["stickLocation"]) ||
                childBuilders["stickLocation"] !== undefined ||
                updates.stickLocation !== undefined, "stickLocation is a required field");
            console.assert((original && !modifiedKeys["otherPercussion"]) ||
                childBuilders["otherPercussion"] !== undefined ||
                updates.otherPercussion !== undefined, "otherPercussion is a required field");
            console.assert((original && !modifiedKeys["wood"]) ||
                childBuilders["wood"] !== undefined ||
                updates.wood !== undefined, "wood is a required field");
            console.assert((original && !modifiedKeys["effect"]) ||
                childBuilders["effect"] !== undefined ||
                updates.effect !== undefined, "effect is a required field");
            console.assert((original && !modifiedKeys["glass"]) ||
                childBuilders["glass"] !== undefined ||
                updates.glass !== undefined, "glass is a required field");
            console.assert((original && !modifiedKeys["timpani"]) ||
                childBuilders["timpani"] !== undefined ||
                updates.timpani !== undefined, "timpani is a required field");
            console.assert((original && !modifiedKeys["stick"]) ||
                childBuilders["stick"] !== undefined ||
                updates.stick !== undefined, "stick is a required field");
            console.assert((original && !modifiedKeys["metal"]) ||
                childBuilders["metal"] !== undefined ||
                updates.metal !== undefined, "metal is a required field");
            console.assert((original && !modifiedKeys["pitched"]) ||
                childBuilders["pitched"] !== undefined ||
                updates.pitched !== undefined, "pitched is a required field");
            console.assert((original && !modifiedKeys["membrane"]) ||
                childBuilders["membrane"] !== undefined ||
                updates.membrane !== undefined, "membrane is a required field");
            console.assert((original && !modifiedKeys["beater"]) ||
                childBuilders["beater"] !== undefined ||
                updates.beater !== undefined, "beater is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Percussion";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.stickLocation = (spec) => {
            updates["stickLocation"] = spec;
            delete childBuilders["stickLocation;"];
            modifiedKeys["stickLocation"] = true;
            return this;
        };
        this.otherPercussion = (spec) => {
            updates["otherPercussion"] = spec;
            delete childBuilders["otherPercussion;"];
            modifiedKeys["otherPercussion"] = true;
            return this;
        };
        this.wood = (spec) => {
            updates["wood"] = spec;
            delete childBuilders["wood;"];
            modifiedKeys["wood"] = true;
            return this;
        };
        this.effect = (spec) => {
            updates["effect"] = spec;
            delete childBuilders["effect;"];
            modifiedKeys["effect"] = true;
            return this;
        };
        this.glass = (spec) => {
            updates["glass"] = spec;
            delete childBuilders["glass;"];
            modifiedKeys["glass"] = true;
            return this;
        };
        this.timpani = (build) => {
            if (typeof build === 'function') {
                delete updates["timpani"];
                const builder = build(new TimpaniBuilder(original && original["timpani"]));
                if (!original)
                    updates["timpani"] = builder.build();
                else
                    childBuilders["timpani"] = builder;
            }
            else {
                updates.timpani = build;
                delete childBuilders["timpani;"];
            }
            modifiedKeys["timpani"] = true;
            return this;
        };
        this.stick = (build) => {
            if (typeof build === 'function') {
                delete updates["stick"];
                const builder = build(new StickBuilder(original && original["stick"]));
                if (!original)
                    updates["stick"] = builder.build();
                else
                    childBuilders["stick"] = builder;
            }
            else {
                updates.stick = build;
                delete childBuilders["stick;"];
            }
            modifiedKeys["stick"] = true;
            return this;
        };
        this.metal = (spec) => {
            updates["metal"] = spec;
            delete childBuilders["metal;"];
            modifiedKeys["metal"] = true;
            return this;
        };
        this.pitched = (spec) => {
            updates["pitched"] = spec;
            delete childBuilders["pitched;"];
            modifiedKeys["pitched"] = true;
            return this;
        };
        this.membrane = (spec) => {
            updates["membrane"] = spec;
            delete childBuilders["membrane;"];
            modifiedKeys["membrane"] = true;
            return this;
        };
        this.beater = (build) => {
            if (typeof build === 'function') {
                delete updates["beater"];
                const builder = build(new BeaterBuilder(original && original["beater"]));
                if (!original)
                    updates["beater"] = builder.build();
                else
                    childBuilders["beater"] = builder;
            }
            else {
                updates.beater = build;
                delete childBuilders["beater;"];
            }
            modifiedKeys["beater"] = true;
            return this;
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
        this.fontFamily = (spec) => {
            updates["fontFamily"] = spec;
            delete childBuilders["fontFamily;"];
            modifiedKeys["fontFamily"] = true;
            return this;
        };
        this.fontWeight = (spec) => {
            updates["fontWeight"] = spec;
            delete childBuilders["fontWeight;"];
            modifiedKeys["fontWeight"] = true;
            return this;
        };
        this.fontStyle = (spec) => {
            updates["fontStyle"] = spec;
            delete childBuilders["fontStyle;"];
            modifiedKeys["fontStyle"] = true;
            return this;
        };
        this.fontSize = (spec) => {
            updates["fontSize"] = spec;
            delete childBuilders["fontSize;"];
            modifiedKeys["fontSize"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
        this.halign = (spec) => {
            updates["halign"] = spec;
            delete childBuilders["halign;"];
            modifiedKeys["halign"] = true;
            return this;
        };
        this.valign = (spec) => {
            updates["valign"] = spec;
            delete childBuilders["valign;"];
            modifiedKeys["valign"] = true;
            return this;
        };
        this.enclosure = (spec) => {
            updates["enclosure"] = spec;
            delete childBuilders["enclosure;"];
            modifiedKeys["enclosure"] = true;
            return this;
        };
    }
}
function patchPercussion(base, builder) { return builder(new PercussionBuilder(base)).patch(); }
exports.patchPercussion = patchPercussion;
function buildPercussion(builder) { return builder(new PercussionBuilder()).build(); }
exports.buildPercussion = buildPercussion;
class TimpaniBuilder {
    build;
    patch;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Timpani";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
    }
}
function patchTimpani(base, builder) { return builder(new TimpaniBuilder(base)).patch(); }
exports.patchTimpani = patchTimpani;
function buildTimpani(builder) { return builder(new TimpaniBuilder()).build(); }
exports.buildTimpani = buildTimpani;
class BeaterBuilder {
    build;
    patch;
    data;
    tip;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["data"]) ||
                childBuilders["data"] !== undefined ||
                updates.data !== undefined, "data is a required field");
            console.assert((original && !modifiedKeys["tip"]) ||
                childBuilders["tip"] !== undefined ||
                updates.tip !== undefined, "tip is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Beater";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.data = (spec) => {
            updates["data"] = spec;
            delete childBuilders["data;"];
            modifiedKeys["data"] = true;
            return this;
        };
        this.tip = (spec) => {
            updates["tip"] = spec;
            delete childBuilders["tip;"];
            modifiedKeys["tip"] = true;
            return this;
        };
    }
}
function patchBeater(base, builder) { return builder(new BeaterBuilder(base)).patch(); }
exports.patchBeater = patchBeater;
function buildBeater(builder) { return builder(new BeaterBuilder()).build(); }
exports.buildBeater = buildBeater;
class StickBuilder {
    build;
    patch;
    stickMaterial;
    stickType;
    tip;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["stickMaterial"]) ||
                childBuilders["stickMaterial"] !== undefined ||
                updates.stickMaterial !== undefined, "stickMaterial is a required field");
            console.assert((original && !modifiedKeys["stickType"]) ||
                childBuilders["stickType"] !== undefined ||
                updates.stickType !== undefined, "stickType is a required field");
            console.assert((original && !modifiedKeys["tip"]) ||
                childBuilders["tip"] !== undefined ||
                updates.tip !== undefined, "tip is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Stick";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.stickMaterial = (spec) => {
            updates["stickMaterial"] = spec;
            delete childBuilders["stickMaterial;"];
            modifiedKeys["stickMaterial"] = true;
            return this;
        };
        this.stickType = (spec) => {
            updates["stickType"] = spec;
            delete childBuilders["stickType;"];
            modifiedKeys["stickType"] = true;
            return this;
        };
        this.tip = (spec) => {
            updates["tip"] = spec;
            delete childBuilders["tip;"];
            modifiedKeys["tip"] = true;
            return this;
        };
    }
}
function patchStick(base, builder) { return builder(new StickBuilder(base)).patch(); }
exports.patchStick = patchStick;
function buildStick(builder) { return builder(new StickBuilder()).build(); }
exports.buildStick = buildStick;
class OffsetBuilder {
    build;
    patch;
    data;
    sound;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["data"]) ||
                childBuilders["data"] !== undefined ||
                updates.data !== undefined, "data is a required field");
            console.assert((original && !modifiedKeys["sound"]) ||
                childBuilders["sound"] !== undefined ||
                updates.sound !== undefined, "sound is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Offset";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.data = (spec) => {
            updates["data"] = spec;
            delete childBuilders["data;"];
            modifiedKeys["data"] = true;
            return this;
        };
        this.sound = (spec) => {
            updates["sound"] = spec;
            delete childBuilders["sound;"];
            modifiedKeys["sound"] = true;
            return this;
        };
    }
}
function patchOffset(base, builder) { return builder(new OffsetBuilder(base)).patch(); }
exports.patchOffset = patchOffset;
function buildOffset(builder) { return builder(new OffsetBuilder()).build(); }
exports.buildOffset = buildOffset;
class HarmonyChordBuilder {
    build;
    patch;
    root;
    function;
    kind;
    degreesAt;
    degreesSplice;
    degrees;
    inversion;
    bass;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["root"]) ||
                childBuilders["root"] !== undefined ||
                updates.root !== undefined, "root is a required field");
            console.assert((original && !modifiedKeys["function"]) ||
                childBuilders["function"] !== undefined ||
                updates.function !== undefined, "function is a required field");
            console.assert((original && !modifiedKeys["kind"]) ||
                childBuilders["kind"] !== undefined ||
                updates.kind !== undefined, "kind is a required field");
            console.assert((original && !modifiedKeys["degrees"]) ||
                childBuilders["degrees"] !== undefined ||
                updates.degrees !== undefined, "degrees is a required field");
            console.assert((original && !modifiedKeys["inversion"]) ||
                childBuilders["inversion"] !== undefined ||
                updates.inversion !== undefined, "inversion is a required field");
            console.assert((original && !modifiedKeys["bass"]) ||
                childBuilders["bass"] !== undefined ||
                updates.bass !== undefined, "bass is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "HarmonyChord";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.root = (build) => {
            if (typeof build === 'function') {
                delete updates["root"];
                const builder = build(new RootBuilder(original && original["root"]));
                if (!original)
                    updates["root"] = builder.build();
                else
                    childBuilders["root"] = builder;
            }
            else {
                updates.root = build;
                delete childBuilders["root;"];
            }
            modifiedKeys["root"] = true;
            return this;
        };
        this.function = (build) => {
            if (typeof build === 'function') {
                delete updates["function"];
                const builder = build(new FunctionBuilder(original && original["function"]));
                if (!original)
                    updates["function"] = builder.build();
                else
                    childBuilders["function"] = builder;
            }
            else {
                updates.function = build;
                delete childBuilders["function;"];
            }
            modifiedKeys["function"] = true;
            return this;
        };
        this.kind = (build) => {
            if (typeof build === 'function') {
                delete updates["kind"];
                const builder = build(new KindBuilder(original && original["kind"]));
                if (!original)
                    updates["kind"] = builder.build();
                else
                    childBuilders["kind"] = builder;
            }
            else {
                updates.kind = build;
                delete childBuilders["kind;"];
            }
            modifiedKeys["kind"] = true;
            return this;
        };
        this.degrees = (spec) => {
            updates["degrees"] = spec;
            delete childBuilders["degrees;"];
            modifiedKeys["degrees"] = true;
            return this;
        };
        this.degreesAt = (idx, build) => {
            makeReference("degrees");
            if (frozen["degrees"][idx]) {
                throw new Error("Patching degrees." + idx + " twice in a builder is unsupported.");
            }
            if (original && original._snapshot && original._snapshot["degrees"] && original._snapshot["degrees"][idx] && !original["degrees"][idx]) {
                // Clone snapshot.
                patches.push({ p: ["degrees", idx], li: original._snapshot["degrees"] });
            }
            if (typeof build === 'function' && reference["degrees"][idx]) {
                let patch = build(new DegreeBuilder(reference["degrees"][idx])).patch();
                patches = patches.concat(patch.map(patch => {
                    // TODO: detach?
                    patch.p = ["degrees", idx].concat(patch.p);
                    return patch;
                }));
                frozen["degrees"][idx] = true;
                return this;
            }
            let update = typeof build === 'function' ? build(new DegreeBuilder(reference["degrees"][idx])).build() : build;
            if (original) {
                patches.push({ p: ["degrees", idx], li: update });
            }
            else {
                updates["degrees"] = reference["degrees"]; // TODO: Merge?
            }
            reference["degrees"][idx] = update;
            frozen["degrees"][idx] = true;
            return this;
        };
        this.degreesSplice = (start, deleteCount, ...items) => {
            makeReference("degrees");
            let idx = start;
            if (original) {
                for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
                    if (frozen["degrees"][idx]) {
                        throw new Error("Replacing degrees." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["degrees"][idx];
                    patches.push({ p: ["degrees", idx], ld, li: items[idx - start] });
                    frozen["degrees"][idx] = true;
                }
                for (; idx < start + deleteCount; ++idx) {
                    if (frozen["degrees"][idx]) {
                        throw new Error("Removing degrees." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["degrees"][idx];
                    patches.push({ p: ["degrees", idx], ld });
                }
                for (; idx < start + items.length; ++idx) {
                    patches.push({ p: ["degrees", idx], li: items[idx - start] });
                    frozen["degrees"][idx] = true;
                }
            }
            reference["degrees"].splice(start, deleteCount, ...items);
            updates["degrees"] = reference["degrees"];
            frozen["degrees"].splice(start, deleteCount, ...items.map(i => true));
            return this;
        };
        this.inversion = (build) => {
            if (typeof build === 'function') {
                delete updates["inversion"];
                const builder = build(new InversionBuilder(original && original["inversion"]));
                if (!original)
                    updates["inversion"] = builder.build();
                else
                    childBuilders["inversion"] = builder;
            }
            else {
                updates.inversion = build;
                delete childBuilders["inversion;"];
            }
            modifiedKeys["inversion"] = true;
            return this;
        };
        this.bass = (build) => {
            if (typeof build === 'function') {
                delete updates["bass"];
                const builder = build(new BassBuilder(original && original["bass"]));
                if (!original)
                    updates["bass"] = builder.build();
                else
                    childBuilders["bass"] = builder;
            }
            else {
                updates.bass = build;
                delete childBuilders["bass;"];
            }
            modifiedKeys["bass"] = true;
            return this;
        };
    }
}
function patchHarmonyChord(base, builder) { return builder(new HarmonyChordBuilder(base)).patch(); }
exports.patchHarmonyChord = patchHarmonyChord;
function buildHarmonyChord(builder) { return builder(new HarmonyChordBuilder()).build(); }
exports.buildHarmonyChord = buildHarmonyChord;
class HarmonyBuilder {
    build;
    patch;
    frame;
    printFrame;
    staff;
    type;
    offset;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    fontFamily;
    fontWeight;
    fontStyle;
    fontSize;
    color;
    printObject;
    placement;
    footnote;
    level;
    root;
    function;
    kind;
    degreesAt;
    degreesSplice;
    degrees;
    inversion;
    bass;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["frame"]) ||
                childBuilders["frame"] !== undefined ||
                updates.frame !== undefined, "frame is a required field");
            console.assert((original && !modifiedKeys["printFrame"]) ||
                childBuilders["printFrame"] !== undefined ||
                updates.printFrame !== undefined, "printFrame is a required field");
            console.assert((original && !modifiedKeys["staff"]) ||
                childBuilders["staff"] !== undefined ||
                updates.staff !== undefined, "staff is a required field");
            console.assert((original && !modifiedKeys["type"]) ||
                childBuilders["type"] !== undefined ||
                updates.type !== undefined, "type is a required field");
            console.assert((original && !modifiedKeys["offset"]) ||
                childBuilders["offset"] !== undefined ||
                updates.offset !== undefined, "offset is a required field");
            console.assert((original && !modifiedKeys["root"]) ||
                childBuilders["root"] !== undefined ||
                updates.root !== undefined, "root is a required field");
            console.assert((original && !modifiedKeys["function"]) ||
                childBuilders["function"] !== undefined ||
                updates.function !== undefined, "function is a required field");
            console.assert((original && !modifiedKeys["kind"]) ||
                childBuilders["kind"] !== undefined ||
                updates.kind !== undefined, "kind is a required field");
            console.assert((original && !modifiedKeys["degrees"]) ||
                childBuilders["degrees"] !== undefined ||
                updates.degrees !== undefined, "degrees is a required field");
            console.assert((original && !modifiedKeys["inversion"]) ||
                childBuilders["inversion"] !== undefined ||
                updates.inversion !== undefined, "inversion is a required field");
            console.assert((original && !modifiedKeys["bass"]) ||
                childBuilders["bass"] !== undefined ||
                updates.bass !== undefined, "bass is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Harmony";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.frame = (build) => {
            if (typeof build === 'function') {
                delete updates["frame"];
                const builder = build(new FrameBuilder(original && original["frame"]));
                if (!original)
                    updates["frame"] = builder.build();
                else
                    childBuilders["frame"] = builder;
            }
            else {
                updates.frame = build;
                delete childBuilders["frame;"];
            }
            modifiedKeys["frame"] = true;
            return this;
        };
        this.printFrame = (spec) => {
            updates["printFrame"] = spec;
            delete childBuilders["printFrame;"];
            modifiedKeys["printFrame"] = true;
            return this;
        };
        this.staff = (spec) => {
            updates["staff"] = spec;
            delete childBuilders["staff;"];
            modifiedKeys["staff"] = true;
            return this;
        };
        this.type = (spec) => {
            updates["type"] = spec;
            delete childBuilders["type;"];
            modifiedKeys["type"] = true;
            return this;
        };
        this.offset = (build) => {
            if (typeof build === 'function') {
                delete updates["offset"];
                const builder = build(new OffsetBuilder(original && original["offset"]));
                if (!original)
                    updates["offset"] = builder.build();
                else
                    childBuilders["offset"] = builder;
            }
            else {
                updates.offset = build;
                delete childBuilders["offset;"];
            }
            modifiedKeys["offset"] = true;
            return this;
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
        this.fontFamily = (spec) => {
            updates["fontFamily"] = spec;
            delete childBuilders["fontFamily;"];
            modifiedKeys["fontFamily"] = true;
            return this;
        };
        this.fontWeight = (spec) => {
            updates["fontWeight"] = spec;
            delete childBuilders["fontWeight;"];
            modifiedKeys["fontWeight"] = true;
            return this;
        };
        this.fontStyle = (spec) => {
            updates["fontStyle"] = spec;
            delete childBuilders["fontStyle;"];
            modifiedKeys["fontStyle"] = true;
            return this;
        };
        this.fontSize = (spec) => {
            updates["fontSize"] = spec;
            delete childBuilders["fontSize;"];
            modifiedKeys["fontSize"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
        this.printObject = (spec) => {
            updates["printObject"] = spec;
            delete childBuilders["printObject;"];
            modifiedKeys["printObject"] = true;
            return this;
        };
        this.placement = (spec) => {
            updates["placement"] = spec;
            delete childBuilders["placement;"];
            modifiedKeys["placement"] = true;
            return this;
        };
        this.footnote = (build) => {
            if (typeof build === 'function') {
                delete updates["footnote"];
                const builder = build(new FootnoteBuilder(original && original["footnote"]));
                if (!original)
                    updates["footnote"] = builder.build();
                else
                    childBuilders["footnote"] = builder;
            }
            else {
                updates.footnote = build;
                delete childBuilders["footnote;"];
            }
            modifiedKeys["footnote"] = true;
            return this;
        };
        this.level = (build) => {
            if (typeof build === 'function') {
                delete updates["level"];
                const builder = build(new LevelBuilder(original && original["level"]));
                if (!original)
                    updates["level"] = builder.build();
                else
                    childBuilders["level"] = builder;
            }
            else {
                updates.level = build;
                delete childBuilders["level;"];
            }
            modifiedKeys["level"] = true;
            return this;
        };
        this.root = (build) => {
            if (typeof build === 'function') {
                delete updates["root"];
                const builder = build(new RootBuilder(original && original["root"]));
                if (!original)
                    updates["root"] = builder.build();
                else
                    childBuilders["root"] = builder;
            }
            else {
                updates.root = build;
                delete childBuilders["root;"];
            }
            modifiedKeys["root"] = true;
            return this;
        };
        this.function = (build) => {
            if (typeof build === 'function') {
                delete updates["function"];
                const builder = build(new FunctionBuilder(original && original["function"]));
                if (!original)
                    updates["function"] = builder.build();
                else
                    childBuilders["function"] = builder;
            }
            else {
                updates.function = build;
                delete childBuilders["function;"];
            }
            modifiedKeys["function"] = true;
            return this;
        };
        this.kind = (build) => {
            if (typeof build === 'function') {
                delete updates["kind"];
                const builder = build(new KindBuilder(original && original["kind"]));
                if (!original)
                    updates["kind"] = builder.build();
                else
                    childBuilders["kind"] = builder;
            }
            else {
                updates.kind = build;
                delete childBuilders["kind;"];
            }
            modifiedKeys["kind"] = true;
            return this;
        };
        this.degrees = (spec) => {
            updates["degrees"] = spec;
            delete childBuilders["degrees;"];
            modifiedKeys["degrees"] = true;
            return this;
        };
        this.degreesAt = (idx, build) => {
            makeReference("degrees");
            if (frozen["degrees"][idx]) {
                throw new Error("Patching degrees." + idx + " twice in a builder is unsupported.");
            }
            if (original && original._snapshot && original._snapshot["degrees"] && original._snapshot["degrees"][idx] && !original["degrees"][idx]) {
                // Clone snapshot.
                patches.push({ p: ["degrees", idx], li: original._snapshot["degrees"] });
            }
            if (typeof build === 'function' && reference["degrees"][idx]) {
                let patch = build(new DegreeBuilder(reference["degrees"][idx])).patch();
                patches = patches.concat(patch.map(patch => {
                    // TODO: detach?
                    patch.p = ["degrees", idx].concat(patch.p);
                    return patch;
                }));
                frozen["degrees"][idx] = true;
                return this;
            }
            let update = typeof build === 'function' ? build(new DegreeBuilder(reference["degrees"][idx])).build() : build;
            if (original) {
                patches.push({ p: ["degrees", idx], li: update });
            }
            else {
                updates["degrees"] = reference["degrees"]; // TODO: Merge?
            }
            reference["degrees"][idx] = update;
            frozen["degrees"][idx] = true;
            return this;
        };
        this.degreesSplice = (start, deleteCount, ...items) => {
            makeReference("degrees");
            let idx = start;
            if (original) {
                for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
                    if (frozen["degrees"][idx]) {
                        throw new Error("Replacing degrees." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["degrees"][idx];
                    patches.push({ p: ["degrees", idx], ld, li: items[idx - start] });
                    frozen["degrees"][idx] = true;
                }
                for (; idx < start + deleteCount; ++idx) {
                    if (frozen["degrees"][idx]) {
                        throw new Error("Removing degrees." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["degrees"][idx];
                    patches.push({ p: ["degrees", idx], ld });
                }
                for (; idx < start + items.length; ++idx) {
                    patches.push({ p: ["degrees", idx], li: items[idx - start] });
                    frozen["degrees"][idx] = true;
                }
            }
            reference["degrees"].splice(start, deleteCount, ...items);
            updates["degrees"] = reference["degrees"];
            frozen["degrees"].splice(start, deleteCount, ...items.map(i => true));
            return this;
        };
        this.inversion = (build) => {
            if (typeof build === 'function') {
                delete updates["inversion"];
                const builder = build(new InversionBuilder(original && original["inversion"]));
                if (!original)
                    updates["inversion"] = builder.build();
                else
                    childBuilders["inversion"] = builder;
            }
            else {
                updates.inversion = build;
                delete childBuilders["inversion;"];
            }
            modifiedKeys["inversion"] = true;
            return this;
        };
        this.bass = (build) => {
            if (typeof build === 'function') {
                delete updates["bass"];
                const builder = build(new BassBuilder(original && original["bass"]));
                if (!original)
                    updates["bass"] = builder.build();
                else
                    childBuilders["bass"] = builder;
            }
            else {
                updates.bass = build;
                delete childBuilders["bass;"];
            }
            modifiedKeys["bass"] = true;
            return this;
        };
    }
}
function patchHarmony(base, builder) { return builder(new HarmonyBuilder(base)).patch(); }
exports.patchHarmony = patchHarmony;
function buildHarmony(builder) { return builder(new HarmonyBuilder()).build(); }
exports.buildHarmony = buildHarmony;
class RootBuilder {
    build;
    patch;
    rootStep;
    rootAlter;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["rootStep"]) ||
                childBuilders["rootStep"] !== undefined ||
                updates.rootStep !== undefined, "rootStep is a required field");
            console.assert((original && !modifiedKeys["rootAlter"]) ||
                childBuilders["rootAlter"] !== undefined ||
                updates.rootAlter !== undefined, "rootAlter is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Root";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.rootStep = (build) => {
            if (typeof build === 'function') {
                delete updates["rootStep"];
                const builder = build(new RootStepBuilder(original && original["rootStep"]));
                if (!original)
                    updates["rootStep"] = builder.build();
                else
                    childBuilders["rootStep"] = builder;
            }
            else {
                updates.rootStep = build;
                delete childBuilders["rootStep;"];
            }
            modifiedKeys["rootStep"] = true;
            return this;
        };
        this.rootAlter = (build) => {
            if (typeof build === 'function') {
                delete updates["rootAlter"];
                const builder = build(new RootAlterBuilder(original && original["rootAlter"]));
                if (!original)
                    updates["rootAlter"] = builder.build();
                else
                    childBuilders["rootAlter"] = builder;
            }
            else {
                updates.rootAlter = build;
                delete childBuilders["rootAlter;"];
            }
            modifiedKeys["rootAlter"] = true;
            return this;
        };
    }
}
function patchRoot(base, builder) { return builder(new RootBuilder(base)).patch(); }
exports.patchRoot = patchRoot;
function buildRoot(builder) { return builder(new RootBuilder()).build(); }
exports.buildRoot = buildRoot;
class RootStepBuilder {
    build;
    patch;
    text;
    data;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    fontFamily;
    fontWeight;
    fontStyle;
    fontSize;
    color;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["text"]) ||
                childBuilders["text"] !== undefined ||
                updates.text !== undefined, "text is a required field");
            console.assert((original && !modifiedKeys["data"]) ||
                childBuilders["data"] !== undefined ||
                updates.data !== undefined, "data is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "RootStep";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.text = (spec) => {
            updates["text"] = spec;
            delete childBuilders["text;"];
            modifiedKeys["text"] = true;
            return this;
        };
        this.data = (spec) => {
            updates["data"] = spec;
            delete childBuilders["data;"];
            modifiedKeys["data"] = true;
            return this;
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
        this.fontFamily = (spec) => {
            updates["fontFamily"] = spec;
            delete childBuilders["fontFamily;"];
            modifiedKeys["fontFamily"] = true;
            return this;
        };
        this.fontWeight = (spec) => {
            updates["fontWeight"] = spec;
            delete childBuilders["fontWeight;"];
            modifiedKeys["fontWeight"] = true;
            return this;
        };
        this.fontStyle = (spec) => {
            updates["fontStyle"] = spec;
            delete childBuilders["fontStyle;"];
            modifiedKeys["fontStyle"] = true;
            return this;
        };
        this.fontSize = (spec) => {
            updates["fontSize"] = spec;
            delete childBuilders["fontSize;"];
            modifiedKeys["fontSize"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
    }
}
function patchRootStep(base, builder) { return builder(new RootStepBuilder(base)).patch(); }
exports.patchRootStep = patchRootStep;
function buildRootStep(builder) { return builder(new RootStepBuilder()).build(); }
exports.buildRootStep = buildRootStep;
class RootAlterBuilder {
    build;
    patch;
    location;
    data;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    fontFamily;
    fontWeight;
    fontStyle;
    fontSize;
    color;
    printObject;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["location"]) ||
                childBuilders["location"] !== undefined ||
                updates.location !== undefined, "location is a required field");
            console.assert((original && !modifiedKeys["data"]) ||
                childBuilders["data"] !== undefined ||
                updates.data !== undefined, "data is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "RootAlter";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.location = (spec) => {
            updates["location"] = spec;
            delete childBuilders["location;"];
            modifiedKeys["location"] = true;
            return this;
        };
        this.data = (spec) => {
            updates["data"] = spec;
            delete childBuilders["data;"];
            modifiedKeys["data"] = true;
            return this;
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
        this.fontFamily = (spec) => {
            updates["fontFamily"] = spec;
            delete childBuilders["fontFamily;"];
            modifiedKeys["fontFamily"] = true;
            return this;
        };
        this.fontWeight = (spec) => {
            updates["fontWeight"] = spec;
            delete childBuilders["fontWeight;"];
            modifiedKeys["fontWeight"] = true;
            return this;
        };
        this.fontStyle = (spec) => {
            updates["fontStyle"] = spec;
            delete childBuilders["fontStyle;"];
            modifiedKeys["fontStyle"] = true;
            return this;
        };
        this.fontSize = (spec) => {
            updates["fontSize"] = spec;
            delete childBuilders["fontSize;"];
            modifiedKeys["fontSize"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
        this.printObject = (spec) => {
            updates["printObject"] = spec;
            delete childBuilders["printObject;"];
            modifiedKeys["printObject"] = true;
            return this;
        };
    }
}
function patchRootAlter(base, builder) { return builder(new RootAlterBuilder(base)).patch(); }
exports.patchRootAlter = patchRootAlter;
function buildRootAlter(builder) { return builder(new RootAlterBuilder()).build(); }
exports.buildRootAlter = buildRootAlter;
class FunctionBuilder {
    build;
    patch;
    data;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    fontFamily;
    fontWeight;
    fontStyle;
    fontSize;
    color;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["data"]) ||
                childBuilders["data"] !== undefined ||
                updates.data !== undefined, "data is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Function";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.data = (spec) => {
            updates["data"] = spec;
            delete childBuilders["data;"];
            modifiedKeys["data"] = true;
            return this;
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
        this.fontFamily = (spec) => {
            updates["fontFamily"] = spec;
            delete childBuilders["fontFamily;"];
            modifiedKeys["fontFamily"] = true;
            return this;
        };
        this.fontWeight = (spec) => {
            updates["fontWeight"] = spec;
            delete childBuilders["fontWeight;"];
            modifiedKeys["fontWeight"] = true;
            return this;
        };
        this.fontStyle = (spec) => {
            updates["fontStyle"] = spec;
            delete childBuilders["fontStyle;"];
            modifiedKeys["fontStyle"] = true;
            return this;
        };
        this.fontSize = (spec) => {
            updates["fontSize"] = spec;
            delete childBuilders["fontSize;"];
            modifiedKeys["fontSize"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
    }
}
function patchFunction(base, builder) { return builder(new FunctionBuilder(base)).patch(); }
exports.patchFunction = patchFunction;
function buildFunction(builder) { return builder(new FunctionBuilder()).build(); }
exports.buildFunction = buildFunction;
class KindBuilder {
    build;
    patch;
    parenthesesDegrees;
    useSymbols;
    text;
    data;
    stackDegrees;
    bracketDegrees;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    fontFamily;
    fontWeight;
    fontStyle;
    fontSize;
    color;
    halign;
    valign;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["parenthesesDegrees"]) ||
                childBuilders["parenthesesDegrees"] !== undefined ||
                updates.parenthesesDegrees !== undefined, "parenthesesDegrees is a required field");
            console.assert((original && !modifiedKeys["useSymbols"]) ||
                childBuilders["useSymbols"] !== undefined ||
                updates.useSymbols !== undefined, "useSymbols is a required field");
            console.assert((original && !modifiedKeys["text"]) ||
                childBuilders["text"] !== undefined ||
                updates.text !== undefined, "text is a required field");
            console.assert((original && !modifiedKeys["data"]) ||
                childBuilders["data"] !== undefined ||
                updates.data !== undefined, "data is a required field");
            console.assert((original && !modifiedKeys["stackDegrees"]) ||
                childBuilders["stackDegrees"] !== undefined ||
                updates.stackDegrees !== undefined, "stackDegrees is a required field");
            console.assert((original && !modifiedKeys["bracketDegrees"]) ||
                childBuilders["bracketDegrees"] !== undefined ||
                updates.bracketDegrees !== undefined, "bracketDegrees is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Kind";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.parenthesesDegrees = (spec) => {
            updates["parenthesesDegrees"] = spec;
            delete childBuilders["parenthesesDegrees;"];
            modifiedKeys["parenthesesDegrees"] = true;
            return this;
        };
        this.useSymbols = (spec) => {
            updates["useSymbols"] = spec;
            delete childBuilders["useSymbols;"];
            modifiedKeys["useSymbols"] = true;
            return this;
        };
        this.text = (spec) => {
            updates["text"] = spec;
            delete childBuilders["text;"];
            modifiedKeys["text"] = true;
            return this;
        };
        this.data = (spec) => {
            updates["data"] = spec;
            delete childBuilders["data;"];
            modifiedKeys["data"] = true;
            return this;
        };
        this.stackDegrees = (spec) => {
            updates["stackDegrees"] = spec;
            delete childBuilders["stackDegrees;"];
            modifiedKeys["stackDegrees"] = true;
            return this;
        };
        this.bracketDegrees = (spec) => {
            updates["bracketDegrees"] = spec;
            delete childBuilders["bracketDegrees;"];
            modifiedKeys["bracketDegrees"] = true;
            return this;
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
        this.fontFamily = (spec) => {
            updates["fontFamily"] = spec;
            delete childBuilders["fontFamily;"];
            modifiedKeys["fontFamily"] = true;
            return this;
        };
        this.fontWeight = (spec) => {
            updates["fontWeight"] = spec;
            delete childBuilders["fontWeight;"];
            modifiedKeys["fontWeight"] = true;
            return this;
        };
        this.fontStyle = (spec) => {
            updates["fontStyle"] = spec;
            delete childBuilders["fontStyle;"];
            modifiedKeys["fontStyle"] = true;
            return this;
        };
        this.fontSize = (spec) => {
            updates["fontSize"] = spec;
            delete childBuilders["fontSize;"];
            modifiedKeys["fontSize"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
        this.halign = (spec) => {
            updates["halign"] = spec;
            delete childBuilders["halign;"];
            modifiedKeys["halign"] = true;
            return this;
        };
        this.valign = (spec) => {
            updates["valign"] = spec;
            delete childBuilders["valign;"];
            modifiedKeys["valign"] = true;
            return this;
        };
    }
}
function patchKind(base, builder) { return builder(new KindBuilder(base)).patch(); }
exports.patchKind = patchKind;
function buildKind(builder) { return builder(new KindBuilder()).build(); }
exports.buildKind = buildKind;
class InversionBuilder {
    build;
    patch;
    data;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    fontFamily;
    fontWeight;
    fontStyle;
    fontSize;
    color;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["data"]) ||
                childBuilders["data"] !== undefined ||
                updates.data !== undefined, "data is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Inversion";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.data = (spec) => {
            updates["data"] = spec;
            delete childBuilders["data;"];
            modifiedKeys["data"] = true;
            return this;
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
        this.fontFamily = (spec) => {
            updates["fontFamily"] = spec;
            delete childBuilders["fontFamily;"];
            modifiedKeys["fontFamily"] = true;
            return this;
        };
        this.fontWeight = (spec) => {
            updates["fontWeight"] = spec;
            delete childBuilders["fontWeight;"];
            modifiedKeys["fontWeight"] = true;
            return this;
        };
        this.fontStyle = (spec) => {
            updates["fontStyle"] = spec;
            delete childBuilders["fontStyle;"];
            modifiedKeys["fontStyle"] = true;
            return this;
        };
        this.fontSize = (spec) => {
            updates["fontSize"] = spec;
            delete childBuilders["fontSize;"];
            modifiedKeys["fontSize"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
    }
}
function patchInversion(base, builder) { return builder(new InversionBuilder(base)).patch(); }
exports.patchInversion = patchInversion;
function buildInversion(builder) { return builder(new InversionBuilder()).build(); }
exports.buildInversion = buildInversion;
class BassBuilder {
    build;
    patch;
    bassStep;
    bassAlter;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["bassStep"]) ||
                childBuilders["bassStep"] !== undefined ||
                updates.bassStep !== undefined, "bassStep is a required field");
            console.assert((original && !modifiedKeys["bassAlter"]) ||
                childBuilders["bassAlter"] !== undefined ||
                updates.bassAlter !== undefined, "bassAlter is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Bass";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.bassStep = (build) => {
            if (typeof build === 'function') {
                delete updates["bassStep"];
                const builder = build(new BassStepBuilder(original && original["bassStep"]));
                if (!original)
                    updates["bassStep"] = builder.build();
                else
                    childBuilders["bassStep"] = builder;
            }
            else {
                updates.bassStep = build;
                delete childBuilders["bassStep;"];
            }
            modifiedKeys["bassStep"] = true;
            return this;
        };
        this.bassAlter = (build) => {
            if (typeof build === 'function') {
                delete updates["bassAlter"];
                const builder = build(new BassAlterBuilder(original && original["bassAlter"]));
                if (!original)
                    updates["bassAlter"] = builder.build();
                else
                    childBuilders["bassAlter"] = builder;
            }
            else {
                updates.bassAlter = build;
                delete childBuilders["bassAlter;"];
            }
            modifiedKeys["bassAlter"] = true;
            return this;
        };
    }
}
function patchBass(base, builder) { return builder(new BassBuilder(base)).patch(); }
exports.patchBass = patchBass;
function buildBass(builder) { return builder(new BassBuilder()).build(); }
exports.buildBass = buildBass;
class BassStepBuilder {
    build;
    patch;
    text;
    data;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    fontFamily;
    fontWeight;
    fontStyle;
    fontSize;
    color;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["text"]) ||
                childBuilders["text"] !== undefined ||
                updates.text !== undefined, "text is a required field");
            console.assert((original && !modifiedKeys["data"]) ||
                childBuilders["data"] !== undefined ||
                updates.data !== undefined, "data is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "BassStep";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.text = (spec) => {
            updates["text"] = spec;
            delete childBuilders["text;"];
            modifiedKeys["text"] = true;
            return this;
        };
        this.data = (spec) => {
            updates["data"] = spec;
            delete childBuilders["data;"];
            modifiedKeys["data"] = true;
            return this;
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
        this.fontFamily = (spec) => {
            updates["fontFamily"] = spec;
            delete childBuilders["fontFamily;"];
            modifiedKeys["fontFamily"] = true;
            return this;
        };
        this.fontWeight = (spec) => {
            updates["fontWeight"] = spec;
            delete childBuilders["fontWeight;"];
            modifiedKeys["fontWeight"] = true;
            return this;
        };
        this.fontStyle = (spec) => {
            updates["fontStyle"] = spec;
            delete childBuilders["fontStyle;"];
            modifiedKeys["fontStyle"] = true;
            return this;
        };
        this.fontSize = (spec) => {
            updates["fontSize"] = spec;
            delete childBuilders["fontSize;"];
            modifiedKeys["fontSize"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
    }
}
function patchBassStep(base, builder) { return builder(new BassStepBuilder(base)).patch(); }
exports.patchBassStep = patchBassStep;
function buildBassStep(builder) { return builder(new BassStepBuilder()).build(); }
exports.buildBassStep = buildBassStep;
class BassAlterBuilder {
    build;
    patch;
    location;
    data;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    fontFamily;
    fontWeight;
    fontStyle;
    fontSize;
    color;
    printObject;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["location"]) ||
                childBuilders["location"] !== undefined ||
                updates.location !== undefined, "location is a required field");
            console.assert((original && !modifiedKeys["data"]) ||
                childBuilders["data"] !== undefined ||
                updates.data !== undefined, "data is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "BassAlter";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.location = (spec) => {
            updates["location"] = spec;
            delete childBuilders["location;"];
            modifiedKeys["location"] = true;
            return this;
        };
        this.data = (spec) => {
            updates["data"] = spec;
            delete childBuilders["data;"];
            modifiedKeys["data"] = true;
            return this;
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
        this.fontFamily = (spec) => {
            updates["fontFamily"] = spec;
            delete childBuilders["fontFamily;"];
            modifiedKeys["fontFamily"] = true;
            return this;
        };
        this.fontWeight = (spec) => {
            updates["fontWeight"] = spec;
            delete childBuilders["fontWeight;"];
            modifiedKeys["fontWeight"] = true;
            return this;
        };
        this.fontStyle = (spec) => {
            updates["fontStyle"] = spec;
            delete childBuilders["fontStyle;"];
            modifiedKeys["fontStyle"] = true;
            return this;
        };
        this.fontSize = (spec) => {
            updates["fontSize"] = spec;
            delete childBuilders["fontSize;"];
            modifiedKeys["fontSize"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
        this.printObject = (spec) => {
            updates["printObject"] = spec;
            delete childBuilders["printObject;"];
            modifiedKeys["printObject"] = true;
            return this;
        };
    }
}
function patchBassAlter(base, builder) { return builder(new BassAlterBuilder(base)).patch(); }
exports.patchBassAlter = patchBassAlter;
function buildBassAlter(builder) { return builder(new BassAlterBuilder()).build(); }
exports.buildBassAlter = buildBassAlter;
class DegreeBuilder {
    build;
    patch;
    degreeAlter;
    degreeValue;
    degreeType;
    printObject;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["degreeAlter"]) ||
                childBuilders["degreeAlter"] !== undefined ||
                updates.degreeAlter !== undefined, "degreeAlter is a required field");
            console.assert((original && !modifiedKeys["degreeValue"]) ||
                childBuilders["degreeValue"] !== undefined ||
                updates.degreeValue !== undefined, "degreeValue is a required field");
            console.assert((original && !modifiedKeys["degreeType"]) ||
                childBuilders["degreeType"] !== undefined ||
                updates.degreeType !== undefined, "degreeType is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Degree";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.degreeAlter = (build) => {
            if (typeof build === 'function') {
                delete updates["degreeAlter"];
                const builder = build(new DegreeAlterBuilder(original && original["degreeAlter"]));
                if (!original)
                    updates["degreeAlter"] = builder.build();
                else
                    childBuilders["degreeAlter"] = builder;
            }
            else {
                updates.degreeAlter = build;
                delete childBuilders["degreeAlter;"];
            }
            modifiedKeys["degreeAlter"] = true;
            return this;
        };
        this.degreeValue = (build) => {
            if (typeof build === 'function') {
                delete updates["degreeValue"];
                const builder = build(new DegreeValueBuilder(original && original["degreeValue"]));
                if (!original)
                    updates["degreeValue"] = builder.build();
                else
                    childBuilders["degreeValue"] = builder;
            }
            else {
                updates.degreeValue = build;
                delete childBuilders["degreeValue;"];
            }
            modifiedKeys["degreeValue"] = true;
            return this;
        };
        this.degreeType = (build) => {
            if (typeof build === 'function') {
                delete updates["degreeType"];
                const builder = build(new DegreeTypeBuilder(original && original["degreeType"]));
                if (!original)
                    updates["degreeType"] = builder.build();
                else
                    childBuilders["degreeType"] = builder;
            }
            else {
                updates.degreeType = build;
                delete childBuilders["degreeType;"];
            }
            modifiedKeys["degreeType"] = true;
            return this;
        };
        this.printObject = (spec) => {
            updates["printObject"] = spec;
            delete childBuilders["printObject;"];
            modifiedKeys["printObject"] = true;
            return this;
        };
    }
}
function patchDegree(base, builder) { return builder(new DegreeBuilder(base)).patch(); }
exports.patchDegree = patchDegree;
function buildDegree(builder) { return builder(new DegreeBuilder()).build(); }
exports.buildDegree = buildDegree;
class DegreeValueBuilder {
    build;
    patch;
    symbol;
    text;
    data;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    fontFamily;
    fontWeight;
    fontStyle;
    fontSize;
    color;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["symbol"]) ||
                childBuilders["symbol"] !== undefined ||
                updates.symbol !== undefined, "symbol is a required field");
            console.assert((original && !modifiedKeys["text"]) ||
                childBuilders["text"] !== undefined ||
                updates.text !== undefined, "text is a required field");
            console.assert((original && !modifiedKeys["data"]) ||
                childBuilders["data"] !== undefined ||
                updates.data !== undefined, "data is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "DegreeValue";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.symbol = (spec) => {
            updates["symbol"] = spec;
            delete childBuilders["symbol;"];
            modifiedKeys["symbol"] = true;
            return this;
        };
        this.text = (spec) => {
            updates["text"] = spec;
            delete childBuilders["text;"];
            modifiedKeys["text"] = true;
            return this;
        };
        this.data = (spec) => {
            updates["data"] = spec;
            delete childBuilders["data;"];
            modifiedKeys["data"] = true;
            return this;
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
        this.fontFamily = (spec) => {
            updates["fontFamily"] = spec;
            delete childBuilders["fontFamily;"];
            modifiedKeys["fontFamily"] = true;
            return this;
        };
        this.fontWeight = (spec) => {
            updates["fontWeight"] = spec;
            delete childBuilders["fontWeight;"];
            modifiedKeys["fontWeight"] = true;
            return this;
        };
        this.fontStyle = (spec) => {
            updates["fontStyle"] = spec;
            delete childBuilders["fontStyle;"];
            modifiedKeys["fontStyle"] = true;
            return this;
        };
        this.fontSize = (spec) => {
            updates["fontSize"] = spec;
            delete childBuilders["fontSize;"];
            modifiedKeys["fontSize"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
    }
}
function patchDegreeValue(base, builder) { return builder(new DegreeValueBuilder(base)).patch(); }
exports.patchDegreeValue = patchDegreeValue;
function buildDegreeValue(builder) { return builder(new DegreeValueBuilder()).build(); }
exports.buildDegreeValue = buildDegreeValue;
class DegreeAlterBuilder {
    build;
    patch;
    plusMinus;
    data;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    fontFamily;
    fontWeight;
    fontStyle;
    fontSize;
    color;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["plusMinus"]) ||
                childBuilders["plusMinus"] !== undefined ||
                updates.plusMinus !== undefined, "plusMinus is a required field");
            console.assert((original && !modifiedKeys["data"]) ||
                childBuilders["data"] !== undefined ||
                updates.data !== undefined, "data is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "DegreeAlter";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.plusMinus = (spec) => {
            updates["plusMinus"] = spec;
            delete childBuilders["plusMinus;"];
            modifiedKeys["plusMinus"] = true;
            return this;
        };
        this.data = (spec) => {
            updates["data"] = spec;
            delete childBuilders["data;"];
            modifiedKeys["data"] = true;
            return this;
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
        this.fontFamily = (spec) => {
            updates["fontFamily"] = spec;
            delete childBuilders["fontFamily;"];
            modifiedKeys["fontFamily"] = true;
            return this;
        };
        this.fontWeight = (spec) => {
            updates["fontWeight"] = spec;
            delete childBuilders["fontWeight;"];
            modifiedKeys["fontWeight"] = true;
            return this;
        };
        this.fontStyle = (spec) => {
            updates["fontStyle"] = spec;
            delete childBuilders["fontStyle;"];
            modifiedKeys["fontStyle"] = true;
            return this;
        };
        this.fontSize = (spec) => {
            updates["fontSize"] = spec;
            delete childBuilders["fontSize;"];
            modifiedKeys["fontSize"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
    }
}
function patchDegreeAlter(base, builder) { return builder(new DegreeAlterBuilder(base)).patch(); }
exports.patchDegreeAlter = patchDegreeAlter;
function buildDegreeAlter(builder) { return builder(new DegreeAlterBuilder()).build(); }
exports.buildDegreeAlter = buildDegreeAlter;
class DegreeTypeBuilder {
    build;
    patch;
    text;
    data;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    fontFamily;
    fontWeight;
    fontStyle;
    fontSize;
    color;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["text"]) ||
                childBuilders["text"] !== undefined ||
                updates.text !== undefined, "text is a required field");
            console.assert((original && !modifiedKeys["data"]) ||
                childBuilders["data"] !== undefined ||
                updates.data !== undefined, "data is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "DegreeType";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.text = (spec) => {
            updates["text"] = spec;
            delete childBuilders["text;"];
            modifiedKeys["text"] = true;
            return this;
        };
        this.data = (spec) => {
            updates["data"] = spec;
            delete childBuilders["data;"];
            modifiedKeys["data"] = true;
            return this;
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
        this.fontFamily = (spec) => {
            updates["fontFamily"] = spec;
            delete childBuilders["fontFamily;"];
            modifiedKeys["fontFamily"] = true;
            return this;
        };
        this.fontWeight = (spec) => {
            updates["fontWeight"] = spec;
            delete childBuilders["fontWeight;"];
            modifiedKeys["fontWeight"] = true;
            return this;
        };
        this.fontStyle = (spec) => {
            updates["fontStyle"] = spec;
            delete childBuilders["fontStyle;"];
            modifiedKeys["fontStyle"] = true;
            return this;
        };
        this.fontSize = (spec) => {
            updates["fontSize"] = spec;
            delete childBuilders["fontSize;"];
            modifiedKeys["fontSize"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
    }
}
function patchDegreeType(base, builder) { return builder(new DegreeTypeBuilder(base)).patch(); }
exports.patchDegreeType = patchDegreeType;
function buildDegreeType(builder) { return builder(new DegreeTypeBuilder()).build(); }
exports.buildDegreeType = buildDegreeType;
class FrameBuilder {
    build;
    patch;
    frameStrings;
    frameNotesAt;
    frameNotesSplice;
    frameNotes;
    unplayed;
    frameFrets;
    firstFret;
    width;
    height;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    color;
    halign;
    valignImage;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["frameStrings"]) ||
                childBuilders["frameStrings"] !== undefined ||
                updates.frameStrings !== undefined, "frameStrings is a required field");
            console.assert((original && !modifiedKeys["frameNotes"]) ||
                childBuilders["frameNotes"] !== undefined ||
                updates.frameNotes !== undefined, "frameNotes is a required field");
            console.assert((original && !modifiedKeys["unplayed"]) ||
                childBuilders["unplayed"] !== undefined ||
                updates.unplayed !== undefined, "unplayed is a required field");
            console.assert((original && !modifiedKeys["frameFrets"]) ||
                childBuilders["frameFrets"] !== undefined ||
                updates.frameFrets !== undefined, "frameFrets is a required field");
            console.assert((original && !modifiedKeys["firstFret"]) ||
                childBuilders["firstFret"] !== undefined ||
                updates.firstFret !== undefined, "firstFret is a required field");
            console.assert((original && !modifiedKeys["width"]) ||
                childBuilders["width"] !== undefined ||
                updates.width !== undefined, "width is a required field");
            console.assert((original && !modifiedKeys["height"]) ||
                childBuilders["height"] !== undefined ||
                updates.height !== undefined, "height is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Frame";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.frameStrings = (spec) => {
            updates["frameStrings"] = spec;
            delete childBuilders["frameStrings;"];
            modifiedKeys["frameStrings"] = true;
            return this;
        };
        this.frameNotes = (spec) => {
            updates["frameNotes"] = spec;
            delete childBuilders["frameNotes;"];
            modifiedKeys["frameNotes"] = true;
            return this;
        };
        this.frameNotesAt = (idx, build) => {
            makeReference("frameNotes");
            if (frozen["frameNotes"][idx]) {
                throw new Error("Patching frameNotes." + idx + " twice in a builder is unsupported.");
            }
            if (original && original._snapshot && original._snapshot["frameNotes"] && original._snapshot["frameNotes"][idx] && !original["frameNotes"][idx]) {
                // Clone snapshot.
                patches.push({ p: ["frameNotes", idx], li: original._snapshot["frameNotes"] });
            }
            if (typeof build === 'function' && reference["frameNotes"][idx]) {
                let patch = build(new FrameNoteBuilder(reference["frameNotes"][idx])).patch();
                patches = patches.concat(patch.map(patch => {
                    // TODO: detach?
                    patch.p = ["frameNotes", idx].concat(patch.p);
                    return patch;
                }));
                frozen["frameNotes"][idx] = true;
                return this;
            }
            let update = typeof build === 'function' ? build(new FrameNoteBuilder(reference["frameNotes"][idx])).build() : build;
            if (original) {
                patches.push({ p: ["frameNotes", idx], li: update });
            }
            else {
                updates["frameNotes"] = reference["frameNotes"]; // TODO: Merge?
            }
            reference["frameNotes"][idx] = update;
            frozen["frameNotes"][idx] = true;
            return this;
        };
        this.frameNotesSplice = (start, deleteCount, ...items) => {
            makeReference("frameNotes");
            let idx = start;
            if (original) {
                for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
                    if (frozen["frameNotes"][idx]) {
                        throw new Error("Replacing frameNotes." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["frameNotes"][idx];
                    patches.push({ p: ["frameNotes", idx], ld, li: items[idx - start] });
                    frozen["frameNotes"][idx] = true;
                }
                for (; idx < start + deleteCount; ++idx) {
                    if (frozen["frameNotes"][idx]) {
                        throw new Error("Removing frameNotes." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["frameNotes"][idx];
                    patches.push({ p: ["frameNotes", idx], ld });
                }
                for (; idx < start + items.length; ++idx) {
                    patches.push({ p: ["frameNotes", idx], li: items[idx - start] });
                    frozen["frameNotes"][idx] = true;
                }
            }
            reference["frameNotes"].splice(start, deleteCount, ...items);
            updates["frameNotes"] = reference["frameNotes"];
            frozen["frameNotes"].splice(start, deleteCount, ...items.map(i => true));
            return this;
        };
        this.unplayed = (spec) => {
            updates["unplayed"] = spec;
            delete childBuilders["unplayed;"];
            modifiedKeys["unplayed"] = true;
            return this;
        };
        this.frameFrets = (spec) => {
            updates["frameFrets"] = spec;
            delete childBuilders["frameFrets;"];
            modifiedKeys["frameFrets"] = true;
            return this;
        };
        this.firstFret = (build) => {
            if (typeof build === 'function') {
                delete updates["firstFret"];
                const builder = build(new FirstFretBuilder(original && original["firstFret"]));
                if (!original)
                    updates["firstFret"] = builder.build();
                else
                    childBuilders["firstFret"] = builder;
            }
            else {
                updates.firstFret = build;
                delete childBuilders["firstFret;"];
            }
            modifiedKeys["firstFret"] = true;
            return this;
        };
        this.width = (spec) => {
            updates["width"] = spec;
            delete childBuilders["width;"];
            modifiedKeys["width"] = true;
            return this;
        };
        this.height = (spec) => {
            updates["height"] = spec;
            delete childBuilders["height;"];
            modifiedKeys["height"] = true;
            return this;
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
        this.halign = (spec) => {
            updates["halign"] = spec;
            delete childBuilders["halign;"];
            modifiedKeys["halign"] = true;
            return this;
        };
        this.valignImage = (spec) => {
            updates["valignImage"] = spec;
            delete childBuilders["valignImage;"];
            modifiedKeys["valignImage"] = true;
            return this;
        };
    }
}
function patchFrame(base, builder) { return builder(new FrameBuilder(base)).patch(); }
exports.patchFrame = patchFrame;
function buildFrame(builder) { return builder(new FrameBuilder()).build(); }
exports.buildFrame = buildFrame;
class FirstFretBuilder {
    build;
    patch;
    text;
    location;
    data;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["text"]) ||
                childBuilders["text"] !== undefined ||
                updates.text !== undefined, "text is a required field");
            console.assert((original && !modifiedKeys["location"]) ||
                childBuilders["location"] !== undefined ||
                updates.location !== undefined, "location is a required field");
            console.assert((original && !modifiedKeys["data"]) ||
                childBuilders["data"] !== undefined ||
                updates.data !== undefined, "data is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "FirstFret";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.text = (spec) => {
            updates["text"] = spec;
            delete childBuilders["text;"];
            modifiedKeys["text"] = true;
            return this;
        };
        this.location = (spec) => {
            updates["location"] = spec;
            delete childBuilders["location;"];
            modifiedKeys["location"] = true;
            return this;
        };
        this.data = (spec) => {
            updates["data"] = spec;
            delete childBuilders["data;"];
            modifiedKeys["data"] = true;
            return this;
        };
    }
}
function patchFirstFret(base, builder) { return builder(new FirstFretBuilder(base)).patch(); }
exports.patchFirstFret = patchFirstFret;
function buildFirstFret(builder) { return builder(new FirstFretBuilder()).build(); }
exports.buildFirstFret = buildFirstFret;
class FrameNoteBuilder {
    build;
    patch;
    barre;
    string;
    fingering;
    fret;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["barre"]) ||
                childBuilders["barre"] !== undefined ||
                updates.barre !== undefined, "barre is a required field");
            console.assert((original && !modifiedKeys["string"]) ||
                childBuilders["string"] !== undefined ||
                updates.string !== undefined, "string is a required field");
            console.assert((original && !modifiedKeys["fingering"]) ||
                childBuilders["fingering"] !== undefined ||
                updates.fingering !== undefined, "fingering is a required field");
            console.assert((original && !modifiedKeys["fret"]) ||
                childBuilders["fret"] !== undefined ||
                updates.fret !== undefined, "fret is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "FrameNote";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.barre = (build) => {
            if (typeof build === 'function') {
                delete updates["barre"];
                const builder = build(new BarreBuilder(original && original["barre"]));
                if (!original)
                    updates["barre"] = builder.build();
                else
                    childBuilders["barre"] = builder;
            }
            else {
                updates.barre = build;
                delete childBuilders["barre;"];
            }
            modifiedKeys["barre"] = true;
            return this;
        };
        this.string = (build) => {
            if (typeof build === 'function') {
                delete updates["string"];
                const builder = build(new StringBuilder(original && original["string"]));
                if (!original)
                    updates["string"] = builder.build();
                else
                    childBuilders["string"] = builder;
            }
            else {
                updates.string = build;
                delete childBuilders["string;"];
            }
            modifiedKeys["string"] = true;
            return this;
        };
        this.fingering = (build) => {
            if (typeof build === 'function') {
                delete updates["fingering"];
                const builder = build(new FingeringBuilder(original && original["fingering"]));
                if (!original)
                    updates["fingering"] = builder.build();
                else
                    childBuilders["fingering"] = builder;
            }
            else {
                updates.fingering = build;
                delete childBuilders["fingering;"];
            }
            modifiedKeys["fingering"] = true;
            return this;
        };
        this.fret = (build) => {
            if (typeof build === 'function') {
                delete updates["fret"];
                const builder = build(new FretBuilder(original && original["fret"]));
                if (!original)
                    updates["fret"] = builder.build();
                else
                    childBuilders["fret"] = builder;
            }
            else {
                updates.fret = build;
                delete childBuilders["fret;"];
            }
            modifiedKeys["fret"] = true;
            return this;
        };
    }
}
function patchFrameNote(base, builder) { return builder(new FrameNoteBuilder(base)).patch(); }
exports.patchFrameNote = patchFrameNote;
function buildFrameNote(builder) { return builder(new FrameNoteBuilder()).build(); }
exports.buildFrameNote = buildFrameNote;
class BarreBuilder {
    build;
    patch;
    type;
    color;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["type"]) ||
                childBuilders["type"] !== undefined ||
                updates.type !== undefined, "type is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Barre";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.type = (spec) => {
            updates["type"] = spec;
            delete childBuilders["type;"];
            modifiedKeys["type"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
    }
}
function patchBarre(base, builder) { return builder(new BarreBuilder(base)).patch(); }
exports.patchBarre = patchBarre;
function buildBarre(builder) { return builder(new BarreBuilder()).build(); }
exports.buildBarre = buildBarre;
class GroupingBuilder {
    build;
    patch;
    featuresAt;
    featuresSplice;
    features;
    number;
    type;
    memberOf;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["features"]) ||
                childBuilders["features"] !== undefined ||
                updates.features !== undefined, "features is a required field");
            console.assert((original && !modifiedKeys["number"]) ||
                childBuilders["number"] !== undefined ||
                updates.number !== undefined, "number is a required field");
            console.assert((original && !modifiedKeys["type"]) ||
                childBuilders["type"] !== undefined ||
                updates.type !== undefined, "type is a required field");
            console.assert((original && !modifiedKeys["memberOf"]) ||
                childBuilders["memberOf"] !== undefined ||
                updates.memberOf !== undefined, "memberOf is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Grouping";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.features = (spec) => {
            updates["features"] = spec;
            delete childBuilders["features;"];
            modifiedKeys["features"] = true;
            return this;
        };
        this.featuresAt = (idx, build) => {
            makeReference("features");
            if (frozen["features"][idx]) {
                throw new Error("Patching features." + idx + " twice in a builder is unsupported.");
            }
            if (original && original._snapshot && original._snapshot["features"] && original._snapshot["features"][idx] && !original["features"][idx]) {
                // Clone snapshot.
                patches.push({ p: ["features", idx], li: original._snapshot["features"] });
            }
            if (typeof build === 'function' && reference["features"][idx]) {
                let patch = build(new FeatureBuilder(reference["features"][idx])).patch();
                patches = patches.concat(patch.map(patch => {
                    // TODO: detach?
                    patch.p = ["features", idx].concat(patch.p);
                    return patch;
                }));
                frozen["features"][idx] = true;
                return this;
            }
            let update = typeof build === 'function' ? build(new FeatureBuilder(reference["features"][idx])).build() : build;
            if (original) {
                patches.push({ p: ["features", idx], li: update });
            }
            else {
                updates["features"] = reference["features"]; // TODO: Merge?
            }
            reference["features"][idx] = update;
            frozen["features"][idx] = true;
            return this;
        };
        this.featuresSplice = (start, deleteCount, ...items) => {
            makeReference("features");
            let idx = start;
            if (original) {
                for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
                    if (frozen["features"][idx]) {
                        throw new Error("Replacing features." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["features"][idx];
                    patches.push({ p: ["features", idx], ld, li: items[idx - start] });
                    frozen["features"][idx] = true;
                }
                for (; idx < start + deleteCount; ++idx) {
                    if (frozen["features"][idx]) {
                        throw new Error("Removing features." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["features"][idx];
                    patches.push({ p: ["features", idx], ld });
                }
                for (; idx < start + items.length; ++idx) {
                    patches.push({ p: ["features", idx], li: items[idx - start] });
                    frozen["features"][idx] = true;
                }
            }
            reference["features"].splice(start, deleteCount, ...items);
            updates["features"] = reference["features"];
            frozen["features"].splice(start, deleteCount, ...items.map(i => true));
            return this;
        };
        this.number = (spec) => {
            updates["number"] = spec;
            delete childBuilders["number;"];
            modifiedKeys["number"] = true;
            return this;
        };
        this.type = (spec) => {
            updates["type"] = spec;
            delete childBuilders["type;"];
            modifiedKeys["type"] = true;
            return this;
        };
        this.memberOf = (spec) => {
            updates["memberOf"] = spec;
            delete childBuilders["memberOf;"];
            modifiedKeys["memberOf"] = true;
            return this;
        };
    }
}
function patchGrouping(base, builder) { return builder(new GroupingBuilder(base)).patch(); }
exports.patchGrouping = patchGrouping;
function buildGrouping(builder) { return builder(new GroupingBuilder()).build(); }
exports.buildGrouping = buildGrouping;
class FeatureBuilder {
    build;
    patch;
    data;
    type;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["data"]) ||
                childBuilders["data"] !== undefined ||
                updates.data !== undefined, "data is a required field");
            console.assert((original && !modifiedKeys["type"]) ||
                childBuilders["type"] !== undefined ||
                updates.type !== undefined, "type is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Feature";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.data = (spec) => {
            updates["data"] = spec;
            delete childBuilders["data;"];
            modifiedKeys["data"] = true;
            return this;
        };
        this.type = (spec) => {
            updates["type"] = spec;
            delete childBuilders["type;"];
            modifiedKeys["type"] = true;
            return this;
        };
    }
}
function patchFeature(base, builder) { return builder(new FeatureBuilder(base)).patch(); }
exports.patchFeature = patchFeature;
function buildFeature(builder) { return builder(new FeatureBuilder()).build(); }
exports.buildFeature = buildFeature;
class PrintBuilder {
    build;
    patch;
    measureNumbering;
    partNameDisplay;
    newSystem;
    newPage;
    blankPage;
    measureLayout;
    partAbbreviationDisplay;
    pageLayout;
    systemLayout;
    staffSpacing;
    staffLayoutsAt;
    staffLayoutsSplice;
    staffLayouts;
    pageNumber;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["measureNumbering"]) ||
                childBuilders["measureNumbering"] !== undefined ||
                updates.measureNumbering !== undefined, "measureNumbering is a required field");
            console.assert((original && !modifiedKeys["partNameDisplay"]) ||
                childBuilders["partNameDisplay"] !== undefined ||
                updates.partNameDisplay !== undefined, "partNameDisplay is a required field");
            console.assert((original && !modifiedKeys["newSystem"]) ||
                childBuilders["newSystem"] !== undefined ||
                updates.newSystem !== undefined, "newSystem is a required field");
            console.assert((original && !modifiedKeys["newPage"]) ||
                childBuilders["newPage"] !== undefined ||
                updates.newPage !== undefined, "newPage is a required field");
            console.assert((original && !modifiedKeys["blankPage"]) ||
                childBuilders["blankPage"] !== undefined ||
                updates.blankPage !== undefined, "blankPage is a required field");
            console.assert((original && !modifiedKeys["measureLayout"]) ||
                childBuilders["measureLayout"] !== undefined ||
                updates.measureLayout !== undefined, "measureLayout is a required field");
            console.assert((original && !modifiedKeys["partAbbreviationDisplay"]) ||
                childBuilders["partAbbreviationDisplay"] !== undefined ||
                updates.partAbbreviationDisplay !== undefined, "partAbbreviationDisplay is a required field");
            console.assert((original && !modifiedKeys["pageLayout"]) ||
                childBuilders["pageLayout"] !== undefined ||
                updates.pageLayout !== undefined, "pageLayout is a required field");
            console.assert((original && !modifiedKeys["systemLayout"]) ||
                childBuilders["systemLayout"] !== undefined ||
                updates.systemLayout !== undefined, "systemLayout is a required field");
            console.assert((original && !modifiedKeys["staffSpacing"]) ||
                childBuilders["staffSpacing"] !== undefined ||
                updates.staffSpacing !== undefined, "staffSpacing is a required field");
            console.assert((original && !modifiedKeys["staffLayouts"]) ||
                childBuilders["staffLayouts"] !== undefined ||
                updates.staffLayouts !== undefined, "staffLayouts is a required field");
            console.assert((original && !modifiedKeys["pageNumber"]) ||
                childBuilders["pageNumber"] !== undefined ||
                updates.pageNumber !== undefined, "pageNumber is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Print";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.measureNumbering = (build) => {
            if (typeof build === 'function') {
                delete updates["measureNumbering"];
                const builder = build(new MeasureNumberingBuilder(original && original["measureNumbering"]));
                if (!original)
                    updates["measureNumbering"] = builder.build();
                else
                    childBuilders["measureNumbering"] = builder;
            }
            else {
                updates.measureNumbering = build;
                delete childBuilders["measureNumbering;"];
            }
            modifiedKeys["measureNumbering"] = true;
            return this;
        };
        this.partNameDisplay = (build) => {
            if (typeof build === 'function') {
                delete updates["partNameDisplay"];
                const builder = build(new PartNameDisplayBuilder(original && original["partNameDisplay"]));
                if (!original)
                    updates["partNameDisplay"] = builder.build();
                else
                    childBuilders["partNameDisplay"] = builder;
            }
            else {
                updates.partNameDisplay = build;
                delete childBuilders["partNameDisplay;"];
            }
            modifiedKeys["partNameDisplay"] = true;
            return this;
        };
        this.newSystem = (spec) => {
            updates["newSystem"] = spec;
            delete childBuilders["newSystem;"];
            modifiedKeys["newSystem"] = true;
            return this;
        };
        this.newPage = (spec) => {
            updates["newPage"] = spec;
            delete childBuilders["newPage;"];
            modifiedKeys["newPage"] = true;
            return this;
        };
        this.blankPage = (spec) => {
            updates["blankPage"] = spec;
            delete childBuilders["blankPage;"];
            modifiedKeys["blankPage"] = true;
            return this;
        };
        this.measureLayout = (build) => {
            if (typeof build === 'function') {
                delete updates["measureLayout"];
                const builder = build(new MeasureLayoutBuilder(original && original["measureLayout"]));
                if (!original)
                    updates["measureLayout"] = builder.build();
                else
                    childBuilders["measureLayout"] = builder;
            }
            else {
                updates.measureLayout = build;
                delete childBuilders["measureLayout;"];
            }
            modifiedKeys["measureLayout"] = true;
            return this;
        };
        this.partAbbreviationDisplay = (build) => {
            if (typeof build === 'function') {
                delete updates["partAbbreviationDisplay"];
                const builder = build(new PartAbbreviationDisplayBuilder(original && original["partAbbreviationDisplay"]));
                if (!original)
                    updates["partAbbreviationDisplay"] = builder.build();
                else
                    childBuilders["partAbbreviationDisplay"] = builder;
            }
            else {
                updates.partAbbreviationDisplay = build;
                delete childBuilders["partAbbreviationDisplay;"];
            }
            modifiedKeys["partAbbreviationDisplay"] = true;
            return this;
        };
        this.pageLayout = (build) => {
            if (typeof build === 'function') {
                delete updates["pageLayout"];
                const builder = build(new PageLayoutBuilder(original && original["pageLayout"]));
                if (!original)
                    updates["pageLayout"] = builder.build();
                else
                    childBuilders["pageLayout"] = builder;
            }
            else {
                updates.pageLayout = build;
                delete childBuilders["pageLayout;"];
            }
            modifiedKeys["pageLayout"] = true;
            return this;
        };
        this.systemLayout = (build) => {
            if (typeof build === 'function') {
                delete updates["systemLayout"];
                const builder = build(new SystemLayoutBuilder(original && original["systemLayout"]));
                if (!original)
                    updates["systemLayout"] = builder.build();
                else
                    childBuilders["systemLayout"] = builder;
            }
            else {
                updates.systemLayout = build;
                delete childBuilders["systemLayout;"];
            }
            modifiedKeys["systemLayout"] = true;
            return this;
        };
        this.staffSpacing = (spec) => {
            updates["staffSpacing"] = spec;
            delete childBuilders["staffSpacing;"];
            modifiedKeys["staffSpacing"] = true;
            return this;
        };
        this.staffLayouts = (spec) => {
            updates["staffLayouts"] = spec;
            delete childBuilders["staffLayouts;"];
            modifiedKeys["staffLayouts"] = true;
            return this;
        };
        this.staffLayoutsAt = (idx, build) => {
            makeReference("staffLayouts");
            if (frozen["staffLayouts"][idx]) {
                throw new Error("Patching staffLayouts." + idx + " twice in a builder is unsupported.");
            }
            if (original && original._snapshot && original._snapshot["staffLayouts"] && original._snapshot["staffLayouts"][idx] && !original["staffLayouts"][idx]) {
                // Clone snapshot.
                patches.push({ p: ["staffLayouts", idx], li: original._snapshot["staffLayouts"] });
            }
            if (typeof build === 'function' && reference["staffLayouts"][idx]) {
                let patch = build(new StaffLayoutBuilder(reference["staffLayouts"][idx])).patch();
                patches = patches.concat(patch.map(patch => {
                    // TODO: detach?
                    patch.p = ["staffLayouts", idx].concat(patch.p);
                    return patch;
                }));
                frozen["staffLayouts"][idx] = true;
                return this;
            }
            let update = typeof build === 'function' ? build(new StaffLayoutBuilder(reference["staffLayouts"][idx])).build() : build;
            if (original) {
                patches.push({ p: ["staffLayouts", idx], li: update });
            }
            else {
                updates["staffLayouts"] = reference["staffLayouts"]; // TODO: Merge?
            }
            reference["staffLayouts"][idx] = update;
            frozen["staffLayouts"][idx] = true;
            return this;
        };
        this.staffLayoutsSplice = (start, deleteCount, ...items) => {
            makeReference("staffLayouts");
            let idx = start;
            if (original) {
                for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
                    if (frozen["staffLayouts"][idx]) {
                        throw new Error("Replacing staffLayouts." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["staffLayouts"][idx];
                    patches.push({ p: ["staffLayouts", idx], ld, li: items[idx - start] });
                    frozen["staffLayouts"][idx] = true;
                }
                for (; idx < start + deleteCount; ++idx) {
                    if (frozen["staffLayouts"][idx]) {
                        throw new Error("Removing staffLayouts." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["staffLayouts"][idx];
                    patches.push({ p: ["staffLayouts", idx], ld });
                }
                for (; idx < start + items.length; ++idx) {
                    patches.push({ p: ["staffLayouts", idx], li: items[idx - start] });
                    frozen["staffLayouts"][idx] = true;
                }
            }
            reference["staffLayouts"].splice(start, deleteCount, ...items);
            updates["staffLayouts"] = reference["staffLayouts"];
            frozen["staffLayouts"].splice(start, deleteCount, ...items.map(i => true));
            return this;
        };
        this.pageNumber = (spec) => {
            updates["pageNumber"] = spec;
            delete childBuilders["pageNumber;"];
            modifiedKeys["pageNumber"] = true;
            return this;
        };
    }
}
function patchPrint(base, builder) { return builder(new PrintBuilder(base)).patch(); }
exports.patchPrint = patchPrint;
function buildPrint(builder) { return builder(new PrintBuilder()).build(); }
exports.buildPrint = buildPrint;
class MeasureNumberingBuilder {
    build;
    patch;
    data;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    fontFamily;
    fontWeight;
    fontStyle;
    fontSize;
    color;
    halign;
    valign;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["data"]) ||
                childBuilders["data"] !== undefined ||
                updates.data !== undefined, "data is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "MeasureNumbering";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.data = (spec) => {
            updates["data"] = spec;
            delete childBuilders["data;"];
            modifiedKeys["data"] = true;
            return this;
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
        this.fontFamily = (spec) => {
            updates["fontFamily"] = spec;
            delete childBuilders["fontFamily;"];
            modifiedKeys["fontFamily"] = true;
            return this;
        };
        this.fontWeight = (spec) => {
            updates["fontWeight"] = spec;
            delete childBuilders["fontWeight;"];
            modifiedKeys["fontWeight"] = true;
            return this;
        };
        this.fontStyle = (spec) => {
            updates["fontStyle"] = spec;
            delete childBuilders["fontStyle;"];
            modifiedKeys["fontStyle"] = true;
            return this;
        };
        this.fontSize = (spec) => {
            updates["fontSize"] = spec;
            delete childBuilders["fontSize;"];
            modifiedKeys["fontSize"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
        this.halign = (spec) => {
            updates["halign"] = spec;
            delete childBuilders["halign;"];
            modifiedKeys["halign"] = true;
            return this;
        };
        this.valign = (spec) => {
            updates["valign"] = spec;
            delete childBuilders["valign;"];
            modifiedKeys["valign"] = true;
            return this;
        };
    }
}
function patchMeasureNumbering(base, builder) { return builder(new MeasureNumberingBuilder(base)).patch(); }
exports.patchMeasureNumbering = patchMeasureNumbering;
function buildMeasureNumbering(builder) { return builder(new MeasureNumberingBuilder()).build(); }
exports.buildMeasureNumbering = buildMeasureNumbering;
class SoundBuilder {
    build;
    patch;
    softPedal;
    midiInstrumentsAt;
    midiInstrumentsSplice;
    midiInstruments;
    pan;
    tocoda;
    decapo;
    divisions;
    pizzicato;
    coda;
    segno;
    elevation;
    fine;
    damperPedal;
    dynamics;
    playsAt;
    playsSplice;
    plays;
    offset;
    sostenutoPedal;
    dalsegno;
    midiDevicesAt;
    midiDevicesSplice;
    midiDevices;
    tempo;
    forwardRepeat;
    timeOnly;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["softPedal"]) ||
                childBuilders["softPedal"] !== undefined ||
                updates.softPedal !== undefined, "softPedal is a required field");
            console.assert((original && !modifiedKeys["midiInstruments"]) ||
                childBuilders["midiInstruments"] !== undefined ||
                updates.midiInstruments !== undefined, "midiInstruments is a required field");
            console.assert((original && !modifiedKeys["pan"]) ||
                childBuilders["pan"] !== undefined ||
                updates.pan !== undefined, "pan is a required field");
            console.assert((original && !modifiedKeys["tocoda"]) ||
                childBuilders["tocoda"] !== undefined ||
                updates.tocoda !== undefined, "tocoda is a required field");
            console.assert((original && !modifiedKeys["decapo"]) ||
                childBuilders["decapo"] !== undefined ||
                updates.decapo !== undefined, "decapo is a required field");
            console.assert((original && !modifiedKeys["divisions"]) ||
                childBuilders["divisions"] !== undefined ||
                updates.divisions !== undefined, "divisions is a required field");
            console.assert((original && !modifiedKeys["pizzicato"]) ||
                childBuilders["pizzicato"] !== undefined ||
                updates.pizzicato !== undefined, "pizzicato is a required field");
            console.assert((original && !modifiedKeys["coda"]) ||
                childBuilders["coda"] !== undefined ||
                updates.coda !== undefined, "coda is a required field");
            console.assert((original && !modifiedKeys["segno"]) ||
                childBuilders["segno"] !== undefined ||
                updates.segno !== undefined, "segno is a required field");
            console.assert((original && !modifiedKeys["elevation"]) ||
                childBuilders["elevation"] !== undefined ||
                updates.elevation !== undefined, "elevation is a required field");
            console.assert((original && !modifiedKeys["fine"]) ||
                childBuilders["fine"] !== undefined ||
                updates.fine !== undefined, "fine is a required field");
            console.assert((original && !modifiedKeys["damperPedal"]) ||
                childBuilders["damperPedal"] !== undefined ||
                updates.damperPedal !== undefined, "damperPedal is a required field");
            console.assert((original && !modifiedKeys["dynamics"]) ||
                childBuilders["dynamics"] !== undefined ||
                updates.dynamics !== undefined, "dynamics is a required field");
            console.assert((original && !modifiedKeys["plays"]) ||
                childBuilders["plays"] !== undefined ||
                updates.plays !== undefined, "plays is a required field");
            console.assert((original && !modifiedKeys["offset"]) ||
                childBuilders["offset"] !== undefined ||
                updates.offset !== undefined, "offset is a required field");
            console.assert((original && !modifiedKeys["sostenutoPedal"]) ||
                childBuilders["sostenutoPedal"] !== undefined ||
                updates.sostenutoPedal !== undefined, "sostenutoPedal is a required field");
            console.assert((original && !modifiedKeys["dalsegno"]) ||
                childBuilders["dalsegno"] !== undefined ||
                updates.dalsegno !== undefined, "dalsegno is a required field");
            console.assert((original && !modifiedKeys["midiDevices"]) ||
                childBuilders["midiDevices"] !== undefined ||
                updates.midiDevices !== undefined, "midiDevices is a required field");
            console.assert((original && !modifiedKeys["tempo"]) ||
                childBuilders["tempo"] !== undefined ||
                updates.tempo !== undefined, "tempo is a required field");
            console.assert((original && !modifiedKeys["forwardRepeat"]) ||
                childBuilders["forwardRepeat"] !== undefined ||
                updates.forwardRepeat !== undefined, "forwardRepeat is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Sound";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.softPedal = (spec) => {
            updates["softPedal"] = spec;
            delete childBuilders["softPedal;"];
            modifiedKeys["softPedal"] = true;
            return this;
        };
        this.midiInstruments = (spec) => {
            updates["midiInstruments"] = spec;
            delete childBuilders["midiInstruments;"];
            modifiedKeys["midiInstruments"] = true;
            return this;
        };
        this.midiInstrumentsAt = (idx, build) => {
            makeReference("midiInstruments");
            if (frozen["midiInstruments"][idx]) {
                throw new Error("Patching midiInstruments." + idx + " twice in a builder is unsupported.");
            }
            if (original && original._snapshot && original._snapshot["midiInstruments"] && original._snapshot["midiInstruments"][idx] && !original["midiInstruments"][idx]) {
                // Clone snapshot.
                patches.push({ p: ["midiInstruments", idx], li: original._snapshot["midiInstruments"] });
            }
            if (typeof build === 'function' && reference["midiInstruments"][idx]) {
                let patch = build(new MidiInstrumentBuilder(reference["midiInstruments"][idx])).patch();
                patches = patches.concat(patch.map(patch => {
                    // TODO: detach?
                    patch.p = ["midiInstruments", idx].concat(patch.p);
                    return patch;
                }));
                frozen["midiInstruments"][idx] = true;
                return this;
            }
            let update = typeof build === 'function' ? build(new MidiInstrumentBuilder(reference["midiInstruments"][idx])).build() : build;
            if (original) {
                patches.push({ p: ["midiInstruments", idx], li: update });
            }
            else {
                updates["midiInstruments"] = reference["midiInstruments"]; // TODO: Merge?
            }
            reference["midiInstruments"][idx] = update;
            frozen["midiInstruments"][idx] = true;
            return this;
        };
        this.midiInstrumentsSplice = (start, deleteCount, ...items) => {
            makeReference("midiInstruments");
            let idx = start;
            if (original) {
                for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
                    if (frozen["midiInstruments"][idx]) {
                        throw new Error("Replacing midiInstruments." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["midiInstruments"][idx];
                    patches.push({ p: ["midiInstruments", idx], ld, li: items[idx - start] });
                    frozen["midiInstruments"][idx] = true;
                }
                for (; idx < start + deleteCount; ++idx) {
                    if (frozen["midiInstruments"][idx]) {
                        throw new Error("Removing midiInstruments." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["midiInstruments"][idx];
                    patches.push({ p: ["midiInstruments", idx], ld });
                }
                for (; idx < start + items.length; ++idx) {
                    patches.push({ p: ["midiInstruments", idx], li: items[idx - start] });
                    frozen["midiInstruments"][idx] = true;
                }
            }
            reference["midiInstruments"].splice(start, deleteCount, ...items);
            updates["midiInstruments"] = reference["midiInstruments"];
            frozen["midiInstruments"].splice(start, deleteCount, ...items.map(i => true));
            return this;
        };
        this.pan = (spec) => {
            updates["pan"] = spec;
            delete childBuilders["pan;"];
            modifiedKeys["pan"] = true;
            return this;
        };
        this.tocoda = (spec) => {
            updates["tocoda"] = spec;
            delete childBuilders["tocoda;"];
            modifiedKeys["tocoda"] = true;
            return this;
        };
        this.decapo = (spec) => {
            updates["decapo"] = spec;
            delete childBuilders["decapo;"];
            modifiedKeys["decapo"] = true;
            return this;
        };
        this.divisions = (spec) => {
            updates["divisions"] = spec;
            delete childBuilders["divisions;"];
            modifiedKeys["divisions"] = true;
            return this;
        };
        this.pizzicato = (spec) => {
            updates["pizzicato"] = spec;
            delete childBuilders["pizzicato;"];
            modifiedKeys["pizzicato"] = true;
            return this;
        };
        this.coda = (spec) => {
            updates["coda"] = spec;
            delete childBuilders["coda;"];
            modifiedKeys["coda"] = true;
            return this;
        };
        this.segno = (spec) => {
            updates["segno"] = spec;
            delete childBuilders["segno;"];
            modifiedKeys["segno"] = true;
            return this;
        };
        this.elevation = (spec) => {
            updates["elevation"] = spec;
            delete childBuilders["elevation;"];
            modifiedKeys["elevation"] = true;
            return this;
        };
        this.fine = (spec) => {
            updates["fine"] = spec;
            delete childBuilders["fine;"];
            modifiedKeys["fine"] = true;
            return this;
        };
        this.damperPedal = (spec) => {
            updates["damperPedal"] = spec;
            delete childBuilders["damperPedal;"];
            modifiedKeys["damperPedal"] = true;
            return this;
        };
        this.dynamics = (spec) => {
            updates["dynamics"] = spec;
            delete childBuilders["dynamics;"];
            modifiedKeys["dynamics"] = true;
            return this;
        };
        this.plays = (spec) => {
            updates["plays"] = spec;
            delete childBuilders["plays;"];
            modifiedKeys["plays"] = true;
            return this;
        };
        this.playsAt = (idx, build) => {
            makeReference("plays");
            if (frozen["plays"][idx]) {
                throw new Error("Patching plays." + idx + " twice in a builder is unsupported.");
            }
            if (original && original._snapshot && original._snapshot["plays"] && original._snapshot["plays"][idx] && !original["plays"][idx]) {
                // Clone snapshot.
                patches.push({ p: ["plays", idx], li: original._snapshot["plays"] });
            }
            if (typeof build === 'function' && reference["plays"][idx]) {
                let patch = build(new PlayBuilder(reference["plays"][idx])).patch();
                patches = patches.concat(patch.map(patch => {
                    // TODO: detach?
                    patch.p = ["plays", idx].concat(patch.p);
                    return patch;
                }));
                frozen["plays"][idx] = true;
                return this;
            }
            let update = typeof build === 'function' ? build(new PlayBuilder(reference["plays"][idx])).build() : build;
            if (original) {
                patches.push({ p: ["plays", idx], li: update });
            }
            else {
                updates["plays"] = reference["plays"]; // TODO: Merge?
            }
            reference["plays"][idx] = update;
            frozen["plays"][idx] = true;
            return this;
        };
        this.playsSplice = (start, deleteCount, ...items) => {
            makeReference("plays");
            let idx = start;
            if (original) {
                for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
                    if (frozen["plays"][idx]) {
                        throw new Error("Replacing plays." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["plays"][idx];
                    patches.push({ p: ["plays", idx], ld, li: items[idx - start] });
                    frozen["plays"][idx] = true;
                }
                for (; idx < start + deleteCount; ++idx) {
                    if (frozen["plays"][idx]) {
                        throw new Error("Removing plays." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["plays"][idx];
                    patches.push({ p: ["plays", idx], ld });
                }
                for (; idx < start + items.length; ++idx) {
                    patches.push({ p: ["plays", idx], li: items[idx - start] });
                    frozen["plays"][idx] = true;
                }
            }
            reference["plays"].splice(start, deleteCount, ...items);
            updates["plays"] = reference["plays"];
            frozen["plays"].splice(start, deleteCount, ...items.map(i => true));
            return this;
        };
        this.offset = (build) => {
            if (typeof build === 'function') {
                delete updates["offset"];
                const builder = build(new OffsetBuilder(original && original["offset"]));
                if (!original)
                    updates["offset"] = builder.build();
                else
                    childBuilders["offset"] = builder;
            }
            else {
                updates.offset = build;
                delete childBuilders["offset;"];
            }
            modifiedKeys["offset"] = true;
            return this;
        };
        this.sostenutoPedal = (spec) => {
            updates["sostenutoPedal"] = spec;
            delete childBuilders["sostenutoPedal;"];
            modifiedKeys["sostenutoPedal"] = true;
            return this;
        };
        this.dalsegno = (spec) => {
            updates["dalsegno"] = spec;
            delete childBuilders["dalsegno;"];
            modifiedKeys["dalsegno"] = true;
            return this;
        };
        this.midiDevices = (spec) => {
            updates["midiDevices"] = spec;
            delete childBuilders["midiDevices;"];
            modifiedKeys["midiDevices"] = true;
            return this;
        };
        this.midiDevicesAt = (idx, build) => {
            makeReference("midiDevices");
            if (frozen["midiDevices"][idx]) {
                throw new Error("Patching midiDevices." + idx + " twice in a builder is unsupported.");
            }
            if (original && original._snapshot && original._snapshot["midiDevices"] && original._snapshot["midiDevices"][idx] && !original["midiDevices"][idx]) {
                // Clone snapshot.
                patches.push({ p: ["midiDevices", idx], li: original._snapshot["midiDevices"] });
            }
            if (typeof build === 'function' && reference["midiDevices"][idx]) {
                let patch = build(new MidiDeviceBuilder(reference["midiDevices"][idx])).patch();
                patches = patches.concat(patch.map(patch => {
                    // TODO: detach?
                    patch.p = ["midiDevices", idx].concat(patch.p);
                    return patch;
                }));
                frozen["midiDevices"][idx] = true;
                return this;
            }
            let update = typeof build === 'function' ? build(new MidiDeviceBuilder(reference["midiDevices"][idx])).build() : build;
            if (original) {
                patches.push({ p: ["midiDevices", idx], li: update });
            }
            else {
                updates["midiDevices"] = reference["midiDevices"]; // TODO: Merge?
            }
            reference["midiDevices"][idx] = update;
            frozen["midiDevices"][idx] = true;
            return this;
        };
        this.midiDevicesSplice = (start, deleteCount, ...items) => {
            makeReference("midiDevices");
            let idx = start;
            if (original) {
                for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
                    if (frozen["midiDevices"][idx]) {
                        throw new Error("Replacing midiDevices." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["midiDevices"][idx];
                    patches.push({ p: ["midiDevices", idx], ld, li: items[idx - start] });
                    frozen["midiDevices"][idx] = true;
                }
                for (; idx < start + deleteCount; ++idx) {
                    if (frozen["midiDevices"][idx]) {
                        throw new Error("Removing midiDevices." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["midiDevices"][idx];
                    patches.push({ p: ["midiDevices", idx], ld });
                }
                for (; idx < start + items.length; ++idx) {
                    patches.push({ p: ["midiDevices", idx], li: items[idx - start] });
                    frozen["midiDevices"][idx] = true;
                }
            }
            reference["midiDevices"].splice(start, deleteCount, ...items);
            updates["midiDevices"] = reference["midiDevices"];
            frozen["midiDevices"].splice(start, deleteCount, ...items.map(i => true));
            return this;
        };
        this.tempo = (spec) => {
            updates["tempo"] = spec;
            delete childBuilders["tempo;"];
            modifiedKeys["tempo"] = true;
            return this;
        };
        this.forwardRepeat = (spec) => {
            updates["forwardRepeat"] = spec;
            delete childBuilders["forwardRepeat;"];
            modifiedKeys["forwardRepeat"] = true;
            return this;
        };
        this.timeOnly = (spec) => {
            updates["timeOnly"] = spec;
            delete childBuilders["timeOnly;"];
            modifiedKeys["timeOnly"] = true;
            return this;
        };
    }
}
function patchSound(base, builder) { return builder(new SoundBuilder(base)).patch(); }
exports.patchSound = patchSound;
function buildSound(builder) { return builder(new SoundBuilder()).build(); }
exports.buildSound = buildSound;
class WorkBuilder {
    build;
    patch;
    workNumber;
    workTitle;
    opus;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["workNumber"]) ||
                childBuilders["workNumber"] !== undefined ||
                updates.workNumber !== undefined, "workNumber is a required field");
            console.assert((original && !modifiedKeys["workTitle"]) ||
                childBuilders["workTitle"] !== undefined ||
                updates.workTitle !== undefined, "workTitle is a required field");
            console.assert((original && !modifiedKeys["opus"]) ||
                childBuilders["opus"] !== undefined ||
                updates.opus !== undefined, "opus is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Work";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.workNumber = (spec) => {
            updates["workNumber"] = spec;
            delete childBuilders["workNumber;"];
            modifiedKeys["workNumber"] = true;
            return this;
        };
        this.workTitle = (spec) => {
            updates["workTitle"] = spec;
            delete childBuilders["workTitle;"];
            modifiedKeys["workTitle"] = true;
            return this;
        };
        this.opus = (build) => {
            if (typeof build === 'function') {
                delete updates["opus"];
                const builder = build(new OpusBuilder(original && original["opus"]));
                if (!original)
                    updates["opus"] = builder.build();
                else
                    childBuilders["opus"] = builder;
            }
            else {
                updates.opus = build;
                delete childBuilders["opus;"];
            }
            modifiedKeys["opus"] = true;
            return this;
        };
    }
}
function patchWork(base, builder) { return builder(new WorkBuilder(base)).patch(); }
exports.patchWork = patchWork;
function buildWork(builder) { return builder(new WorkBuilder()).build(); }
exports.buildWork = buildWork;
class OpusBuilder {
    build;
    patch;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Opus";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
    }
}
function patchOpus(base, builder) { return builder(new OpusBuilder(base)).patch(); }
exports.patchOpus = patchOpus;
function buildOpus(builder) { return builder(new OpusBuilder()).build(); }
exports.buildOpus = buildOpus;
class DefaultsBuilder {
    build;
    patch;
    wordFont;
    lyricLanguagesAt;
    lyricLanguagesSplice;
    lyricLanguages;
    lyricFontsAt;
    lyricFontsSplice;
    lyricFonts;
    pageLayout;
    systemLayout;
    appearance;
    scaling;
    staffLayoutsAt;
    staffLayoutsSplice;
    staffLayouts;
    musicFont;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["wordFont"]) ||
                childBuilders["wordFont"] !== undefined ||
                updates.wordFont !== undefined, "wordFont is a required field");
            console.assert((original && !modifiedKeys["lyricLanguages"]) ||
                childBuilders["lyricLanguages"] !== undefined ||
                updates.lyricLanguages !== undefined, "lyricLanguages is a required field");
            console.assert((original && !modifiedKeys["lyricFonts"]) ||
                childBuilders["lyricFonts"] !== undefined ||
                updates.lyricFonts !== undefined, "lyricFonts is a required field");
            console.assert((original && !modifiedKeys["pageLayout"]) ||
                childBuilders["pageLayout"] !== undefined ||
                updates.pageLayout !== undefined, "pageLayout is a required field");
            console.assert((original && !modifiedKeys["systemLayout"]) ||
                childBuilders["systemLayout"] !== undefined ||
                updates.systemLayout !== undefined, "systemLayout is a required field");
            console.assert((original && !modifiedKeys["appearance"]) ||
                childBuilders["appearance"] !== undefined ||
                updates.appearance !== undefined, "appearance is a required field");
            console.assert((original && !modifiedKeys["scaling"]) ||
                childBuilders["scaling"] !== undefined ||
                updates.scaling !== undefined, "scaling is a required field");
            console.assert((original && !modifiedKeys["staffLayouts"]) ||
                childBuilders["staffLayouts"] !== undefined ||
                updates.staffLayouts !== undefined, "staffLayouts is a required field");
            console.assert((original && !modifiedKeys["musicFont"]) ||
                childBuilders["musicFont"] !== undefined ||
                updates.musicFont !== undefined, "musicFont is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Defaults";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.wordFont = (build) => {
            if (typeof build === 'function') {
                delete updates["wordFont"];
                const builder = build(new WordFontBuilder(original && original["wordFont"]));
                if (!original)
                    updates["wordFont"] = builder.build();
                else
                    childBuilders["wordFont"] = builder;
            }
            else {
                updates.wordFont = build;
                delete childBuilders["wordFont;"];
            }
            modifiedKeys["wordFont"] = true;
            return this;
        };
        this.lyricLanguages = (spec) => {
            updates["lyricLanguages"] = spec;
            delete childBuilders["lyricLanguages;"];
            modifiedKeys["lyricLanguages"] = true;
            return this;
        };
        this.lyricLanguagesAt = (idx, build) => {
            makeReference("lyricLanguages");
            if (frozen["lyricLanguages"][idx]) {
                throw new Error("Patching lyricLanguages." + idx + " twice in a builder is unsupported.");
            }
            if (original && original._snapshot && original._snapshot["lyricLanguages"] && original._snapshot["lyricLanguages"][idx] && !original["lyricLanguages"][idx]) {
                // Clone snapshot.
                patches.push({ p: ["lyricLanguages", idx], li: original._snapshot["lyricLanguages"] });
            }
            if (typeof build === 'function' && reference["lyricLanguages"][idx]) {
                let patch = build(new LyricLanguageBuilder(reference["lyricLanguages"][idx])).patch();
                patches = patches.concat(patch.map(patch => {
                    // TODO: detach?
                    patch.p = ["lyricLanguages", idx].concat(patch.p);
                    return patch;
                }));
                frozen["lyricLanguages"][idx] = true;
                return this;
            }
            let update = typeof build === 'function' ? build(new LyricLanguageBuilder(reference["lyricLanguages"][idx])).build() : build;
            if (original) {
                patches.push({ p: ["lyricLanguages", idx], li: update });
            }
            else {
                updates["lyricLanguages"] = reference["lyricLanguages"]; // TODO: Merge?
            }
            reference["lyricLanguages"][idx] = update;
            frozen["lyricLanguages"][idx] = true;
            return this;
        };
        this.lyricLanguagesSplice = (start, deleteCount, ...items) => {
            makeReference("lyricLanguages");
            let idx = start;
            if (original) {
                for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
                    if (frozen["lyricLanguages"][idx]) {
                        throw new Error("Replacing lyricLanguages." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["lyricLanguages"][idx];
                    patches.push({ p: ["lyricLanguages", idx], ld, li: items[idx - start] });
                    frozen["lyricLanguages"][idx] = true;
                }
                for (; idx < start + deleteCount; ++idx) {
                    if (frozen["lyricLanguages"][idx]) {
                        throw new Error("Removing lyricLanguages." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["lyricLanguages"][idx];
                    patches.push({ p: ["lyricLanguages", idx], ld });
                }
                for (; idx < start + items.length; ++idx) {
                    patches.push({ p: ["lyricLanguages", idx], li: items[idx - start] });
                    frozen["lyricLanguages"][idx] = true;
                }
            }
            reference["lyricLanguages"].splice(start, deleteCount, ...items);
            updates["lyricLanguages"] = reference["lyricLanguages"];
            frozen["lyricLanguages"].splice(start, deleteCount, ...items.map(i => true));
            return this;
        };
        this.lyricFonts = (spec) => {
            updates["lyricFonts"] = spec;
            delete childBuilders["lyricFonts;"];
            modifiedKeys["lyricFonts"] = true;
            return this;
        };
        this.lyricFontsAt = (idx, build) => {
            makeReference("lyricFonts");
            if (frozen["lyricFonts"][idx]) {
                throw new Error("Patching lyricFonts." + idx + " twice in a builder is unsupported.");
            }
            if (original && original._snapshot && original._snapshot["lyricFonts"] && original._snapshot["lyricFonts"][idx] && !original["lyricFonts"][idx]) {
                // Clone snapshot.
                patches.push({ p: ["lyricFonts", idx], li: original._snapshot["lyricFonts"] });
            }
            if (typeof build === 'function' && reference["lyricFonts"][idx]) {
                let patch = build(new LyricFontBuilder(reference["lyricFonts"][idx])).patch();
                patches = patches.concat(patch.map(patch => {
                    // TODO: detach?
                    patch.p = ["lyricFonts", idx].concat(patch.p);
                    return patch;
                }));
                frozen["lyricFonts"][idx] = true;
                return this;
            }
            let update = typeof build === 'function' ? build(new LyricFontBuilder(reference["lyricFonts"][idx])).build() : build;
            if (original) {
                patches.push({ p: ["lyricFonts", idx], li: update });
            }
            else {
                updates["lyricFonts"] = reference["lyricFonts"]; // TODO: Merge?
            }
            reference["lyricFonts"][idx] = update;
            frozen["lyricFonts"][idx] = true;
            return this;
        };
        this.lyricFontsSplice = (start, deleteCount, ...items) => {
            makeReference("lyricFonts");
            let idx = start;
            if (original) {
                for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
                    if (frozen["lyricFonts"][idx]) {
                        throw new Error("Replacing lyricFonts." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["lyricFonts"][idx];
                    patches.push({ p: ["lyricFonts", idx], ld, li: items[idx - start] });
                    frozen["lyricFonts"][idx] = true;
                }
                for (; idx < start + deleteCount; ++idx) {
                    if (frozen["lyricFonts"][idx]) {
                        throw new Error("Removing lyricFonts." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["lyricFonts"][idx];
                    patches.push({ p: ["lyricFonts", idx], ld });
                }
                for (; idx < start + items.length; ++idx) {
                    patches.push({ p: ["lyricFonts", idx], li: items[idx - start] });
                    frozen["lyricFonts"][idx] = true;
                }
            }
            reference["lyricFonts"].splice(start, deleteCount, ...items);
            updates["lyricFonts"] = reference["lyricFonts"];
            frozen["lyricFonts"].splice(start, deleteCount, ...items.map(i => true));
            return this;
        };
        this.pageLayout = (build) => {
            if (typeof build === 'function') {
                delete updates["pageLayout"];
                const builder = build(new PageLayoutBuilder(original && original["pageLayout"]));
                if (!original)
                    updates["pageLayout"] = builder.build();
                else
                    childBuilders["pageLayout"] = builder;
            }
            else {
                updates.pageLayout = build;
                delete childBuilders["pageLayout;"];
            }
            modifiedKeys["pageLayout"] = true;
            return this;
        };
        this.systemLayout = (build) => {
            if (typeof build === 'function') {
                delete updates["systemLayout"];
                const builder = build(new SystemLayoutBuilder(original && original["systemLayout"]));
                if (!original)
                    updates["systemLayout"] = builder.build();
                else
                    childBuilders["systemLayout"] = builder;
            }
            else {
                updates.systemLayout = build;
                delete childBuilders["systemLayout;"];
            }
            modifiedKeys["systemLayout"] = true;
            return this;
        };
        this.appearance = (build) => {
            if (typeof build === 'function') {
                delete updates["appearance"];
                const builder = build(new AppearanceBuilder(original && original["appearance"]));
                if (!original)
                    updates["appearance"] = builder.build();
                else
                    childBuilders["appearance"] = builder;
            }
            else {
                updates.appearance = build;
                delete childBuilders["appearance;"];
            }
            modifiedKeys["appearance"] = true;
            return this;
        };
        this.scaling = (build) => {
            if (typeof build === 'function') {
                delete updates["scaling"];
                const builder = build(new ScalingBuilder(original && original["scaling"]));
                if (!original)
                    updates["scaling"] = builder.build();
                else
                    childBuilders["scaling"] = builder;
            }
            else {
                updates.scaling = build;
                delete childBuilders["scaling;"];
            }
            modifiedKeys["scaling"] = true;
            return this;
        };
        this.staffLayouts = (spec) => {
            updates["staffLayouts"] = spec;
            delete childBuilders["staffLayouts;"];
            modifiedKeys["staffLayouts"] = true;
            return this;
        };
        this.staffLayoutsAt = (idx, build) => {
            makeReference("staffLayouts");
            if (frozen["staffLayouts"][idx]) {
                throw new Error("Patching staffLayouts." + idx + " twice in a builder is unsupported.");
            }
            if (original && original._snapshot && original._snapshot["staffLayouts"] && original._snapshot["staffLayouts"][idx] && !original["staffLayouts"][idx]) {
                // Clone snapshot.
                patches.push({ p: ["staffLayouts", idx], li: original._snapshot["staffLayouts"] });
            }
            if (typeof build === 'function' && reference["staffLayouts"][idx]) {
                let patch = build(new StaffLayoutBuilder(reference["staffLayouts"][idx])).patch();
                patches = patches.concat(patch.map(patch => {
                    // TODO: detach?
                    patch.p = ["staffLayouts", idx].concat(patch.p);
                    return patch;
                }));
                frozen["staffLayouts"][idx] = true;
                return this;
            }
            let update = typeof build === 'function' ? build(new StaffLayoutBuilder(reference["staffLayouts"][idx])).build() : build;
            if (original) {
                patches.push({ p: ["staffLayouts", idx], li: update });
            }
            else {
                updates["staffLayouts"] = reference["staffLayouts"]; // TODO: Merge?
            }
            reference["staffLayouts"][idx] = update;
            frozen["staffLayouts"][idx] = true;
            return this;
        };
        this.staffLayoutsSplice = (start, deleteCount, ...items) => {
            makeReference("staffLayouts");
            let idx = start;
            if (original) {
                for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
                    if (frozen["staffLayouts"][idx]) {
                        throw new Error("Replacing staffLayouts." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["staffLayouts"][idx];
                    patches.push({ p: ["staffLayouts", idx], ld, li: items[idx - start] });
                    frozen["staffLayouts"][idx] = true;
                }
                for (; idx < start + deleteCount; ++idx) {
                    if (frozen["staffLayouts"][idx]) {
                        throw new Error("Removing staffLayouts." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["staffLayouts"][idx];
                    patches.push({ p: ["staffLayouts", idx], ld });
                }
                for (; idx < start + items.length; ++idx) {
                    patches.push({ p: ["staffLayouts", idx], li: items[idx - start] });
                    frozen["staffLayouts"][idx] = true;
                }
            }
            reference["staffLayouts"].splice(start, deleteCount, ...items);
            updates["staffLayouts"] = reference["staffLayouts"];
            frozen["staffLayouts"].splice(start, deleteCount, ...items.map(i => true));
            return this;
        };
        this.musicFont = (build) => {
            if (typeof build === 'function') {
                delete updates["musicFont"];
                const builder = build(new MusicFontBuilder(original && original["musicFont"]));
                if (!original)
                    updates["musicFont"] = builder.build();
                else
                    childBuilders["musicFont"] = builder;
            }
            else {
                updates.musicFont = build;
                delete childBuilders["musicFont;"];
            }
            modifiedKeys["musicFont"] = true;
            return this;
        };
    }
}
function patchDefaults(base, builder) { return builder(new DefaultsBuilder(base)).patch(); }
exports.patchDefaults = patchDefaults;
function buildDefaults(builder) { return builder(new DefaultsBuilder()).build(); }
exports.buildDefaults = buildDefaults;
class MusicFontBuilder {
    build;
    patch;
    fontFamily;
    fontWeight;
    fontStyle;
    fontSize;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "MusicFont";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.fontFamily = (spec) => {
            updates["fontFamily"] = spec;
            delete childBuilders["fontFamily;"];
            modifiedKeys["fontFamily"] = true;
            return this;
        };
        this.fontWeight = (spec) => {
            updates["fontWeight"] = spec;
            delete childBuilders["fontWeight;"];
            modifiedKeys["fontWeight"] = true;
            return this;
        };
        this.fontStyle = (spec) => {
            updates["fontStyle"] = spec;
            delete childBuilders["fontStyle;"];
            modifiedKeys["fontStyle"] = true;
            return this;
        };
        this.fontSize = (spec) => {
            updates["fontSize"] = spec;
            delete childBuilders["fontSize;"];
            modifiedKeys["fontSize"] = true;
            return this;
        };
    }
}
function patchMusicFont(base, builder) { return builder(new MusicFontBuilder(base)).patch(); }
exports.patchMusicFont = patchMusicFont;
function buildMusicFont(builder) { return builder(new MusicFontBuilder()).build(); }
exports.buildMusicFont = buildMusicFont;
class WordFontBuilder {
    build;
    patch;
    fontFamily;
    fontWeight;
    fontStyle;
    fontSize;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "WordFont";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.fontFamily = (spec) => {
            updates["fontFamily"] = spec;
            delete childBuilders["fontFamily;"];
            modifiedKeys["fontFamily"] = true;
            return this;
        };
        this.fontWeight = (spec) => {
            updates["fontWeight"] = spec;
            delete childBuilders["fontWeight;"];
            modifiedKeys["fontWeight"] = true;
            return this;
        };
        this.fontStyle = (spec) => {
            updates["fontStyle"] = spec;
            delete childBuilders["fontStyle;"];
            modifiedKeys["fontStyle"] = true;
            return this;
        };
        this.fontSize = (spec) => {
            updates["fontSize"] = spec;
            delete childBuilders["fontSize;"];
            modifiedKeys["fontSize"] = true;
            return this;
        };
    }
}
function patchWordFont(base, builder) { return builder(new WordFontBuilder(base)).patch(); }
exports.patchWordFont = patchWordFont;
function buildWordFont(builder) { return builder(new WordFontBuilder()).build(); }
exports.buildWordFont = buildWordFont;
class LyricFontBuilder {
    build;
    patch;
    number;
    name;
    fontFamily;
    fontWeight;
    fontStyle;
    fontSize;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["number"]) ||
                childBuilders["number"] !== undefined ||
                updates.number !== undefined, "number is a required field");
            console.assert((original && !modifiedKeys["name"]) ||
                childBuilders["name"] !== undefined ||
                updates.name !== undefined, "name is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "LyricFont";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.number = (spec) => {
            updates["number"] = spec;
            delete childBuilders["number;"];
            modifiedKeys["number"] = true;
            return this;
        };
        this.name = (spec) => {
            updates["name"] = spec;
            delete childBuilders["name;"];
            modifiedKeys["name"] = true;
            return this;
        };
        this.fontFamily = (spec) => {
            updates["fontFamily"] = spec;
            delete childBuilders["fontFamily;"];
            modifiedKeys["fontFamily"] = true;
            return this;
        };
        this.fontWeight = (spec) => {
            updates["fontWeight"] = spec;
            delete childBuilders["fontWeight;"];
            modifiedKeys["fontWeight"] = true;
            return this;
        };
        this.fontStyle = (spec) => {
            updates["fontStyle"] = spec;
            delete childBuilders["fontStyle;"];
            modifiedKeys["fontStyle"] = true;
            return this;
        };
        this.fontSize = (spec) => {
            updates["fontSize"] = spec;
            delete childBuilders["fontSize;"];
            modifiedKeys["fontSize"] = true;
            return this;
        };
    }
}
function patchLyricFont(base, builder) { return builder(new LyricFontBuilder(base)).patch(); }
exports.patchLyricFont = patchLyricFont;
function buildLyricFont(builder) { return builder(new LyricFontBuilder()).build(); }
exports.buildLyricFont = buildLyricFont;
class LyricLanguageBuilder {
    build;
    patch;
    number;
    name;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["number"]) ||
                childBuilders["number"] !== undefined ||
                updates.number !== undefined, "number is a required field");
            console.assert((original && !modifiedKeys["name"]) ||
                childBuilders["name"] !== undefined ||
                updates.name !== undefined, "name is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "LyricLanguage";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.number = (spec) => {
            updates["number"] = spec;
            delete childBuilders["number;"];
            modifiedKeys["number"] = true;
            return this;
        };
        this.name = (spec) => {
            updates["name"] = spec;
            delete childBuilders["name;"];
            modifiedKeys["name"] = true;
            return this;
        };
    }
}
function patchLyricLanguage(base, builder) { return builder(new LyricLanguageBuilder(base)).patch(); }
exports.patchLyricLanguage = patchLyricLanguage;
function buildLyricLanguage(builder) { return builder(new LyricLanguageBuilder()).build(); }
exports.buildLyricLanguage = buildLyricLanguage;
class CreditBuilder {
    build;
    patch;
    creditTypes;
    creditWordsAt;
    creditWordsSplice;
    creditWords;
    creditImage;
    page;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["creditTypes"]) ||
                childBuilders["creditTypes"] !== undefined ||
                updates.creditTypes !== undefined, "creditTypes is a required field");
            console.assert((original && !modifiedKeys["creditWords"]) ||
                childBuilders["creditWords"] !== undefined ||
                updates.creditWords !== undefined, "creditWords is a required field");
            console.assert((original && !modifiedKeys["creditImage"]) ||
                childBuilders["creditImage"] !== undefined ||
                updates.creditImage !== undefined, "creditImage is a required field");
            console.assert((original && !modifiedKeys["page"]) ||
                childBuilders["page"] !== undefined ||
                updates.page !== undefined, "page is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Credit";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.creditTypes = (spec) => {
            updates["creditTypes"] = spec;
            delete childBuilders["creditTypes;"];
            modifiedKeys["creditTypes"] = true;
            return this;
        };
        this.creditWords = (spec) => {
            updates["creditWords"] = spec;
            delete childBuilders["creditWords;"];
            modifiedKeys["creditWords"] = true;
            return this;
        };
        this.creditWordsAt = (idx, build) => {
            makeReference("creditWords");
            if (frozen["creditWords"][idx]) {
                throw new Error("Patching creditWords." + idx + " twice in a builder is unsupported.");
            }
            if (original && original._snapshot && original._snapshot["creditWords"] && original._snapshot["creditWords"][idx] && !original["creditWords"][idx]) {
                // Clone snapshot.
                patches.push({ p: ["creditWords", idx], li: original._snapshot["creditWords"] });
            }
            if (typeof build === 'function' && reference["creditWords"][idx]) {
                let patch = build(new CreditWordsBuilder(reference["creditWords"][idx])).patch();
                patches = patches.concat(patch.map(patch => {
                    // TODO: detach?
                    patch.p = ["creditWords", idx].concat(patch.p);
                    return patch;
                }));
                frozen["creditWords"][idx] = true;
                return this;
            }
            let update = typeof build === 'function' ? build(new CreditWordsBuilder(reference["creditWords"][idx])).build() : build;
            if (original) {
                patches.push({ p: ["creditWords", idx], li: update });
            }
            else {
                updates["creditWords"] = reference["creditWords"]; // TODO: Merge?
            }
            reference["creditWords"][idx] = update;
            frozen["creditWords"][idx] = true;
            return this;
        };
        this.creditWordsSplice = (start, deleteCount, ...items) => {
            makeReference("creditWords");
            let idx = start;
            if (original) {
                for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
                    if (frozen["creditWords"][idx]) {
                        throw new Error("Replacing creditWords." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["creditWords"][idx];
                    patches.push({ p: ["creditWords", idx], ld, li: items[idx - start] });
                    frozen["creditWords"][idx] = true;
                }
                for (; idx < start + deleteCount; ++idx) {
                    if (frozen["creditWords"][idx]) {
                        throw new Error("Removing creditWords." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["creditWords"][idx];
                    patches.push({ p: ["creditWords", idx], ld });
                }
                for (; idx < start + items.length; ++idx) {
                    patches.push({ p: ["creditWords", idx], li: items[idx - start] });
                    frozen["creditWords"][idx] = true;
                }
            }
            reference["creditWords"].splice(start, deleteCount, ...items);
            updates["creditWords"] = reference["creditWords"];
            frozen["creditWords"].splice(start, deleteCount, ...items.map(i => true));
            return this;
        };
        this.creditImage = (build) => {
            if (typeof build === 'function') {
                delete updates["creditImage"];
                const builder = build(new CreditImageBuilder(original && original["creditImage"]));
                if (!original)
                    updates["creditImage"] = builder.build();
                else
                    childBuilders["creditImage"] = builder;
            }
            else {
                updates.creditImage = build;
                delete childBuilders["creditImage;"];
            }
            modifiedKeys["creditImage"] = true;
            return this;
        };
        this.page = (spec) => {
            updates["page"] = spec;
            delete childBuilders["page;"];
            modifiedKeys["page"] = true;
            return this;
        };
    }
}
function patchCredit(base, builder) { return builder(new CreditBuilder(base)).patch(); }
exports.patchCredit = patchCredit;
function buildCredit(builder) { return builder(new CreditBuilder()).build(); }
exports.buildCredit = buildCredit;
class CreditWordsBuilder {
    build;
    patch;
    words;
    justify;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    fontFamily;
    fontWeight;
    fontStyle;
    fontSize;
    color;
    halign;
    valign;
    underline;
    overline;
    lineThrough;
    rotation;
    letterSpacing;
    lineHeight;
    dir;
    enclosure;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["words"]) ||
                childBuilders["words"] !== undefined ||
                updates.words !== undefined, "words is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "CreditWords";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.words = (spec) => {
            updates["words"] = spec;
            delete childBuilders["words;"];
            modifiedKeys["words"] = true;
            return this;
        };
        this.justify = (spec) => {
            updates["justify"] = spec;
            delete childBuilders["justify;"];
            modifiedKeys["justify"] = true;
            return this;
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
        this.fontFamily = (spec) => {
            updates["fontFamily"] = spec;
            delete childBuilders["fontFamily;"];
            modifiedKeys["fontFamily"] = true;
            return this;
        };
        this.fontWeight = (spec) => {
            updates["fontWeight"] = spec;
            delete childBuilders["fontWeight;"];
            modifiedKeys["fontWeight"] = true;
            return this;
        };
        this.fontStyle = (spec) => {
            updates["fontStyle"] = spec;
            delete childBuilders["fontStyle;"];
            modifiedKeys["fontStyle"] = true;
            return this;
        };
        this.fontSize = (spec) => {
            updates["fontSize"] = spec;
            delete childBuilders["fontSize;"];
            modifiedKeys["fontSize"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
        this.halign = (spec) => {
            updates["halign"] = spec;
            delete childBuilders["halign;"];
            modifiedKeys["halign"] = true;
            return this;
        };
        this.valign = (spec) => {
            updates["valign"] = spec;
            delete childBuilders["valign;"];
            modifiedKeys["valign"] = true;
            return this;
        };
        this.underline = (spec) => {
            updates["underline"] = spec;
            delete childBuilders["underline;"];
            modifiedKeys["underline"] = true;
            return this;
        };
        this.overline = (spec) => {
            updates["overline"] = spec;
            delete childBuilders["overline;"];
            modifiedKeys["overline"] = true;
            return this;
        };
        this.lineThrough = (spec) => {
            updates["lineThrough"] = spec;
            delete childBuilders["lineThrough;"];
            modifiedKeys["lineThrough"] = true;
            return this;
        };
        this.rotation = (spec) => {
            updates["rotation"] = spec;
            delete childBuilders["rotation;"];
            modifiedKeys["rotation"] = true;
            return this;
        };
        this.letterSpacing = (spec) => {
            updates["letterSpacing"] = spec;
            delete childBuilders["letterSpacing;"];
            modifiedKeys["letterSpacing"] = true;
            return this;
        };
        this.lineHeight = (spec) => {
            updates["lineHeight"] = spec;
            delete childBuilders["lineHeight;"];
            modifiedKeys["lineHeight"] = true;
            return this;
        };
        this.dir = (spec) => {
            updates["dir"] = spec;
            delete childBuilders["dir;"];
            modifiedKeys["dir"] = true;
            return this;
        };
        this.enclosure = (spec) => {
            updates["enclosure"] = spec;
            delete childBuilders["enclosure;"];
            modifiedKeys["enclosure"] = true;
            return this;
        };
    }
}
function patchCreditWords(base, builder) { return builder(new CreditWordsBuilder(base)).patch(); }
exports.patchCreditWords = patchCreditWords;
function buildCreditWords(builder) { return builder(new CreditWordsBuilder()).build(); }
exports.buildCreditWords = buildCreditWords;
class CreditImageBuilder {
    build;
    patch;
    type;
    source;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    halign;
    valignImage;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["type"]) ||
                childBuilders["type"] !== undefined ||
                updates.type !== undefined, "type is a required field");
            console.assert((original && !modifiedKeys["source"]) ||
                childBuilders["source"] !== undefined ||
                updates.source !== undefined, "source is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "CreditImage";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.type = (spec) => {
            updates["type"] = spec;
            delete childBuilders["type;"];
            modifiedKeys["type"] = true;
            return this;
        };
        this.source = (spec) => {
            updates["source"] = spec;
            delete childBuilders["source;"];
            modifiedKeys["source"] = true;
            return this;
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
        this.halign = (spec) => {
            updates["halign"] = spec;
            delete childBuilders["halign;"];
            modifiedKeys["halign"] = true;
            return this;
        };
        this.valignImage = (spec) => {
            updates["valignImage"] = spec;
            delete childBuilders["valignImage;"];
            modifiedKeys["valignImage"] = true;
            return this;
        };
    }
}
function patchCreditImage(base, builder) { return builder(new CreditImageBuilder(base)).patch(); }
exports.patchCreditImage = patchCreditImage;
function buildCreditImage(builder) { return builder(new CreditImageBuilder()).build(); }
exports.buildCreditImage = buildCreditImage;
class ScorePartBuilder {
    build;
    patch;
    identification;
    partNameDisplay;
    scoreInstrumentsAt;
    scoreInstrumentsSplice;
    scoreInstruments;
    midiDevicesAt;
    midiDevicesSplice;
    midiDevices;
    partName;
    partAbbreviationDisplay;
    partAbbreviation;
    groups;
    midiInstrumentsAt;
    midiInstrumentsSplice;
    midiInstruments;
    id;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["partName"]) ||
                childBuilders["partName"] !== undefined ||
                updates.partName !== undefined, "partName is a required field");
            console.assert((original && !modifiedKeys["id"]) ||
                childBuilders["id"] !== undefined ||
                updates.id !== undefined, "id is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "ScorePart";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.identification = (build) => {
            if (typeof build === 'function') {
                delete updates["identification"];
                const builder = build(new IdentificationBuilder(original && original["identification"]));
                if (!original)
                    updates["identification"] = builder.build();
                else
                    childBuilders["identification"] = builder;
            }
            else {
                updates.identification = build;
                delete childBuilders["identification;"];
            }
            modifiedKeys["identification"] = true;
            return this;
        };
        this.partNameDisplay = (build) => {
            if (typeof build === 'function') {
                delete updates["partNameDisplay"];
                const builder = build(new PartNameDisplayBuilder(original && original["partNameDisplay"]));
                if (!original)
                    updates["partNameDisplay"] = builder.build();
                else
                    childBuilders["partNameDisplay"] = builder;
            }
            else {
                updates.partNameDisplay = build;
                delete childBuilders["partNameDisplay;"];
            }
            modifiedKeys["partNameDisplay"] = true;
            return this;
        };
        this.scoreInstruments = (spec) => {
            updates["scoreInstruments"] = spec;
            delete childBuilders["scoreInstruments;"];
            modifiedKeys["scoreInstruments"] = true;
            return this;
        };
        this.scoreInstrumentsAt = (idx, build) => {
            makeReference("scoreInstruments");
            if (frozen["scoreInstruments"][idx]) {
                throw new Error("Patching scoreInstruments." + idx + " twice in a builder is unsupported.");
            }
            if (original && original._snapshot && original._snapshot["scoreInstruments"] && original._snapshot["scoreInstruments"][idx] && !original["scoreInstruments"][idx]) {
                // Clone snapshot.
                patches.push({ p: ["scoreInstruments", idx], li: original._snapshot["scoreInstruments"] });
            }
            if (typeof build === 'function' && reference["scoreInstruments"][idx]) {
                let patch = build(new ScoreInstrumentBuilder(reference["scoreInstruments"][idx])).patch();
                patches = patches.concat(patch.map(patch => {
                    // TODO: detach?
                    patch.p = ["scoreInstruments", idx].concat(patch.p);
                    return patch;
                }));
                frozen["scoreInstruments"][idx] = true;
                return this;
            }
            let update = typeof build === 'function' ? build(new ScoreInstrumentBuilder(reference["scoreInstruments"][idx])).build() : build;
            if (original) {
                patches.push({ p: ["scoreInstruments", idx], li: update });
            }
            else {
                updates["scoreInstruments"] = reference["scoreInstruments"]; // TODO: Merge?
            }
            reference["scoreInstruments"][idx] = update;
            frozen["scoreInstruments"][idx] = true;
            return this;
        };
        this.scoreInstrumentsSplice = (start, deleteCount, ...items) => {
            makeReference("scoreInstruments");
            let idx = start;
            if (original) {
                for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
                    if (frozen["scoreInstruments"][idx]) {
                        throw new Error("Replacing scoreInstruments." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["scoreInstruments"][idx];
                    patches.push({ p: ["scoreInstruments", idx], ld, li: items[idx - start] });
                    frozen["scoreInstruments"][idx] = true;
                }
                for (; idx < start + deleteCount; ++idx) {
                    if (frozen["scoreInstruments"][idx]) {
                        throw new Error("Removing scoreInstruments." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["scoreInstruments"][idx];
                    patches.push({ p: ["scoreInstruments", idx], ld });
                }
                for (; idx < start + items.length; ++idx) {
                    patches.push({ p: ["scoreInstruments", idx], li: items[idx - start] });
                    frozen["scoreInstruments"][idx] = true;
                }
            }
            reference["scoreInstruments"].splice(start, deleteCount, ...items);
            updates["scoreInstruments"] = reference["scoreInstruments"];
            frozen["scoreInstruments"].splice(start, deleteCount, ...items.map(i => true));
            return this;
        };
        this.midiDevices = (spec) => {
            updates["midiDevices"] = spec;
            delete childBuilders["midiDevices;"];
            modifiedKeys["midiDevices"] = true;
            return this;
        };
        this.midiDevicesAt = (idx, build) => {
            makeReference("midiDevices");
            if (frozen["midiDevices"][idx]) {
                throw new Error("Patching midiDevices." + idx + " twice in a builder is unsupported.");
            }
            if (original && original._snapshot && original._snapshot["midiDevices"] && original._snapshot["midiDevices"][idx] && !original["midiDevices"][idx]) {
                // Clone snapshot.
                patches.push({ p: ["midiDevices", idx], li: original._snapshot["midiDevices"] });
            }
            if (typeof build === 'function' && reference["midiDevices"][idx]) {
                let patch = build(new MidiDeviceBuilder(reference["midiDevices"][idx])).patch();
                patches = patches.concat(patch.map(patch => {
                    // TODO: detach?
                    patch.p = ["midiDevices", idx].concat(patch.p);
                    return patch;
                }));
                frozen["midiDevices"][idx] = true;
                return this;
            }
            let update = typeof build === 'function' ? build(new MidiDeviceBuilder(reference["midiDevices"][idx])).build() : build;
            if (original) {
                patches.push({ p: ["midiDevices", idx], li: update });
            }
            else {
                updates["midiDevices"] = reference["midiDevices"]; // TODO: Merge?
            }
            reference["midiDevices"][idx] = update;
            frozen["midiDevices"][idx] = true;
            return this;
        };
        this.midiDevicesSplice = (start, deleteCount, ...items) => {
            makeReference("midiDevices");
            let idx = start;
            if (original) {
                for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
                    if (frozen["midiDevices"][idx]) {
                        throw new Error("Replacing midiDevices." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["midiDevices"][idx];
                    patches.push({ p: ["midiDevices", idx], ld, li: items[idx - start] });
                    frozen["midiDevices"][idx] = true;
                }
                for (; idx < start + deleteCount; ++idx) {
                    if (frozen["midiDevices"][idx]) {
                        throw new Error("Removing midiDevices." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["midiDevices"][idx];
                    patches.push({ p: ["midiDevices", idx], ld });
                }
                for (; idx < start + items.length; ++idx) {
                    patches.push({ p: ["midiDevices", idx], li: items[idx - start] });
                    frozen["midiDevices"][idx] = true;
                }
            }
            reference["midiDevices"].splice(start, deleteCount, ...items);
            updates["midiDevices"] = reference["midiDevices"];
            frozen["midiDevices"].splice(start, deleteCount, ...items.map(i => true));
            return this;
        };
        this.partName = (build) => {
            if (typeof build === 'function') {
                delete updates["partName"];
                const builder = build(new PartNameBuilder(original && original["partName"]));
                if (!original)
                    updates["partName"] = builder.build();
                else
                    childBuilders["partName"] = builder;
            }
            else {
                updates.partName = build;
                delete childBuilders["partName;"];
            }
            modifiedKeys["partName"] = true;
            return this;
        };
        this.partAbbreviationDisplay = (build) => {
            if (typeof build === 'function') {
                delete updates["partAbbreviationDisplay"];
                const builder = build(new PartAbbreviationDisplayBuilder(original && original["partAbbreviationDisplay"]));
                if (!original)
                    updates["partAbbreviationDisplay"] = builder.build();
                else
                    childBuilders["partAbbreviationDisplay"] = builder;
            }
            else {
                updates.partAbbreviationDisplay = build;
                delete childBuilders["partAbbreviationDisplay;"];
            }
            modifiedKeys["partAbbreviationDisplay"] = true;
            return this;
        };
        this.partAbbreviation = (build) => {
            if (typeof build === 'function') {
                delete updates["partAbbreviation"];
                const builder = build(new PartAbbreviationBuilder(original && original["partAbbreviation"]));
                if (!original)
                    updates["partAbbreviation"] = builder.build();
                else
                    childBuilders["partAbbreviation"] = builder;
            }
            else {
                updates.partAbbreviation = build;
                delete childBuilders["partAbbreviation;"];
            }
            modifiedKeys["partAbbreviation"] = true;
            return this;
        };
        this.groups = (spec) => {
            updates["groups"] = spec;
            delete childBuilders["groups;"];
            modifiedKeys["groups"] = true;
            return this;
        };
        this.midiInstruments = (spec) => {
            updates["midiInstruments"] = spec;
            delete childBuilders["midiInstruments;"];
            modifiedKeys["midiInstruments"] = true;
            return this;
        };
        this.midiInstrumentsAt = (idx, build) => {
            makeReference("midiInstruments");
            if (frozen["midiInstruments"][idx]) {
                throw new Error("Patching midiInstruments." + idx + " twice in a builder is unsupported.");
            }
            if (original && original._snapshot && original._snapshot["midiInstruments"] && original._snapshot["midiInstruments"][idx] && !original["midiInstruments"][idx]) {
                // Clone snapshot.
                patches.push({ p: ["midiInstruments", idx], li: original._snapshot["midiInstruments"] });
            }
            if (typeof build === 'function' && reference["midiInstruments"][idx]) {
                let patch = build(new MidiInstrumentBuilder(reference["midiInstruments"][idx])).patch();
                patches = patches.concat(patch.map(patch => {
                    // TODO: detach?
                    patch.p = ["midiInstruments", idx].concat(patch.p);
                    return patch;
                }));
                frozen["midiInstruments"][idx] = true;
                return this;
            }
            let update = typeof build === 'function' ? build(new MidiInstrumentBuilder(reference["midiInstruments"][idx])).build() : build;
            if (original) {
                patches.push({ p: ["midiInstruments", idx], li: update });
            }
            else {
                updates["midiInstruments"] = reference["midiInstruments"]; // TODO: Merge?
            }
            reference["midiInstruments"][idx] = update;
            frozen["midiInstruments"][idx] = true;
            return this;
        };
        this.midiInstrumentsSplice = (start, deleteCount, ...items) => {
            makeReference("midiInstruments");
            let idx = start;
            if (original) {
                for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
                    if (frozen["midiInstruments"][idx]) {
                        throw new Error("Replacing midiInstruments." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["midiInstruments"][idx];
                    patches.push({ p: ["midiInstruments", idx], ld, li: items[idx - start] });
                    frozen["midiInstruments"][idx] = true;
                }
                for (; idx < start + deleteCount; ++idx) {
                    if (frozen["midiInstruments"][idx]) {
                        throw new Error("Removing midiInstruments." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["midiInstruments"][idx];
                    patches.push({ p: ["midiInstruments", idx], ld });
                }
                for (; idx < start + items.length; ++idx) {
                    patches.push({ p: ["midiInstruments", idx], li: items[idx - start] });
                    frozen["midiInstruments"][idx] = true;
                }
            }
            reference["midiInstruments"].splice(start, deleteCount, ...items);
            updates["midiInstruments"] = reference["midiInstruments"];
            frozen["midiInstruments"].splice(start, deleteCount, ...items.map(i => true));
            return this;
        };
        this.id = (spec) => {
            updates["id"] = spec;
            delete childBuilders["id;"];
            modifiedKeys["id"] = true;
            return this;
        };
    }
}
function patchScorePart(base, builder) { return builder(new ScorePartBuilder(base)).patch(); }
exports.patchScorePart = patchScorePart;
function buildScorePart(builder) { return builder(new ScorePartBuilder()).build(); }
exports.buildScorePart = buildScorePart;
class PartNameBuilder {
    build;
    patch;
    partName;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    fontFamily;
    fontWeight;
    fontStyle;
    fontSize;
    color;
    printObject;
    justify;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["partName"]) ||
                childBuilders["partName"] !== undefined ||
                updates.partName !== undefined, "partName is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "PartName";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.partName = (spec) => {
            updates["partName"] = spec;
            delete childBuilders["partName;"];
            modifiedKeys["partName"] = true;
            return this;
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
        this.fontFamily = (spec) => {
            updates["fontFamily"] = spec;
            delete childBuilders["fontFamily;"];
            modifiedKeys["fontFamily"] = true;
            return this;
        };
        this.fontWeight = (spec) => {
            updates["fontWeight"] = spec;
            delete childBuilders["fontWeight;"];
            modifiedKeys["fontWeight"] = true;
            return this;
        };
        this.fontStyle = (spec) => {
            updates["fontStyle"] = spec;
            delete childBuilders["fontStyle;"];
            modifiedKeys["fontStyle"] = true;
            return this;
        };
        this.fontSize = (spec) => {
            updates["fontSize"] = spec;
            delete childBuilders["fontSize;"];
            modifiedKeys["fontSize"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
        this.printObject = (spec) => {
            updates["printObject"] = spec;
            delete childBuilders["printObject;"];
            modifiedKeys["printObject"] = true;
            return this;
        };
        this.justify = (spec) => {
            updates["justify"] = spec;
            delete childBuilders["justify;"];
            modifiedKeys["justify"] = true;
            return this;
        };
    }
}
function patchPartName(base, builder) { return builder(new PartNameBuilder(base)).patch(); }
exports.patchPartName = patchPartName;
function buildPartName(builder) { return builder(new PartNameBuilder()).build(); }
exports.buildPartName = buildPartName;
class PartAbbreviationBuilder {
    build;
    patch;
    abbreviation;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    fontFamily;
    fontWeight;
    fontStyle;
    fontSize;
    color;
    printObject;
    justify;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["abbreviation"]) ||
                childBuilders["abbreviation"] !== undefined ||
                updates.abbreviation !== undefined, "abbreviation is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "PartAbbreviation";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.abbreviation = (spec) => {
            updates["abbreviation"] = spec;
            delete childBuilders["abbreviation;"];
            modifiedKeys["abbreviation"] = true;
            return this;
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
        this.fontFamily = (spec) => {
            updates["fontFamily"] = spec;
            delete childBuilders["fontFamily;"];
            modifiedKeys["fontFamily"] = true;
            return this;
        };
        this.fontWeight = (spec) => {
            updates["fontWeight"] = spec;
            delete childBuilders["fontWeight;"];
            modifiedKeys["fontWeight"] = true;
            return this;
        };
        this.fontStyle = (spec) => {
            updates["fontStyle"] = spec;
            delete childBuilders["fontStyle;"];
            modifiedKeys["fontStyle"] = true;
            return this;
        };
        this.fontSize = (spec) => {
            updates["fontSize"] = spec;
            delete childBuilders["fontSize;"];
            modifiedKeys["fontSize"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
        this.printObject = (spec) => {
            updates["printObject"] = spec;
            delete childBuilders["printObject;"];
            modifiedKeys["printObject"] = true;
            return this;
        };
        this.justify = (spec) => {
            updates["justify"] = spec;
            delete childBuilders["justify;"];
            modifiedKeys["justify"] = true;
            return this;
        };
    }
}
function patchPartAbbreviation(base, builder) { return builder(new PartAbbreviationBuilder(base)).patch(); }
exports.patchPartAbbreviation = patchPartAbbreviation;
function buildPartAbbreviation(builder) { return builder(new PartAbbreviationBuilder()).build(); }
exports.buildPartAbbreviation = buildPartAbbreviation;
class PartGroupBuilder {
    build;
    patch;
    groupNameDisplay;
    groupSymbol;
    groupName;
    groupAbbreviationDisplay;
    groupBarline;
    number;
    groupAbbreviation;
    type;
    groupTime;
    footnote;
    level;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["groupNameDisplay"]) ||
                childBuilders["groupNameDisplay"] !== undefined ||
                updates.groupNameDisplay !== undefined, "groupNameDisplay is a required field");
            console.assert((original && !modifiedKeys["groupSymbol"]) ||
                childBuilders["groupSymbol"] !== undefined ||
                updates.groupSymbol !== undefined, "groupSymbol is a required field");
            console.assert((original && !modifiedKeys["groupName"]) ||
                childBuilders["groupName"] !== undefined ||
                updates.groupName !== undefined, "groupName is a required field");
            console.assert((original && !modifiedKeys["groupAbbreviationDisplay"]) ||
                childBuilders["groupAbbreviationDisplay"] !== undefined ||
                updates.groupAbbreviationDisplay !== undefined, "groupAbbreviationDisplay is a required field");
            console.assert((original && !modifiedKeys["groupBarline"]) ||
                childBuilders["groupBarline"] !== undefined ||
                updates.groupBarline !== undefined, "groupBarline is a required field");
            console.assert((original && !modifiedKeys["number"]) ||
                childBuilders["number"] !== undefined ||
                updates.number !== undefined, "number is a required field");
            console.assert((original && !modifiedKeys["groupAbbreviation"]) ||
                childBuilders["groupAbbreviation"] !== undefined ||
                updates.groupAbbreviation !== undefined, "groupAbbreviation is a required field");
            console.assert((original && !modifiedKeys["type"]) ||
                childBuilders["type"] !== undefined ||
                updates.type !== undefined, "type is a required field");
            console.assert((original && !modifiedKeys["groupTime"]) ||
                childBuilders["groupTime"] !== undefined ||
                updates.groupTime !== undefined, "groupTime is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "PartGroup";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.groupNameDisplay = (build) => {
            if (typeof build === 'function') {
                delete updates["groupNameDisplay"];
                const builder = build(new GroupNameDisplayBuilder(original && original["groupNameDisplay"]));
                if (!original)
                    updates["groupNameDisplay"] = builder.build();
                else
                    childBuilders["groupNameDisplay"] = builder;
            }
            else {
                updates.groupNameDisplay = build;
                delete childBuilders["groupNameDisplay;"];
            }
            modifiedKeys["groupNameDisplay"] = true;
            return this;
        };
        this.groupSymbol = (build) => {
            if (typeof build === 'function') {
                delete updates["groupSymbol"];
                const builder = build(new GroupSymbolBuilder(original && original["groupSymbol"]));
                if (!original)
                    updates["groupSymbol"] = builder.build();
                else
                    childBuilders["groupSymbol"] = builder;
            }
            else {
                updates.groupSymbol = build;
                delete childBuilders["groupSymbol;"];
            }
            modifiedKeys["groupSymbol"] = true;
            return this;
        };
        this.groupName = (build) => {
            if (typeof build === 'function') {
                delete updates["groupName"];
                const builder = build(new GroupNameBuilder(original && original["groupName"]));
                if (!original)
                    updates["groupName"] = builder.build();
                else
                    childBuilders["groupName"] = builder;
            }
            else {
                updates.groupName = build;
                delete childBuilders["groupName;"];
            }
            modifiedKeys["groupName"] = true;
            return this;
        };
        this.groupAbbreviationDisplay = (build) => {
            if (typeof build === 'function') {
                delete updates["groupAbbreviationDisplay"];
                const builder = build(new GroupAbbreviationDisplayBuilder(original && original["groupAbbreviationDisplay"]));
                if (!original)
                    updates["groupAbbreviationDisplay"] = builder.build();
                else
                    childBuilders["groupAbbreviationDisplay"] = builder;
            }
            else {
                updates.groupAbbreviationDisplay = build;
                delete childBuilders["groupAbbreviationDisplay;"];
            }
            modifiedKeys["groupAbbreviationDisplay"] = true;
            return this;
        };
        this.groupBarline = (build) => {
            if (typeof build === 'function') {
                delete updates["groupBarline"];
                const builder = build(new GroupBarlineBuilder(original && original["groupBarline"]));
                if (!original)
                    updates["groupBarline"] = builder.build();
                else
                    childBuilders["groupBarline"] = builder;
            }
            else {
                updates.groupBarline = build;
                delete childBuilders["groupBarline;"];
            }
            modifiedKeys["groupBarline"] = true;
            return this;
        };
        this.number = (spec) => {
            updates["number"] = spec;
            delete childBuilders["number;"];
            modifiedKeys["number"] = true;
            return this;
        };
        this.groupAbbreviation = (build) => {
            if (typeof build === 'function') {
                delete updates["groupAbbreviation"];
                const builder = build(new GroupAbbreviationBuilder(original && original["groupAbbreviation"]));
                if (!original)
                    updates["groupAbbreviation"] = builder.build();
                else
                    childBuilders["groupAbbreviation"] = builder;
            }
            else {
                updates.groupAbbreviation = build;
                delete childBuilders["groupAbbreviation;"];
            }
            modifiedKeys["groupAbbreviation"] = true;
            return this;
        };
        this.type = (spec) => {
            updates["type"] = spec;
            delete childBuilders["type;"];
            modifiedKeys["type"] = true;
            return this;
        };
        this.groupTime = (build) => {
            if (typeof build === 'function') {
                delete updates["groupTime"];
                const builder = build(new GroupTimeBuilder(original && original["groupTime"]));
                if (!original)
                    updates["groupTime"] = builder.build();
                else
                    childBuilders["groupTime"] = builder;
            }
            else {
                updates.groupTime = build;
                delete childBuilders["groupTime;"];
            }
            modifiedKeys["groupTime"] = true;
            return this;
        };
        this.footnote = (build) => {
            if (typeof build === 'function') {
                delete updates["footnote"];
                const builder = build(new FootnoteBuilder(original && original["footnote"]));
                if (!original)
                    updates["footnote"] = builder.build();
                else
                    childBuilders["footnote"] = builder;
            }
            else {
                updates.footnote = build;
                delete childBuilders["footnote;"];
            }
            modifiedKeys["footnote"] = true;
            return this;
        };
        this.level = (build) => {
            if (typeof build === 'function') {
                delete updates["level"];
                const builder = build(new LevelBuilder(original && original["level"]));
                if (!original)
                    updates["level"] = builder.build();
                else
                    childBuilders["level"] = builder;
            }
            else {
                updates.level = build;
                delete childBuilders["level;"];
            }
            modifiedKeys["level"] = true;
            return this;
        };
    }
}
function patchPartGroup(base, builder) { return builder(new PartGroupBuilder(base)).patch(); }
exports.patchPartGroup = patchPartGroup;
function buildPartGroup(builder) { return builder(new PartGroupBuilder()).build(); }
exports.buildPartGroup = buildPartGroup;
class GroupNameBuilder {
    build;
    patch;
    name;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    fontFamily;
    fontWeight;
    fontStyle;
    fontSize;
    color;
    justify;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["name"]) ||
                childBuilders["name"] !== undefined ||
                updates.name !== undefined, "name is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "GroupName";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.name = (spec) => {
            updates["name"] = spec;
            delete childBuilders["name;"];
            modifiedKeys["name"] = true;
            return this;
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
        this.fontFamily = (spec) => {
            updates["fontFamily"] = spec;
            delete childBuilders["fontFamily;"];
            modifiedKeys["fontFamily"] = true;
            return this;
        };
        this.fontWeight = (spec) => {
            updates["fontWeight"] = spec;
            delete childBuilders["fontWeight;"];
            modifiedKeys["fontWeight"] = true;
            return this;
        };
        this.fontStyle = (spec) => {
            updates["fontStyle"] = spec;
            delete childBuilders["fontStyle;"];
            modifiedKeys["fontStyle"] = true;
            return this;
        };
        this.fontSize = (spec) => {
            updates["fontSize"] = spec;
            delete childBuilders["fontSize;"];
            modifiedKeys["fontSize"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
        this.justify = (spec) => {
            updates["justify"] = spec;
            delete childBuilders["justify;"];
            modifiedKeys["justify"] = true;
            return this;
        };
    }
}
function patchGroupName(base, builder) { return builder(new GroupNameBuilder(base)).patch(); }
exports.patchGroupName = patchGroupName;
function buildGroupName(builder) { return builder(new GroupNameBuilder()).build(); }
exports.buildGroupName = buildGroupName;
class GroupNameDisplayBuilder {
    build;
    patch;
    nameAt;
    nameSplice;
    name;
    printObject;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["name"]) ||
                childBuilders["name"] !== undefined ||
                updates.name !== undefined, "name is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "GroupNameDisplay";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.name = (spec) => {
            updates["name"] = spec;
            delete childBuilders["name;"];
            modifiedKeys["name"] = true;
            return this;
        };
        this.nameAt = (idx, build) => {
            makeReference("name");
            if (frozen["name"][idx]) {
                throw new Error("Patching name." + idx + " twice in a builder is unsupported.");
            }
            if (original && original._snapshot && original._snapshot["name"] && original._snapshot["name"][idx] && !original["name"][idx]) {
                // Clone snapshot.
                patches.push({ p: ["name", idx], li: original._snapshot["name"] });
            }
            if (typeof build === 'function' && reference["name"][idx]) {
                let patch = build(new TextSegmentBuilder(reference["name"][idx])).patch();
                patches = patches.concat(patch.map(patch => {
                    // TODO: detach?
                    patch.p = ["name", idx].concat(patch.p);
                    return patch;
                }));
                frozen["name"][idx] = true;
                return this;
            }
            let update = typeof build === 'function' ? build(new TextSegmentBuilder(reference["name"][idx])).build() : build;
            if (original) {
                patches.push({ p: ["name", idx], li: update });
            }
            else {
                updates["name"] = reference["name"]; // TODO: Merge?
            }
            reference["name"][idx] = update;
            frozen["name"][idx] = true;
            return this;
        };
        this.nameSplice = (start, deleteCount, ...items) => {
            makeReference("name");
            let idx = start;
            if (original) {
                for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
                    if (frozen["name"][idx]) {
                        throw new Error("Replacing name." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["name"][idx];
                    patches.push({ p: ["name", idx], ld, li: items[idx - start] });
                    frozen["name"][idx] = true;
                }
                for (; idx < start + deleteCount; ++idx) {
                    if (frozen["name"][idx]) {
                        throw new Error("Removing name." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["name"][idx];
                    patches.push({ p: ["name", idx], ld });
                }
                for (; idx < start + items.length; ++idx) {
                    patches.push({ p: ["name", idx], li: items[idx - start] });
                    frozen["name"][idx] = true;
                }
            }
            reference["name"].splice(start, deleteCount, ...items);
            updates["name"] = reference["name"];
            frozen["name"].splice(start, deleteCount, ...items.map(i => true));
            return this;
        };
        this.printObject = (spec) => {
            updates["printObject"] = spec;
            delete childBuilders["printObject;"];
            modifiedKeys["printObject"] = true;
            return this;
        };
    }
}
function patchGroupNameDisplay(base, builder) { return builder(new GroupNameDisplayBuilder(base)).patch(); }
exports.patchGroupNameDisplay = patchGroupNameDisplay;
function buildGroupNameDisplay(builder) { return builder(new GroupNameDisplayBuilder()).build(); }
exports.buildGroupNameDisplay = buildGroupNameDisplay;
class GroupAbbreviationBuilder {
    build;
    patch;
    text;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    fontFamily;
    fontWeight;
    fontStyle;
    fontSize;
    color;
    justify;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["text"]) ||
                childBuilders["text"] !== undefined ||
                updates.text !== undefined, "text is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "GroupAbbreviation";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.text = (spec) => {
            updates["text"] = spec;
            delete childBuilders["text;"];
            modifiedKeys["text"] = true;
            return this;
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
        this.fontFamily = (spec) => {
            updates["fontFamily"] = spec;
            delete childBuilders["fontFamily;"];
            modifiedKeys["fontFamily"] = true;
            return this;
        };
        this.fontWeight = (spec) => {
            updates["fontWeight"] = spec;
            delete childBuilders["fontWeight;"];
            modifiedKeys["fontWeight"] = true;
            return this;
        };
        this.fontStyle = (spec) => {
            updates["fontStyle"] = spec;
            delete childBuilders["fontStyle;"];
            modifiedKeys["fontStyle"] = true;
            return this;
        };
        this.fontSize = (spec) => {
            updates["fontSize"] = spec;
            delete childBuilders["fontSize;"];
            modifiedKeys["fontSize"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
        this.justify = (spec) => {
            updates["justify"] = spec;
            delete childBuilders["justify;"];
            modifiedKeys["justify"] = true;
            return this;
        };
    }
}
function patchGroupAbbreviation(base, builder) { return builder(new GroupAbbreviationBuilder(base)).patch(); }
exports.patchGroupAbbreviation = patchGroupAbbreviation;
function buildGroupAbbreviation(builder) { return builder(new GroupAbbreviationBuilder()).build(); }
exports.buildGroupAbbreviation = buildGroupAbbreviation;
class GroupAbbreviationDisplayBuilder {
    build;
    patch;
    nameAt;
    nameSplice;
    name;
    printObject;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["name"]) ||
                childBuilders["name"] !== undefined ||
                updates.name !== undefined, "name is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "GroupAbbreviationDisplay";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.name = (spec) => {
            updates["name"] = spec;
            delete childBuilders["name;"];
            modifiedKeys["name"] = true;
            return this;
        };
        this.nameAt = (idx, build) => {
            makeReference("name");
            if (frozen["name"][idx]) {
                throw new Error("Patching name." + idx + " twice in a builder is unsupported.");
            }
            if (original && original._snapshot && original._snapshot["name"] && original._snapshot["name"][idx] && !original["name"][idx]) {
                // Clone snapshot.
                patches.push({ p: ["name", idx], li: original._snapshot["name"] });
            }
            if (typeof build === 'function' && reference["name"][idx]) {
                let patch = build(new TextSegmentBuilder(reference["name"][idx])).patch();
                patches = patches.concat(patch.map(patch => {
                    // TODO: detach?
                    patch.p = ["name", idx].concat(patch.p);
                    return patch;
                }));
                frozen["name"][idx] = true;
                return this;
            }
            let update = typeof build === 'function' ? build(new TextSegmentBuilder(reference["name"][idx])).build() : build;
            if (original) {
                patches.push({ p: ["name", idx], li: update });
            }
            else {
                updates["name"] = reference["name"]; // TODO: Merge?
            }
            reference["name"][idx] = update;
            frozen["name"][idx] = true;
            return this;
        };
        this.nameSplice = (start, deleteCount, ...items) => {
            makeReference("name");
            let idx = start;
            if (original) {
                for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
                    if (frozen["name"][idx]) {
                        throw new Error("Replacing name." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["name"][idx];
                    patches.push({ p: ["name", idx], ld, li: items[idx - start] });
                    frozen["name"][idx] = true;
                }
                for (; idx < start + deleteCount; ++idx) {
                    if (frozen["name"][idx]) {
                        throw new Error("Removing name." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["name"][idx];
                    patches.push({ p: ["name", idx], ld });
                }
                for (; idx < start + items.length; ++idx) {
                    patches.push({ p: ["name", idx], li: items[idx - start] });
                    frozen["name"][idx] = true;
                }
            }
            reference["name"].splice(start, deleteCount, ...items);
            updates["name"] = reference["name"];
            frozen["name"].splice(start, deleteCount, ...items.map(i => true));
            return this;
        };
        this.printObject = (spec) => {
            updates["printObject"] = spec;
            delete childBuilders["printObject;"];
            modifiedKeys["printObject"] = true;
            return this;
        };
    }
}
function patchGroupAbbreviationDisplay(base, builder) { return builder(new GroupAbbreviationDisplayBuilder(base)).patch(); }
exports.patchGroupAbbreviationDisplay = patchGroupAbbreviationDisplay;
function buildGroupAbbreviationDisplay(builder) { return builder(new GroupAbbreviationDisplayBuilder()).build(); }
exports.buildGroupAbbreviationDisplay = buildGroupAbbreviationDisplay;
class GroupSymbolBuilder {
    build;
    patch;
    data;
    defaultX;
    relativeY;
    defaultY;
    relativeX;
    color;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["data"]) ||
                childBuilders["data"] !== undefined ||
                updates.data !== undefined, "data is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "GroupSymbol";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.data = (spec) => {
            updates["data"] = spec;
            delete childBuilders["data;"];
            modifiedKeys["data"] = true;
            return this;
        };
        this.defaultX = (spec) => {
            updates["defaultX"] = spec;
            delete childBuilders["defaultX;"];
            modifiedKeys["defaultX"] = true;
            return this;
        };
        this.relativeY = (spec) => {
            updates["relativeY"] = spec;
            delete childBuilders["relativeY;"];
            modifiedKeys["relativeY"] = true;
            return this;
        };
        this.defaultY = (spec) => {
            updates["defaultY"] = spec;
            delete childBuilders["defaultY;"];
            modifiedKeys["defaultY"] = true;
            return this;
        };
        this.relativeX = (spec) => {
            updates["relativeX"] = spec;
            delete childBuilders["relativeX;"];
            modifiedKeys["relativeX"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
    }
}
function patchGroupSymbol(base, builder) { return builder(new GroupSymbolBuilder(base)).patch(); }
exports.patchGroupSymbol = patchGroupSymbol;
function buildGroupSymbol(builder) { return builder(new GroupSymbolBuilder()).build(); }
exports.buildGroupSymbol = buildGroupSymbol;
class GroupBarlineBuilder {
    build;
    patch;
    data;
    color;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["data"]) ||
                childBuilders["data"] !== undefined ||
                updates.data !== undefined, "data is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "GroupBarline";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.data = (spec) => {
            updates["data"] = spec;
            delete childBuilders["data;"];
            modifiedKeys["data"] = true;
            return this;
        };
        this.color = (spec) => {
            updates["color"] = spec;
            delete childBuilders["color;"];
            modifiedKeys["color"] = true;
            return this;
        };
    }
}
function patchGroupBarline(base, builder) { return builder(new GroupBarlineBuilder(base)).patch(); }
exports.patchGroupBarline = patchGroupBarline;
function buildGroupBarline(builder) { return builder(new GroupBarlineBuilder()).build(); }
exports.buildGroupBarline = buildGroupBarline;
class GroupTimeBuilder {
    build;
    patch;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "GroupTime";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
    }
}
function patchGroupTime(base, builder) { return builder(new GroupTimeBuilder(base)).patch(); }
exports.patchGroupTime = patchGroupTime;
function buildGroupTime(builder) { return builder(new GroupTimeBuilder()).build(); }
exports.buildGroupTime = buildGroupTime;
class ScoreInstrumentBuilder {
    build;
    patch;
    instrumentName;
    instrumentSound;
    ensemble;
    virtualInstrument;
    instrumentAbbreviation;
    solo;
    id;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["instrumentName"]) ||
                childBuilders["instrumentName"] !== undefined ||
                updates.instrumentName !== undefined, "instrumentName is a required field");
            console.assert((original && !modifiedKeys["id"]) ||
                childBuilders["id"] !== undefined ||
                updates.id !== undefined, "id is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "ScoreInstrument";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.instrumentName = (spec) => {
            updates["instrumentName"] = spec;
            delete childBuilders["instrumentName;"];
            modifiedKeys["instrumentName"] = true;
            return this;
        };
        this.instrumentSound = (spec) => {
            updates["instrumentSound"] = spec;
            delete childBuilders["instrumentSound;"];
            modifiedKeys["instrumentSound"] = true;
            return this;
        };
        this.ensemble = (spec) => {
            updates["ensemble"] = spec;
            delete childBuilders["ensemble;"];
            modifiedKeys["ensemble"] = true;
            return this;
        };
        this.virtualInstrument = (build) => {
            if (typeof build === 'function') {
                delete updates["virtualInstrument"];
                const builder = build(new VirtualInstrumentBuilder(original && original["virtualInstrument"]));
                if (!original)
                    updates["virtualInstrument"] = builder.build();
                else
                    childBuilders["virtualInstrument"] = builder;
            }
            else {
                updates.virtualInstrument = build;
                delete childBuilders["virtualInstrument;"];
            }
            modifiedKeys["virtualInstrument"] = true;
            return this;
        };
        this.instrumentAbbreviation = (spec) => {
            updates["instrumentAbbreviation"] = spec;
            delete childBuilders["instrumentAbbreviation;"];
            modifiedKeys["instrumentAbbreviation"] = true;
            return this;
        };
        this.solo = (build) => {
            if (typeof build === 'function') {
                delete updates["solo"];
                const builder = build(new SoloBuilder(original && original["solo"]));
                if (!original)
                    updates["solo"] = builder.build();
                else
                    childBuilders["solo"] = builder;
            }
            else {
                updates.solo = build;
                delete childBuilders["solo;"];
            }
            modifiedKeys["solo"] = true;
            return this;
        };
        this.id = (spec) => {
            updates["id"] = spec;
            delete childBuilders["id;"];
            modifiedKeys["id"] = true;
            return this;
        };
    }
}
function patchScoreInstrument(base, builder) { return builder(new ScoreInstrumentBuilder(base)).patch(); }
exports.patchScoreInstrument = patchScoreInstrument;
function buildScoreInstrument(builder) { return builder(new ScoreInstrumentBuilder()).build(); }
exports.buildScoreInstrument = buildScoreInstrument;
class SoloBuilder {
    build;
    patch;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Solo";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
    }
}
function patchSolo(base, builder) { return builder(new SoloBuilder(base)).patch(); }
exports.patchSolo = patchSolo;
function buildSolo(builder) { return builder(new SoloBuilder()).build(); }
exports.buildSolo = buildSolo;
class VirtualInstrumentBuilder {
    build;
    patch;
    virtualLibrary;
    virtualName;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["virtualLibrary"]) ||
                childBuilders["virtualLibrary"] !== undefined ||
                updates.virtualLibrary !== undefined, "virtualLibrary is a required field");
            console.assert((original && !modifiedKeys["virtualName"]) ||
                childBuilders["virtualName"] !== undefined ||
                updates.virtualName !== undefined, "virtualName is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "VirtualInstrument";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.virtualLibrary = (spec) => {
            updates["virtualLibrary"] = spec;
            delete childBuilders["virtualLibrary;"];
            modifiedKeys["virtualLibrary"] = true;
            return this;
        };
        this.virtualName = (spec) => {
            updates["virtualName"] = spec;
            delete childBuilders["virtualName;"];
            modifiedKeys["virtualName"] = true;
            return this;
        };
    }
}
function patchVirtualInstrument(base, builder) { return builder(new VirtualInstrumentBuilder(base)).patch(); }
exports.patchVirtualInstrument = patchVirtualInstrument;
function buildVirtualInstrument(builder) { return builder(new VirtualInstrumentBuilder()).build(); }
exports.buildVirtualInstrument = buildVirtualInstrument;
class ScoreHeaderBuilder {
    build;
    patch;
    movementTitle;
    identification;
    defaults;
    work;
    creditsAt;
    creditsSplice;
    credits;
    partList;
    movementNumber;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["movementTitle"]) ||
                childBuilders["movementTitle"] !== undefined ||
                updates.movementTitle !== undefined, "movementTitle is a required field");
            console.assert((original && !modifiedKeys["identification"]) ||
                childBuilders["identification"] !== undefined ||
                updates.identification !== undefined, "identification is a required field");
            console.assert((original && !modifiedKeys["defaults"]) ||
                childBuilders["defaults"] !== undefined ||
                updates.defaults !== undefined, "defaults is a required field");
            console.assert((original && !modifiedKeys["work"]) ||
                childBuilders["work"] !== undefined ||
                updates.work !== undefined, "work is a required field");
            console.assert((original && !modifiedKeys["credits"]) ||
                childBuilders["credits"] !== undefined ||
                updates.credits !== undefined, "credits is a required field");
            console.assert((original && !modifiedKeys["partList"]) ||
                childBuilders["partList"] !== undefined ||
                updates.partList !== undefined, "partList is a required field");
            console.assert((original && !modifiedKeys["movementNumber"]) ||
                childBuilders["movementNumber"] !== undefined ||
                updates.movementNumber !== undefined, "movementNumber is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "ScoreHeader";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.movementTitle = (spec) => {
            updates["movementTitle"] = spec;
            delete childBuilders["movementTitle;"];
            modifiedKeys["movementTitle"] = true;
            return this;
        };
        this.identification = (build) => {
            if (typeof build === 'function') {
                delete updates["identification"];
                const builder = build(new IdentificationBuilder(original && original["identification"]));
                if (!original)
                    updates["identification"] = builder.build();
                else
                    childBuilders["identification"] = builder;
            }
            else {
                updates.identification = build;
                delete childBuilders["identification;"];
            }
            modifiedKeys["identification"] = true;
            return this;
        };
        this.defaults = (build) => {
            if (typeof build === 'function') {
                delete updates["defaults"];
                const builder = build(new DefaultsBuilder(original && original["defaults"]));
                if (!original)
                    updates["defaults"] = builder.build();
                else
                    childBuilders["defaults"] = builder;
            }
            else {
                updates.defaults = build;
                delete childBuilders["defaults;"];
            }
            modifiedKeys["defaults"] = true;
            return this;
        };
        this.work = (build) => {
            if (typeof build === 'function') {
                delete updates["work"];
                const builder = build(new WorkBuilder(original && original["work"]));
                if (!original)
                    updates["work"] = builder.build();
                else
                    childBuilders["work"] = builder;
            }
            else {
                updates.work = build;
                delete childBuilders["work;"];
            }
            modifiedKeys["work"] = true;
            return this;
        };
        this.credits = (spec) => {
            updates["credits"] = spec;
            delete childBuilders["credits;"];
            modifiedKeys["credits"] = true;
            return this;
        };
        this.creditsAt = (idx, build) => {
            makeReference("credits");
            if (frozen["credits"][idx]) {
                throw new Error("Patching credits." + idx + " twice in a builder is unsupported.");
            }
            if (original && original._snapshot && original._snapshot["credits"] && original._snapshot["credits"][idx] && !original["credits"][idx]) {
                // Clone snapshot.
                patches.push({ p: ["credits", idx], li: original._snapshot["credits"] });
            }
            if (typeof build === 'function' && reference["credits"][idx]) {
                let patch = build(new CreditBuilder(reference["credits"][idx])).patch();
                patches = patches.concat(patch.map(patch => {
                    // TODO: detach?
                    patch.p = ["credits", idx].concat(patch.p);
                    return patch;
                }));
                frozen["credits"][idx] = true;
                return this;
            }
            let update = typeof build === 'function' ? build(new CreditBuilder(reference["credits"][idx])).build() : build;
            if (original) {
                patches.push({ p: ["credits", idx], li: update });
            }
            else {
                updates["credits"] = reference["credits"]; // TODO: Merge?
            }
            reference["credits"][idx] = update;
            frozen["credits"][idx] = true;
            return this;
        };
        this.creditsSplice = (start, deleteCount, ...items) => {
            makeReference("credits");
            let idx = start;
            if (original) {
                for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
                    if (frozen["credits"][idx]) {
                        throw new Error("Replacing credits." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["credits"][idx];
                    patches.push({ p: ["credits", idx], ld, li: items[idx - start] });
                    frozen["credits"][idx] = true;
                }
                for (; idx < start + deleteCount; ++idx) {
                    if (frozen["credits"][idx]) {
                        throw new Error("Removing credits." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["credits"][idx];
                    patches.push({ p: ["credits", idx], ld });
                }
                for (; idx < start + items.length; ++idx) {
                    patches.push({ p: ["credits", idx], li: items[idx - start] });
                    frozen["credits"][idx] = true;
                }
            }
            reference["credits"].splice(start, deleteCount, ...items);
            updates["credits"] = reference["credits"];
            frozen["credits"].splice(start, deleteCount, ...items.map(i => true));
            return this;
        };
        this.partList = (spec) => {
            updates["partList"] = spec;
            delete childBuilders["partList;"];
            modifiedKeys["partList"] = true;
            return this;
        };
        this.movementNumber = (spec) => {
            updates["movementNumber"] = spec;
            delete childBuilders["movementNumber;"];
            modifiedKeys["movementNumber"] = true;
            return this;
        };
    }
}
function patchScoreHeader(base, builder) { return builder(new ScoreHeaderBuilder(base)).patch(); }
exports.patchScoreHeader = patchScoreHeader;
function buildScoreHeader(builder) { return builder(new ScoreHeaderBuilder()).build(); }
exports.buildScoreHeader = buildScoreHeader;
class ScoreTimewiseBuilder {
    build;
    patch;
    measuresAt;
    measuresSplice;
    measures;
    version;
    movementTitle;
    identification;
    defaults;
    work;
    creditsAt;
    creditsSplice;
    credits;
    partList;
    movementNumber;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["measures"]) ||
                childBuilders["measures"] !== undefined ||
                updates.measures !== undefined, "measures is a required field");
            console.assert((original && !modifiedKeys["version"]) ||
                childBuilders["version"] !== undefined ||
                updates.version !== undefined, "version is a required field");
            console.assert((original && !modifiedKeys["movementTitle"]) ||
                childBuilders["movementTitle"] !== undefined ||
                updates.movementTitle !== undefined, "movementTitle is a required field");
            console.assert((original && !modifiedKeys["identification"]) ||
                childBuilders["identification"] !== undefined ||
                updates.identification !== undefined, "identification is a required field");
            console.assert((original && !modifiedKeys["defaults"]) ||
                childBuilders["defaults"] !== undefined ||
                updates.defaults !== undefined, "defaults is a required field");
            console.assert((original && !modifiedKeys["work"]) ||
                childBuilders["work"] !== undefined ||
                updates.work !== undefined, "work is a required field");
            console.assert((original && !modifiedKeys["credits"]) ||
                childBuilders["credits"] !== undefined ||
                updates.credits !== undefined, "credits is a required field");
            console.assert((original && !modifiedKeys["partList"]) ||
                childBuilders["partList"] !== undefined ||
                updates.partList !== undefined, "partList is a required field");
            console.assert((original && !modifiedKeys["movementNumber"]) ||
                childBuilders["movementNumber"] !== undefined ||
                updates.movementNumber !== undefined, "movementNumber is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "ScoreTimewise";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.measures = (spec) => {
            updates["measures"] = spec;
            delete childBuilders["measures;"];
            modifiedKeys["measures"] = true;
            return this;
        };
        this.measuresAt = (idx, build) => {
            makeReference("measures");
            if (frozen["measures"][idx]) {
                throw new Error("Patching measures." + idx + " twice in a builder is unsupported.");
            }
            if (original && original._snapshot && original._snapshot["measures"] && original._snapshot["measures"][idx] && !original["measures"][idx]) {
                // Clone snapshot.
                patches.push({ p: ["measures", idx], li: original._snapshot["measures"] });
            }
            if (typeof build === 'function' && reference["measures"][idx]) {
                let patch = build(new MeasureBuilder(reference["measures"][idx])).patch();
                patches = patches.concat(patch.map(patch => {
                    // TODO: detach?
                    patch.p = ["measures", idx].concat(patch.p);
                    return patch;
                }));
                frozen["measures"][idx] = true;
                return this;
            }
            let update = typeof build === 'function' ? build(new MeasureBuilder(reference["measures"][idx])).build() : build;
            if (original) {
                patches.push({ p: ["measures", idx], li: update });
            }
            else {
                updates["measures"] = reference["measures"]; // TODO: Merge?
            }
            reference["measures"][idx] = update;
            frozen["measures"][idx] = true;
            return this;
        };
        this.measuresSplice = (start, deleteCount, ...items) => {
            makeReference("measures");
            let idx = start;
            if (original) {
                for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
                    if (frozen["measures"][idx]) {
                        throw new Error("Replacing measures." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["measures"][idx];
                    patches.push({ p: ["measures", idx], ld, li: items[idx - start] });
                    frozen["measures"][idx] = true;
                }
                for (; idx < start + deleteCount; ++idx) {
                    if (frozen["measures"][idx]) {
                        throw new Error("Removing measures." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["measures"][idx];
                    patches.push({ p: ["measures", idx], ld });
                }
                for (; idx < start + items.length; ++idx) {
                    patches.push({ p: ["measures", idx], li: items[idx - start] });
                    frozen["measures"][idx] = true;
                }
            }
            reference["measures"].splice(start, deleteCount, ...items);
            updates["measures"] = reference["measures"];
            frozen["measures"].splice(start, deleteCount, ...items.map(i => true));
            return this;
        };
        this.version = (spec) => {
            updates["version"] = spec;
            delete childBuilders["version;"];
            modifiedKeys["version"] = true;
            return this;
        };
        this.movementTitle = (spec) => {
            updates["movementTitle"] = spec;
            delete childBuilders["movementTitle;"];
            modifiedKeys["movementTitle"] = true;
            return this;
        };
        this.identification = (build) => {
            if (typeof build === 'function') {
                delete updates["identification"];
                const builder = build(new IdentificationBuilder(original && original["identification"]));
                if (!original)
                    updates["identification"] = builder.build();
                else
                    childBuilders["identification"] = builder;
            }
            else {
                updates.identification = build;
                delete childBuilders["identification;"];
            }
            modifiedKeys["identification"] = true;
            return this;
        };
        this.defaults = (build) => {
            if (typeof build === 'function') {
                delete updates["defaults"];
                const builder = build(new DefaultsBuilder(original && original["defaults"]));
                if (!original)
                    updates["defaults"] = builder.build();
                else
                    childBuilders["defaults"] = builder;
            }
            else {
                updates.defaults = build;
                delete childBuilders["defaults;"];
            }
            modifiedKeys["defaults"] = true;
            return this;
        };
        this.work = (build) => {
            if (typeof build === 'function') {
                delete updates["work"];
                const builder = build(new WorkBuilder(original && original["work"]));
                if (!original)
                    updates["work"] = builder.build();
                else
                    childBuilders["work"] = builder;
            }
            else {
                updates.work = build;
                delete childBuilders["work;"];
            }
            modifiedKeys["work"] = true;
            return this;
        };
        this.credits = (spec) => {
            updates["credits"] = spec;
            delete childBuilders["credits;"];
            modifiedKeys["credits"] = true;
            return this;
        };
        this.creditsAt = (idx, build) => {
            makeReference("credits");
            if (frozen["credits"][idx]) {
                throw new Error("Patching credits." + idx + " twice in a builder is unsupported.");
            }
            if (original && original._snapshot && original._snapshot["credits"] && original._snapshot["credits"][idx] && !original["credits"][idx]) {
                // Clone snapshot.
                patches.push({ p: ["credits", idx], li: original._snapshot["credits"] });
            }
            if (typeof build === 'function' && reference["credits"][idx]) {
                let patch = build(new CreditBuilder(reference["credits"][idx])).patch();
                patches = patches.concat(patch.map(patch => {
                    // TODO: detach?
                    patch.p = ["credits", idx].concat(patch.p);
                    return patch;
                }));
                frozen["credits"][idx] = true;
                return this;
            }
            let update = typeof build === 'function' ? build(new CreditBuilder(reference["credits"][idx])).build() : build;
            if (original) {
                patches.push({ p: ["credits", idx], li: update });
            }
            else {
                updates["credits"] = reference["credits"]; // TODO: Merge?
            }
            reference["credits"][idx] = update;
            frozen["credits"][idx] = true;
            return this;
        };
        this.creditsSplice = (start, deleteCount, ...items) => {
            makeReference("credits");
            let idx = start;
            if (original) {
                for (; idx < start + deleteCount && idx < start + items.length; ++idx) {
                    if (frozen["credits"][idx]) {
                        throw new Error("Replacing credits." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["credits"][idx];
                    patches.push({ p: ["credits", idx], ld, li: items[idx - start] });
                    frozen["credits"][idx] = true;
                }
                for (; idx < start + deleteCount; ++idx) {
                    if (frozen["credits"][idx]) {
                        throw new Error("Removing credits." + idx + " after patching in a builder is unsupported.");
                    }
                    let ld = reference["credits"][idx];
                    patches.push({ p: ["credits", idx], ld });
                }
                for (; idx < start + items.length; ++idx) {
                    patches.push({ p: ["credits", idx], li: items[idx - start] });
                    frozen["credits"][idx] = true;
                }
            }
            reference["credits"].splice(start, deleteCount, ...items);
            updates["credits"] = reference["credits"];
            frozen["credits"].splice(start, deleteCount, ...items.map(i => true));
            return this;
        };
        this.partList = (spec) => {
            updates["partList"] = spec;
            delete childBuilders["partList;"];
            modifiedKeys["partList"] = true;
            return this;
        };
        this.movementNumber = (spec) => {
            updates["movementNumber"] = spec;
            delete childBuilders["movementNumber;"];
            modifiedKeys["movementNumber"] = true;
            return this;
        };
    }
}
function patchScoreTimewise(base, builder) { return builder(new ScoreTimewiseBuilder(base)).patch(); }
exports.patchScoreTimewise = patchScoreTimewise;
function buildScoreTimewise(builder) { return builder(new ScoreTimewiseBuilder()).build(); }
exports.buildScoreTimewise = buildScoreTimewise;
class MeasureBuilder {
    build;
    patch;
    number;
    implicit;
    width;
    set;
    nonControlling;
    constructor(original) {
        let updates = {};
        let childBuilders = {};
        let modifiedKeys = {};
        let reference = {};
        let frozen = {};
        let patches = [];
        function makeReference(fieldName) {
            if (!reference[fieldName]) {
                if (original) {
                    reference[fieldName] = ((original._snapshot || original)[fieldName] || []).slice();
                }
                else {
                    reference[fieldName] = [];
                }
                frozen[fieldName] = reference[fieldName].map(a => false);
            }
        }
        function checkInvariants() {
            console.assert((original && !modifiedKeys["number"]) ||
                childBuilders["number"] !== undefined ||
                updates.number !== undefined, "number is a required field");
        }
        if (!original) {
            this.build = () => {
                checkInvariants();
                updates._class = "Measure";
                return updates;
            };
        }
        this.patch = () => {
            checkInvariants();
            return makePatch(original, updates, childBuilders, patches, modifiedKeys);
        };
        this.number = (spec) => {
            updates["number"] = spec;
            delete childBuilders["number;"];
            modifiedKeys["number"] = true;
            return this;
        };
        this.implicit = (spec) => {
            updates["implicit"] = spec;
            delete childBuilders["implicit;"];
            modifiedKeys["implicit"] = true;
            return this;
        };
        this.width = (spec) => {
            updates["width"] = spec;
            delete childBuilders["width;"];
            modifiedKeys["width"] = true;
            return this;
        };
        this.set = (key, val) => {
            updates[key] = val;
            modifiedKeys[key] = true;
            return this;
        };
        this.nonControlling = (spec) => {
            updates["nonControlling"] = spec;
            delete childBuilders["nonControlling;"];
            modifiedKeys["nonControlling"] = true;
            return this;
        };
    }
}
function patchMeasure(base, builder) { return builder(new MeasureBuilder(base)).patch(); }
exports.patchMeasure = patchMeasure;
function buildMeasure(builder) { return builder(new MeasureBuilder()).build(); }
exports.buildMeasure = buildMeasure;
